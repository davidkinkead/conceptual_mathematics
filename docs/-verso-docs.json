{"999": "<code>(X.tA âŸ¶ Z.tA) Ã— (X.tD âŸ¶ Z.tD)</code>",
 "998": "<code>Y.tD</code>",
 "997": "<code>Y.tA</code>",
 "996": "<code>(Y.tA âŸ¶ Z.tA) Ã— (Y.tD âŸ¶ Z.tD)</code>",
 "995":
 "<code>{X Y Z : IrreflexiveGraph} â†’\n  { f //\n      (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Y.carrierA) âˆ§\n        (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Y.carrierD) âˆ§ f.2 âŠš X.toSrc = Y.toSrc âŠš f.1 âˆ§ f.2 âŠš X.toTgt = Y.toTgt âŠš f.1 } â†’\n    { f //\n        (âˆ€ x âˆˆ Y.carrierA, f.1 x âˆˆ Z.carrierA) âˆ§\n          (âˆ€ x âˆˆ Y.carrierD, f.2 x âˆˆ Z.carrierD) âˆ§ f.2 âŠš Y.toSrc = Z.toSrc âŠš f.1 âˆ§ f.2 âŠš Y.toTgt = Z.toTgt âŠš f.1 } â†’\n      { f //\n        (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Z.carrierA) âˆ§\n          (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Z.carrierD) âˆ§ f.2 âŠš X.toSrc = Z.toSrc âŠš f.1 âˆ§ f.2 âŠš X.toTgt = Z.toTgt âŠš f.1 }</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "994": "<code>xâœ âˆˆ X.carrierA</code>",
 "993":
 "<code class=\"docstring\">`split_ands` applies `And.intro` until it does not make progress. </code>",
 "992":
 "<code>Prod.mk.{u, v} {Î± : Type u} {Î² : Type v} (fst : Î±) (snd : Î²) : Î± Ã— Î²</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.</code>",
 "991":
 "<code>(X : IrreflexiveGraph) â†’\n  { f //\n    (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ X.carrierA) âˆ§\n      (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ X.carrierD) âˆ§ f.2 âŠš X.toSrc = X.toSrc âŠš f.1 âˆ§ f.2 âŠš X.toTgt = X.toTgt âŠš f.1 }</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "990": "<code>X.tD</code>",
 "99":
 "<code>rfl.{u} {Î± : Sort u} {a : Î±} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>",
 "989": "<code>X.tA</code>",
 "988": "<code>(X.tA âŸ¶ Y.tA) Ã— (X.tD âŸ¶ Y.tD)</code>",
 "987": "<code>IrreflexiveGraph</code>",
 "986":
 "<code>IrreflexiveGraph â†’ IrreflexiveGraph â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "985":
 "<code>CM.instCategoryIrreflexiveGraph : Category.{0, 1} IrreflexiveGraph</code>",
 "984":
 "<code>CM.IrreflexiveGraph.toTgt_mem (self : IrreflexiveGraph) {a : self.tA} : a âˆˆ self.carrierA â†’ self.toTgt a âˆˆ self.carrierD</code>",
 "983":
 "<code>CM.IrreflexiveGraph.toTgt (self : IrreflexiveGraph) : self.tA âŸ¶ self.tD</code>",
 "982": "<code>Set tD</code>",
 "981": "<code>tA âŸ¶ tD</code>",
 "980": "<code>Set tA</code>",
 "98":
 "<code>Or.inl {a b : Prop} (h : a) : a âˆ¨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. </code>",
 "979": "<code>tA</code>",
 "978":
 "<code>CM.IrreflexiveGraph.toSrc_mem (self : IrreflexiveGraph) {a : self.tA} : a âˆˆ self.carrierA â†’ self.toSrc a âˆˆ self.carrierD</code>",
 "977":
 "<code>CM.IrreflexiveGraph.toSrc (self : IrreflexiveGraph) : self.tA âŸ¶ self.tD</code>",
 "976":
 "<code>CM.IrreflexiveGraph.carrierD (self : IrreflexiveGraph) : Set self.tD</code>",
 "975": "<code>CM.IrreflexiveGraph.tD (self : IrreflexiveGraph) : Type</code>",
 "974":
 "<code>CM.IrreflexiveGraph.carrierA (self : IrreflexiveGraph) : Set self.tA</code>",
 "973": "<code>CM.IrreflexiveGraph.tA (self : IrreflexiveGraph) : Type</code>",
 "972": "<code>CM.IrreflexiveGraph : Type 1</code>",
 "971": "<code>CM.ExIII_10.t : X âŸ¶ P</code>",
 "970": "<code>CM.ExIII_10.s : X âŸ¶ P</code>",
 "97":
 "<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>",
 "969": "<code>CM.ExIII_10.P.r : P</code>",
 "968": "<code>CM.ExIII_10.P.q : P</code>",
 "967": "<code>CM.ExIII_10.P.p : P</code>",
 "966": "<code>CM.ExIII_10.P.n : P</code>",
 "965": "<code>CM.ExIII_10.P.m : P</code>",
 "964": "<code>CM.ExIII_10.P.k : P</code>",
 "963": "<code>CM.ExIII_10.P : Type</code>",
 "962": "<code>CM.ExIII_10.X.e : X</code>",
 "961": "<code>CM.ExIII_10.X.d : X</code>",
 "960": "<code>CM.ExIII_10.X.c : X</code>",
 "96":
 "<code class=\"docstring\">`first | tac | ...` runs each `tac` until one succeeds, or else fails. </code>",
 "959": "<code>CM.ExIII_10.X.b : X</code>",
 "958": "<code>CM.ExIII_10.X.a : X</code>",
 "957": "<code>CM.ExIII_10.X : Type</code>",
 "956": "<code>A.aâ‚ƒ = A.aâ‚</code>",
 "955": "<code>(Î± âŠš Î±) A.aâ‚ = ğŸ™ A A.aâ‚</code>",
 "954": "<code>CM.ExIII_9.A.aâ‚‚ : CM.ExIII_9.A</code>",
 "953": "<code>CM.ExIII_9.A.aâ‚ƒ : CM.ExIII_9.A</code>",
 "952": "<code>A.aâ‚ƒ = A.aâ‚‚</code>",
 "951": "<code>CM.ExIII_9.A.aâ‚ : CM.ExIII_9.A</code>",
 "950": "<code>CM.ExIII_9.Î± : CM.ExIII_9.A âŸ¶ CM.ExIII_9.A</code>",
 "95":
 "<code class=\"docstring\">`subst x...` substitutes each hypothesis `x` with a definition found in the local context,\nthen eliminates the hypothesis.\n- If `x` is a local definition, then its definition is used.\n- Otherwise, if there is a hypothesis of the form `x = e` or `e = x`,\n  then `e` is used for the definition of `x`.\n\nIf `h : a = b`, then `subst h` may be used if either `a` or `b` unfolds to a local hypothesis.\nThis is similar to the `cases h` tactic.\n\nSee also: `subst_vars` for substituting all local hypotheses that have a defining equation.\n</code>",
 "949": "<code>(Î± âŠš Î±) A.aâ‚ = Î± A.aâ‚</code>",
 "948": "<code>CM.ExIII_9.Î± : A âŸ¶ A</code>",
 "947": "<code>CM.ExIII_9.A.aâ‚ƒ : A</code>",
 "946": "<code>CM.ExIII_9.A.aâ‚‚ : A</code>",
 "945": "<code>CM.ExIII_9.A.aâ‚ : A</code>",
 "944": "<code>CM.ExIII_9.A : Type</code>",
 "943": "<code>5 âˆ£ 1</code>",
 "942": "<code>(Î± âŠš Î±inv) 1 = ğŸ™ â„¤ 1</code>",
 "941": "<code>Î±inv âŠš Î± = ğŸ™ â„¤</code>",
 "940": "<code>Î± âŠš Î±inv = ğŸ™ â„¤</code>",
 "94":
 "<code class=\"docstring\">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.\nIf the tactic fails on any goal, the entire `all_goals` tactic fails.\n\nSee also `any_goals tac`.\n</code>",
 "939": "<code>IsIso Î±</code>",
 "938": "<code>CM.ExIII_7.Î± : â„¤ âŸ¶ â„¤</code>",
 "937":
 "<code>âˆƒ inv, inv âŠš Î± = ğŸ™ â„¤ âˆ§ Î± âŠš inv = ğŸ™ â„¤</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "936": "<code>â„¤ âŸ¶ â„¤</code>",
 "935": "<code>CM.ExIII_6.Î± : â„¤ âŸ¶ â„¤</code>",
 "934": "<code>Iff.symm {a b : Prop} (h : a â†” b) : b â†” a</code>",
 "933": "<code>|a| = a</code>",
 "932": "<code>AddRightMono Î±</code>",
 "931": "<code>AddLeftMono Î±</code>",
 "930": "<code>AddGroup Î±</code>",
 "93": "<code>aâœ = \"Sam\"</code>",
 "929": "<code>Lattice Î±</code>",
 "928":
 "<code>AddRightMono.{u_1} (M : Type u_1) [Add M] [LE M] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Typeclass for monotonicity of addition on the right,\nnamely `aâ‚ â‰¤ aâ‚‚ â†’ aâ‚ + b â‰¤ aâ‚‚ + b`.\n\nYou should usually not use this very granular typeclass directly, but rather a typeclass like\n`OrderedAddCommMonoid`. </code>",
 "927":
 "<code>AddLeftMono.{u_1} (M : Type u_1) [Add M] [LE M] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Typeclass for monotonicity of addition on the left,\nnamely `bâ‚ â‰¤ bâ‚‚ â†’ a + bâ‚ â‰¤ a + bâ‚‚`.\n\nYou should usually not use this very granular typeclass directly, but rather a typeclass like\n`OrderedAddCommMonoid`. </code>",
 "926":
 "<code>AddGroup.{u} (A : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">An `AddGroup` is an `AddMonoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition.\n\nUse `AddGroup.ofLeftAxioms` or `AddGroup.ofRightAxioms` to define an\nadditive group structure on a type with the minimum proof obligations.\n</code>",
 "925":
 "<code>Lattice.{u} (Î± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A lattice is a join-semilattice which is also a meet-semilattice. </code>",
 "924": "<code class=\"docstring\">The universe parameter u_1</code>",
 "923":
 "<code>abs_iff_nonneg.{u_1} {Î± : Type u_1} [Lattice Î±] [AddGroup Î±] {a : Î±} [AddLeftMono Î±] [AddRightMono Î±] : 0 â‰¤ a â†” |a| = a</code>",
 "922":
 "<code>abs_of_nonneg.{u_1} {Î± : Type u_1} [Lattice Î±] [AddGroup Î±] {a : Î±} [AddLeftMono Î±] (h : 0 â‰¤ a) : |a| = a</code>",
 "921":
 "<code>abs_nonneg.{u_1} {Î± : Type u_1} [Lattice Î±] [AddGroup Î±] [AddLeftMono Î±] [AddRightMono Î±] (a : Î±) : 0 â‰¤ |a|</code>",
 "920": "<code>|x| = x</code>",
 "92": "<code>aâœ = \"Mary\"</code>",
 "919": "<code>|(|(-1)|)| = -1</code>",
 "918": "<code>(Î± âŠš Î±) (-1) = ğŸ™ â„¤ (-1)</code>",
 "917": "<code>IsInvolution Î±</code>",
 "916":
 "<code>abs_abs.{u_1} {Î± : Type u_1} [Lattice Î±] [AddGroup Î±] [AddLeftMono Î±] [AddRightMono Î±] (a : Î±) : |(|a|)| = |a|</code>",
 "915": "<code>Î± âŠš Î± = Î±</code>",
 "914": "<code>CM.ExIII_5.Î± : â„¤ âŸ¶ â„¤</code>",
 "913": "<code>a = 0</code>",
 "912": "<code>IsOrderedAddMonoid Î±</code>",
 "911": "<code>LinearOrder Î±</code>",
 "910": "<code>AddCommGroup Î±</code>",
 "91": "<code>aâœ = \"John\"</code>",
 "909":
 "<code>IsOrderedAddMonoid.{u_2} (Î± : Type u_2) [AddCommMonoid Î±] [PartialOrder Î±] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An ordered (additive) monoid is a monoid with a partial order such that addition is monotone. </code>",
 "908":
 "<code>LinearOrder.{u_2} (Î± : Type u_2) : Type u_2</code><span class=\"sep\"></span><code class=\"docstring\">A linear order is reflexive, transitive, antisymmetric and total relation `â‰¤`.\nWe assume that every linear ordered type has decidable `(â‰¤)`, `(&lt;)`, and `(=)`. </code>",
 "907":
 "<code>AddCommGroup.{u} (G : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">An additive commutative group is an additive group with commutative `(+)`. </code>",
 "906":
 "<code>eq_zero_iff_neg_eq.{u} {Î± : Type u} [AddCommGroup Î±] [LinearOrder Î±] [IsOrderedAddMonoid Î±] {a : Î±} : -a = a â†” a = 0</code>",
 "905": "<code>neg_zero.{u_1} {G : Type u_1} [NegZeroClass G] : -0 = 0</code>",
 "904": "<code>x = 0</code>",
 "903":
 "<code>eq_zero_of_neg_eq.{u} {Î± : Type u} [AddCommGroup Î±] [LinearOrder Î±] [IsOrderedAddMonoid Î±] {a : Î±} (h : -a = a) : a = 0</code>",
 "902":
 "<code>Function.IsFixedPt.{uâ‚} {Î± : Type uâ‚} (f : Î± â†’ Î±) (x : Î±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A point `x` is a fixed point of `f : Î± â†’ Î±` if `f x = x`. </code>",
 "901":
 "<code>Int : Type</code><span class=\"sep\"></span><code class=\"docstring\">The integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores â€œsmallâ€ signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A â€œsmall numberâ€ is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n</code>",
 "900": "<code>Î± âŠš Î± = ğŸ™ â„¤</code>",
 "90":
 "<code class=\"docstring\">`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a âˆ§ b âˆ§ c âˆ¨ d` or\n`h2 : âˆƒ x y, trans_rel R x y`. Usual usage might be `rcases h1 with âŸ¨ha, hb, hcâŸ© | hd` or\n`rcases h2 with âŸ¨x, y, _ | âŸ¨z, hxz, hzyâŸ©âŸ©` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `âŸ¨p1, p2, p3âŸ©`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a âˆ§ b âˆ§ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@âŸ¨p1, p2, p3âŸ©` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a âˆ¨ b âˆ¨ c`.\n\nA pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on\n`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n</code>",
 "9": "<code>CM.ExI_1.B.bâ‚ : B</code>",
 "899": "<code>(Î± âŠš Î±) 1 = Î± 1</code>",
 "898": "<code>IsIdempotent Î±</code>",
 "897": "<code>â„¤</code>",
 "896": "<code>CM.ExIII_4.Î± : â„¤ âŸ¶ â„¤</code>",
 "895": "<code>Î² âŠš Î± = ğŸ™ A</code>",
 "894": "<code>Î± âŠš Î± = Î±</code>",
 "893":
 "<code>{X Y : InvolEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a bundled function to a morphism of `C`. </code>",
 "892":
 "<code>{X Y : InvolEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "891":
 "<code>{X Y Z : InvolEndomap} â†’\n  EndomapHom X.toEndomap Y.toEndomap â†’ EndomapHom Y.toEndomap Z.toEndomap â†’ EndomapHom X.toEndomap Z.toEndomap</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "890":
 "<code>(X : InvolEndomap) â†’ EndomapHom X.toEndomap X.toEndomap</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "89": "<code>aâœ = \"John\" âˆ¨ aâœ = \"Mary\" âˆ¨ aâœ = \"Sam\"</code>",
 "889": "<code>InvolEndomap</code>",
 "888":
 "<code>InvolEndomap â†’ InvolEndomap â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "887": "<code>CM.instCatInvolEndomap : Category.{0, 1} InvolEndomap</code>",
 "886":
 "<code>CM.InvolEndomap.invol (self : InvolEndomap) : self.toEnd âŠš self.toEnd = ğŸ™ self.carrier</code>",
 "885": "<code>CM.InvolEndomap : Type 1</code>",
 "884":
 "<code>{X Y : InvEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a bundled function to a morphism of `C`. </code>",
 "883":
 "<code>{X Y : InvEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "882":
 "<code>{X Y Z : InvEndomap} â†’\n  EndomapHom X.toEndomap Y.toEndomap â†’ EndomapHom Y.toEndomap Z.toEndomap â†’ EndomapHom X.toEndomap Z.toEndomap</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "881":
 "<code>(X : InvEndomap) â†’ EndomapHom X.toEndomap X.toEndomap</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "880": "<code>CM.InvEndomap.toEndomap (self : InvEndomap) : Endomap</code>",
 "88":
 "<code>Finset.mem_singleton.{u_1} {Î± : Type u_1} {a b : Î±} : b âˆˆ {a} â†” b = a</code>",
 "879": "<code>InvEndomap</code>",
 "878":
 "<code>InvEndomap â†’ InvEndomap â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "877": "<code>CM.instCatInvEndomap : Category.{0, 1} InvEndomap</code>",
 "876":
 "<code>CM.InvEndomap.inv (self : InvEndomap) : âˆƒ inv, inv âŠš self.toEnd = ğŸ™ self.carrier âˆ§ self.toEnd âŠš inv = ğŸ™ self.carrier</code>",
 "875": "<code>CM.InvEndomap : Type 1</code>",
 "874":
 "<code>{X Y : IdemEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a bundled function to a morphism of `C`. </code>",
 "873":
 "<code>{X Y : IdemEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "872":
 "<code>{X Y Z : IdemEndomap} â†’\n  EndomapHom X.toEndomap Y.toEndomap â†’ EndomapHom Y.toEndomap Z.toEndomap â†’ EndomapHom X.toEndomap Z.toEndomap</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "871":
 "<code>(X : IdemEndomap) â†’ EndomapHom X.toEndomap X.toEndomap</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "870": "<code>CM.IdemEndomap.toEndomap (self : IdemEndomap) : Endomap</code>",
 "87":
 "<code>Singleton.singleton.{u, v} {Î± : outParam (Type u)} {Î² : Type v} [self : Singleton Î± Î²] : Î± â†’ Î²</code><span class=\"sep\"></span><code class=\"docstring\">`singleton x` is a collection with the single element `x` (notation: `{x}`). \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.</code>",
 "869": "<code>IdemEndomap</code>",
 "868":
 "<code>IdemEndomap â†’ IdemEndomap â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "867": "<code>CM.instCatIdemEndomap : Category.{0, 1} IdemEndomap</code>",
 "866": "<code>carrier âŸ¶ carrier</code>",
 "865":
 "<code>CM.IdemEndomap.idem (self : IdemEndomap) : self.toEnd âŠš self.toEnd = self.toEnd</code>",
 "864": "<code>CM.IdemEndomap : Type 1</code>",
 "863":
 "<code>{X Y : Endomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a bundled function to a morphism of `C`. </code>",
 "862":
 "<code>{X Y : Endomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "861":
 "<code>(X âŸ¶ Y) â†’ (X.carrier âŸ¶ Y.carrier)</code><span class=\"sep\"></span><code class=\"docstring\">The coercion from `F` to a function. </code>",
 "860":
 "<code>{X Y Z : Endomap} â†’ EndomapHom X Y â†’ EndomapHom Y Z â†’ EndomapHom X Z</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "86":
 "<code>Or (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Or a b`, or `a âˆ¨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a â†’ a âˆ¨ b` and `Or.inr : b â†’ a âˆ¨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `âˆ¨` in identifiers is `or`.\n\n * The recommended spelling of `\\/` in identifiers is `or` (prefer `âˆ¨` over `\\/`).</code>",
 "859":
 "<code>(X : Endomap) â†’ EndomapHom X X</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "858":
 "<code>Endomap â†’ Endomap â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "857": "<code>CM.instCatEndomap : Category.{0, 1} Endomap</code>",
 "856": "<code>EndomapHom Y Z</code>",
 "855": "<code>EndomapHom X Y</code>",
 "854":
 "<code>CM.EndomapHom.comp {X Y Z : Endomap} (f : EndomapHom X Y) (g : EndomapHom Y Z) : EndomapHom X Z</code>",
 "853": "<code>CM.EndomapHom.id (X : Endomap) : EndomapHom X X</code>",
 "852": "<code>X.carrier âŸ¶ Y.carrier</code>",
 "851": "<code>Endomap</code>",
 "850": "<code>CM.EndomapHom (X Y : Endomap) : Type</code>",
 "85": "<code>aâœ = \"John\" âˆ¨ aâœ = \"Mary\" âˆ¨ aâœ âˆˆ {\"Sam\"}</code>",
 "849":
 "<code>CM.Endomap.toEnd (self : Endomap) : self.carrier âŸ¶ self.carrier</code>",
 "848": "<code>CM.Endomap.carrier (self : Endomap) : Type</code>",
 "847": "<code>CM.Endomap : Type 1</code>",
 "846":
 "<code>{X Y : SetWithInvEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a bundled function to a morphism of `C`. </code>",
 "845":
 "<code>{X Y : SetWithInvEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "844":
 "<code>{X Y Z : SetWithInvEndomap} â†’\n  SetWithEndomapHom X.toSetWithEndomap Y.toSetWithEndomap â†’\n    SetWithEndomapHom Y.toSetWithEndomap Z.toSetWithEndomap â†’ SetWithEndomapHom X.toSetWithEndomap Z.toSetWithEndomap</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "843":
 "<code>(X : SetWithInvEndomap) â†’ SetWithEndomapHom X.toSetWithEndomap X.toSetWithEndomap</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "842":
 "<code>CM.SetWithInvEndomap.toSetWithEndomap (self : SetWithInvEndomap) : SetWithEndomap</code>",
 "841": "<code>SetWithInvEndomap</code>",
 "840":
 "<code>SetWithInvEndomap â†’ SetWithInvEndomap â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "84":
 "<code>Finset.mem_insert.{u_1} {Î± : Type u_1} [DecidableEq Î±] {s : Finset Î±} {a b : Î±} : a âˆˆ insert b s â†” a = b âˆ¨ a âˆˆ s</code>",
 "839":
 "<code>CM.instCatSetWithInvEndomap : Category.{0, 1} SetWithInvEndomap</code>",
 "838":
 "<code>CM.SetWithInvEndomap.inv (self : SetWithInvEndomap) : âˆƒ inv, inv âŠš self.toEnd = ğŸ™ self.t âˆ§ self.toEnd âŠš inv = ğŸ™ self.t</code>",
 "837": "<code>CM.SetWithInvEndomap : Type 1</code>",
 "836":
 "<code>{X Y : SetWithIdemEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a bundled function to a morphism of `C`. </code>",
 "835":
 "<code>{X Y : SetWithIdemEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "834":
 "<code>{X Y Z : SetWithIdemEndomap} â†’\n  SetWithEndomapHom X.toSetWithEndomap Y.toSetWithEndomap â†’\n    SetWithEndomapHom Y.toSetWithEndomap Z.toSetWithEndomap â†’ SetWithEndomapHom X.toSetWithEndomap Z.toSetWithEndomap</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "833":
 "<code>(X : SetWithIdemEndomap) â†’ SetWithEndomapHom X.toSetWithEndomap X.toSetWithEndomap</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "832":
 "<code>CM.SetWithIdemEndomap.toSetWithEndomap (self : SetWithIdemEndomap) : SetWithEndomap</code>",
 "831": "<code>SetWithIdemEndomap</code>",
 "830":
 "<code>SetWithIdemEndomap â†’ SetWithIdemEndomap â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "83":
 "<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>",
 "829":
 "<code>CM.instCatSetWithIdemEndomap : Category.{0, 1} SetWithIdemEndomap</code>",
 "828":
 "<code>CM.SetWithIdemEndomap.idem (self : SetWithIdemEndomap) : self.toEnd âŠš self.toEnd = self.toEnd</code>",
 "827": "<code>CM.SetWithIdemEndomap : Type 1</code>",
 "826": "<code>g âŠš Î² = Î³ âŠš g</code>",
 "825": "<code>f âŠš Î± = Î² âŠš f</code>",
 "824": "<code>Z âŸ¶ Z</code>",
 "823": "<code>Y âŸ¶ Y</code>",
 "822":
 "<code>{X Y : SetWithEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a bundled function to a morphism of `C`. </code>",
 "821": "<code>Xâœ âŸ¶ Yâœ</code>",
 "820":
 "<code>{X Y : SetWithEndomap} â†’ (X âŸ¶ Y) â†’ (X âŸ¶ Y)</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "82":
 "<code class=\"docstring\">`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n</code>",
 "819":
 "<code>CategoryTheory.ConcreteCategory.{w, v, u, u_1} (C : Type u) [Category.{v, u} C] (FC : outParam (C â†’ C â†’ Type u_1))\n  {CC : outParam (C â†’ Type w)} [outParam ((X Y : C) â†’ FunLike (FC X Y) (CC X) (CC Y))] : Type (max (max u u_1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A concrete category is a category `C` where objects correspond to types and morphisms to\n(bundled) functions between those types.\n\nIn other words, it has a fixed faithful functor `forget : C â¥¤ Type`.\n\nNote that `ConcreteCategory` potentially depends on three independent universe levels,\n* the universe level `w` appearing in `forget : C â¥¤ Type w`\n* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)\n* the universe level `u` of the objects (i.e `C : Type u`)\nThey are specified that order, to avoid unnecessary universe annotations.\n</code>",
 "818": "<code>(fun f â†¦ â†‘f) xâœÂ¹ = (fun f â†¦ â†‘f) xâœ</code>",
 "817":
 "<code>âˆ€ (x x_1 : X âŸ¶ Y), (fun f â†¦ â†‘f) x = (fun f â†¦ â†‘f) x_1 â†’ x = x_1</code><span class=\"sep\"></span><code class=\"docstring\">The coercion to functions must be injective. </code>",
 "816":
 "<code>(X âŸ¶ Y) â†’ (X.t âŸ¶ Y.t)</code><span class=\"sep\"></span><code class=\"docstring\">The coercion from `F` to a function. </code>",
 "815":
 "<code>FunLike.{u_1, u_2, u_3} (F : Sort u_1) (Î± : Sort u_2) (Î² : Sort u_3) : Sort (max (max (max 1 u_1) u_2) u_3)</code><span class=\"sep\"></span><code class=\"docstring\">The class `FunLike F Î± Î²` (`Fun`ction-`Like`) expresses that terms of type `F`\nhave an injective coercion to functions from `Î±` to `Î²`.\n`FunLike` is the non-dependent version of `DFunLike`.\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `ZeroHomClass`, `MulHomClass`, `MonoidHomClass`, ....\n</code>",
 "814":
 "<code>{X Y Z : SetWithEndomap} â†’ SetWithEndomapHom X Y â†’ SetWithEndomapHom Y Z â†’ SetWithEndomapHom X Z</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "813":
 "<code>(X : SetWithEndomap) â†’ SetWithEndomapHom X X</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "812":
 "<code>SetWithEndomap â†’ SetWithEndomap â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "811":
 "<code>CM.instCatSetWithEndomap : Category.{0, 1} SetWithEndomap</code>",
 "810": "<code>x âˆˆ X.carrier</code>",
 "81":
 "<code>Insert.insert.{u, v} {Î± : outParam (Type u)} {Î³ : Type v} [self : Insert Î± Î³] : Î± â†’ Î³ â†’ Î³</code><span class=\"sep\"></span><code class=\"docstring\">`insert x xs` inserts the element `x` into the collection `xs`. </code>",
 "809": "<code>â†‘g âŠš Y.toEnd = Z.toEnd âŠš â†‘g</code>",
 "808": "<code>âˆ€ x âˆˆ Y.carrier, â†‘g x âˆˆ Z.carrier</code>",
 "807":
 "<code>Subtype.property.{u} {Î± : Sort u} {p : Î± â†’ Prop} (self : Subtype p) : p â†‘self</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "806": "<code>â†‘f âŠš X.toEnd = Y.toEnd âŠš â†‘f</code>",
 "805": "<code>âˆ€ x âˆˆ X.carrier, â†‘f x âˆˆ Y.carrier</code>",
 "804": "<code>SetWithEndomapHom Y Z</code>",
 "803": "<code>SetWithEndomapHom X Y</code>",
 "802":
 "<code>CM.SetWithEndomapHom.comp {X Y Z : SetWithEndomap} (f : SetWithEndomapHom X Y) (g : SetWithEndomapHom Y Z) :\n  SetWithEndomapHom X Z</code>",
 "801":
 "<code>CM.SetWithEndomapHom.id (X : SetWithEndomap) : SetWithEndomapHom X X</code>",
 "800": "<code>SetWithEndomap</code>",
 "80": "<code>aâœ âˆˆ {\"John\", \"Mary\", \"Sam\"}</code>",
 "8": "<code>CM.ExI_1.B : Type</code>",
 "799": "<code>CM.SetWithEndomapHom (X Y : SetWithEndomap) : Type</code>",
 "798": "<code>t âŸ¶ t</code>",
 "797":
 "<code>CM.SetWithEndomap.toEnd_mem (self : SetWithEndomap) {a : self.t} : a âˆˆ self.carrier â†’ self.toEnd a âˆˆ self.carrier</code>",
 "796":
 "<code>CM.SetWithEndomap.toEnd (self : SetWithEndomap) : self.t âŸ¶ self.t</code>",
 "795":
 "<code>CM.SetWithEndomap.carrier (self : SetWithEndomap) : Set self.t</code>",
 "794": "<code>CM.SetWithEndomap.t (self : SetWithEndomap) : Type</code>",
 "793": "<code>CM.SetWithEndomap : Type 1</code>",
 "792": "<code>âˆ€ (x : â„), f x = 4 * x - 7</code>",
 "791": "<code>CM.Test1_1.s : B âŸ¶ A</code>",
 "790": "<code>CM.Test1_1.r : A âŸ¶ B</code>",
 "79":
 "<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`\n* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>",
 "789": "<code>CM.Test1_1.B.b : B</code>",
 "788": "<code>CM.Test1_1.B : Type</code>",
 "787": "<code>CM.Test1_1.e : A âŸ¶ A</code>",
 "786":
 "<code>âˆƒ inv, inv âŠš f = ğŸ™ A âˆ§ f âŠš inv = ğŸ™ A</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "785": "<code>CM.Test1_1.finv : A âŸ¶ A</code>",
 "784": "<code>CM.Test1_1.f : A âŸ¶ A</code>",
 "783": "<code>CM.Test1_1.A.Andrea : A</code>",
 "782": "<code>CM.Test1_1.A.Aurelio : A</code>",
 "781": "<code>CM.Test1_1.A.Mara : A</code>",
 "780": "<code>CM.Test1_1.A : Type</code>",
 "78": "<code>aâœ âˆˆ A</code>",
 "779":
 "<code>CM.IsInvolution.invol.{u, v} {ğ’ : Type u} {instâœ : Category.{v, u} ğ’} {A : ğ’} {f : A âŸ¶ A} [self : IsInvolution f] :\n  f âŠš f = ğŸ™ A</code>",
 "778":
 "<code>CM.IsInvolution.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A : ğ’} (f : A âŸ¶ A) : Prop</code>",
 "777":
 "<code>CM.Involution.invol.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A : ğ’} (self : Involution A) : self.f âŠš self.f = ğŸ™ A</code>",
 "776":
 "<code>CM.Involution.f.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A : ğ’} (self : Involution A) : A âŸ¶ A</code>",
 "775":
 "<code>CM.Involution.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] (A : ğ’) : Type v</code>",
 "774":
 "<code>IsEmpty.false.{u_4} {Î± : Sort u_4} [self : IsEmpty Î±] : âˆ€ (a : Î±), False</code>",
 "773":
 "<code>IsEmpty.mk.{u_4} {Î± : Sort u_4} (false : âˆ€ (a : Î±), False) : IsEmpty Î±</code>",
 "772": "<code>IsEmpty A</code>",
 "771":
 "<code>Fintype.card_eq_zero_iff.{u_1} {Î± : Type u_1} [Fintype Î±] : Fintype.card Î± = 0 â†” IsEmpty Î±</code>",
 "770":
 "<code>Cardinal.mk_fintype.{u} (Î± : Type u) [h : Fintype Î±] : #Î± = â†‘(Fintype.card Î±)</code>",
 "77":
 "<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`. It is equivalent to `intro _`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, given a type ascription, or matched against a pattern:\n  ```lean\n  -- ... âŠ¢ Î± Ã— Î² â†’ ...\n  intro (a, b)\n  -- ..., a : Î±, b : Î² âŠ¢ ...\n  ```\n* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side\n  is a variable.\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>",
 "769": "<code>Fintype Î±</code>",
 "768":
 "<code>IsEmpty.{u_4} (Î± : Sort u_4) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsEmpty Î±` expresses that `Î±` is empty. </code>",
 "767": "<code>Cardinal.{u}</code>",
 "766":
 "<code>CM.CM_Fintype.h_cardinal_zero_eq_zero_iff.{u} {Î± : Type u} [Fintype Î±] : #Î± = 0 â†” IsEmpty Î±</code>",
 "765":
 "<code>Cardinal.mk_le_of_injective.{u} {Î± Î² : Type u} {f : Î± â†’ Î²} (hf : Function.Injective f) : #Î± â‰¤ #Î²</code>",
 "764": "<code>Function.Injective j</code>",
 "763":
 "<code>CategoryTheory.SplitMono.mono.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (sm : SplitMono f) :\n  Mono f</code>",
 "762": "<code>Mono j</code>",
 "761":
 "<code>X âŸ¶ A</code><span class=\"sep\"></span><code class=\"docstring\">The map splitting `f` </code>",
 "760": "<code>Retraction j</code>",
 "76": "<code>String</code>",
 "759":
 "<code>Cardinal.mk_le_of_surjective.{u} {Î± Î² : Type u} {f : Î± â†’ Î²} (hf : Function.Surjective f) : #Î² â‰¤ #Î±</code>",
 "758":
 "<code>Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. </code>",
 "757": "<code>Function.Surjective p</code>",
 "756":
 "<code>CategoryTheory.SplitEpi.epi.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (se : SplitEpi f) : Epi f</code>",
 "755": "<code>Epi p</code>",
 "754":
 "<code>A âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The map splitting `f` </code>",
 "753": "<code>Section p</code>",
 "752":
 "<code>Cardinal.mk_le_of_surjective.{u} {Î± Î² : Type u} {f : Î± â†’ Î²} (hf : Function.Surjective f) : Cardinal.mk Î² â‰¤ Cardinal.mk Î±</code>",
 "751":
 "<code>Cardinal.mk.{u} : Type u â†’ Cardinal.{u}</code><span class=\"sep\"></span><code class=\"docstring\">The cardinal number of a type </code>",
 "750":
 "<code>CategoryTheory.mono_iff_injective.{u} {X Y : Type u} (f : X âŸ¶ Y) : Mono f â†” Function.Injective f</code><span class=\"sep\"></span><code class=\"docstring\">A morphism in `Type` is a monomorphism if and only if it is injective. </code>",
 "75":
 "<code>âˆ€ a âˆˆ A,\n  (match a with\n    | \"John\" =&gt; \"eggs\"\n    | \"Mary\" =&gt; \"eggs\"\n    | x =&gt; \"coffee\") âˆˆ\n    B</code>",
 "749": "<code>j aâ‚ = j aâ‚‚</code>",
 "748":
 "<code>CategoryTheory.epi_iff_surjective.{u} {X Y : Type u} (f : X âŸ¶ Y) : Epi f â†” Function.Surjective f</code><span class=\"sep\"></span><code class=\"docstring\">A morphism in `Type` is an epimorphism if and only if it is surjective. </code>",
 "747": "<code>Î²</code>",
 "746": "<code>Sort u_2</code>",
 "745":
 "<code class=\"docstring\">A specific universe in Lean's infinite hierarchy of universes. </code>",
 "744": "<code>Sort u_1</code>",
 "743": "<code>Fintype X</code>",
 "742": "<code>Fintype A</code>",
 "741": "<code>X</code>",
 "740": "<code>X âŸ¶ X</code>",
 "74": "<code>String â†’ String</code>",
 "739": "<code>p âŠš j = ğŸ™ A</code>",
 "738": "<code>X âŸ¶ A</code>",
 "737": "<code>A âŸ¶ X</code>",
 "736": "<code>1 â‰¤ â†‘n + 1</code>",
 "735": "<code>â†‘n + 1 = 0.5</code>",
 "734": "<code>f n.succ = ğŸ™ B 0.5</code>",
 "733": "<code>s 0.5 = n.succ</code>",
 "732": "<code>0 = 0.5</code>",
 "731": "<code>f Nat.zero = ğŸ™ B 0.5</code>",
 "730": "<code>s 0.5 = Nat.zero</code>",
 "73": "<code>CM.CM_Finset.f : Map A B</code>",
 "729": "<code>(f âŠš s) 0.5 = ğŸ™ B 0.5</code>",
 "728":
 "<code>Nat.floor_natCast.{u_1} {R : Type u_1} [Semiring R] [LinearOrder R] [FloorSemiring R] [IsStrictOrderedRing R] (n : â„•) :\n  âŒŠâ†‘nâŒ‹â‚Š = n</code>",
 "727":
 "<code class=\"docstring\">The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : â„¤\nh : â†‘a + â†‘b &lt; (10 : â„š)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b &lt; 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n</code>",
 "726":
 "<code>âŒŠ|match n with\n      | 0 =&gt; 0\n      | Nat.succ n =&gt; â†‘n + 1|âŒ‹â‚Š =\n  n</code>",
 "725":
 "<code>Nat.floor_zero.{u_1} {R : Type u_1} [Semiring R] [LinearOrder R] [FloorSemiring R] [IsStrictOrderedRing R] : âŒŠ0âŒ‹â‚Š = 0</code>",
 "724":
 "<code>abs_zero.{u_1} {Î± : Type u_1} [Lattice Î±] [AddGroup Î±] [AddLeftMono Î±] : |0| = 0</code>",
 "723":
 "<code>Nat.zero : â„•</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/4.24.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "722":
 "<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>",
 "721":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ihâ‚` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,\n  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tacâ‚ | succ x' ih =&gt; tacâ‚‚`\n  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.\n</code>",
 "720":
 "<code>Nat.succ (n : â„•) : â„•</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.24.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "72":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `háµ¢`'s, where the `háµ¢`'s are expressions.-\n- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.\n- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idáµ¢`.\n- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If\n  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis\n  `háµ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "719":
 "<code>Nat.floor.{u_2} {Î± : Type u_2} [Semiring Î±] [PartialOrder Î±] [FloorSemiring Î±] : Î± â†’ â„•</code><span class=\"sep\"></span><code class=\"docstring\">`âŒŠaâŒ‹â‚Š` is the greatest natural `n` such that `n â‰¤ a`. If `a` is negative, then `âŒŠaâŒ‹â‚Š = 0`. </code>",
 "718":
 "<code>abs.{u_1} {Î± : Type u_1} [Lattice Î±] [AddGroup Î±] (a : Î±) : Î±</code><span class=\"sep\"></span><code class=\"docstring\">`abs a`, denoted `|a|`, is the absolute value of `a` </code>",
 "717": "<code>CM.Â«Quiz_1*Â».r : B âŸ¶ A</code>",
 "716": "<code>CM.Â«Quiz_1*Â».f : A âŸ¶ B</code>",
 "715": "<code>CM.Â«Quiz_1*Â».B : Type</code>",
 "714": "<code>CM.Â«Quiz_1*Â».A : Type</code>",
 "713": "<code>(q âŠš p) âŠš q âŠš p = q âŠš p</code>",
 "712": "<code>(p âŠš q) âŠš p âŠš q = p âŠš q</code>",
 "711": "<code>p âŠš q âŠš p = p</code>",
 "710": "<code>D âŸ¶ C</code>",
 "71":
 "<code>Membership.mem.{u, v} {Î± : outParam (Type u)} {Î³ : Type v} [self : Membership Î± Î³] : Î³ â†’ Î± â†’ Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a âˆˆ s : Prop` where `a : Î±`, `s : Î³`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `âˆˆ` in identifiers is `mem`.</code>",
 "709": "<code>C âŸ¶ D</code>",
 "708": "<code>CM.Quiz_1.B.bâ‚‚ : CM.Quiz_1.B</code>",
 "707": "<code>(f âŠš s) B.bâ‚‚ = ğŸ™ B B.bâ‚‚</code>",
 "706": "<code>CM.Quiz_1.r : B âŸ¶ A</code>",
 "705": "<code>CM.Quiz_1.f : A âŸ¶ B</code>",
 "704": "<code>CM.Quiz_1.B.bâ‚‚ : B</code>",
 "703": "<code>CM.Quiz_1.B.bâ‚ : B</code>",
 "702": "<code>CM.Quiz_1.B : Type</code>",
 "701": "<code>CM.Quiz_1.A.a : A</code>",
 "700": "<code>CM.Quiz_1.A : Type</code>",
 "70": "<code>Unit</code>",
 "7": "<code>CM.ExI_1.A.aâ‚ƒ : A</code>",
 "699":
 "<code>(hsr'.r âŠš hsr.s) âŠš hsr.r âŠš hsr'.s = ğŸ™ hsr'.A</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "698":
 "<code class=\"docstring\">`rw [rules]` applies the given list of rewrite rules to the target.\nSee the `rw` tactic for more information. </code>",
 "697":
 "<code class=\"docstring\">* `arg i` traverses into the `i`'th argument of the target. For example if the\n  target is `f a b c d` then `arg 1` traverses to `a` and `arg 3` traverses to `c`.\n  The index may be negative; `arg -1` traverses into the last argument,\n  `arg -2` into the second-to-last argument, and so on.\n* `arg @i` is the same as `arg i` but it counts all arguments instead of just the\n  explicit arguments.\n* `arg 0` traverses into the function. If the target is `f a b c d`, `arg 0` traverses into `f`. </code>",
 "696":
 "<code class=\"docstring\">Traverses into the left subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the second to last argument.\nIt is a synonym for `arg -2`.\n</code>",
 "695": "<code>IsIdempotent e</code>",
 "694":
 "<code>(hsr.r âŠš hsr'.s) âŠš hsr'.r âŠš hsr.s = ğŸ™ hsr.A</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "693":
 "<code>hsr'.A âŸ¶ hsr.A</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "692":
 "<code>hsr.A âŸ¶ hsr'.A</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "691": "<code>Splitting e</code>",
 "690":
 "<code>CM.Splitting.sr.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {B : ğ’} {e : B âŸ¶ B} [IsIdempotent e] (self : Splitting e) :\n  self.s âŠš self.r = e</code>",
 "69": "<code>âˆ€ a âˆˆ One, \"John\" âˆˆ A</code>",
 "689":
 "<code>CM.Splitting.rs.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {B : ğ’} {e : B âŸ¶ B} [IsIdempotent e] (self : Splitting e) :\n  self.r âŠš self.s = ğŸ™ self.A</code>",
 "688":
 "<code>CM.Splitting.r.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {B : ğ’} {e : B âŸ¶ B} [IsIdempotent e] (self : Splitting e) :\n  B âŸ¶ self.A</code>",
 "687":
 "<code>CM.Splitting.s.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {B : ğ’} {e : B âŸ¶ B} [IsIdempotent e] (self : Splitting e) :\n  self.A âŸ¶ B</code>",
 "686":
 "<code>CM.Splitting.A.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {B : ğ’} {e : B âŸ¶ B} [IsIdempotent e] (self : Splitting e) : ğ’</code>",
 "685":
 "<code>CM.Splitting.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {B : ğ’} (e : B âŸ¶ B) [IsIdempotent e] : Type (max u v)</code>",
 "684":
 "<code>C âŸ¶ A</code><span class=\"sep\"></span><code class=\"docstring\">the split epimorphism </code>",
 "683":
 "<code>A âŸ¶ C</code><span class=\"sep\"></span><code class=\"docstring\">the split monomorphism </code>",
 "682": "<code>Retract B C</code>",
 "681": "<code>Retract A B</code>",
 "680":
 "<code>A âŸ¶ A</code><span class=\"sep\"></span><code class=\"docstring\">the split epimorphism </code>",
 "68": "<code>Unit â†’ String</code>",
 "679":
 "<code>A âŸ¶ A</code><span class=\"sep\"></span><code class=\"docstring\">the split monomorphism </code>",
 "678": "<code>autoParam (r âŠš i = ğŸ™ X) Retract.retract._autoParam</code>",
 "677":
 "<code>CategoryTheory.Retract.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (i : X âŸ¶ Y) (r : Y âŸ¶ X)\n  (retract : r âŠš i = ğŸ™ X := by cat_disch) : Retract X Y</code>",
 "676": "<code>Retract X Y</code>",
 "675":
 "<code>CategoryTheory.Retract.retract.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (self : Retract X Y) :\n  self.r âŠš self.i = ğŸ™ X</code>",
 "674":
 "<code>CategoryTheory.Retract.r.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (self : Retract X Y) : Y âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">the split epimorphism </code>",
 "673":
 "<code>CategoryTheory.Retract.i.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (self : Retract X Y) : X âŸ¶ Y</code><span class=\"sep\"></span><code class=\"docstring\">the split monomorphism </code>",
 "672":
 "<code>CategoryTheory.Retract.{v, u} {C : Type u} [Category.{v, u} C] (X Y : C) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">An object `X` is a retract of `Y` if there are morphisms `i : X âŸ¶ Y` and `r : Y âŸ¶ X` such\nthat `i â‰« r = ğŸ™ X`. </code>",
 "671": "<code>CM.Ex5_3.sâ‚ˆ : B âŸ¶ A</code>",
 "670": "<code>CM.Ex5_3.sâ‚‡ : B âŸ¶ A</code>",
 "67": "<code>CM.CM_Finset.John : Point A</code>",
 "669": "<code>CM.Ex5_3.sâ‚† : B âŸ¶ A</code>",
 "668": "<code>CM.Ex5_3.sâ‚… : B âŸ¶ A</code>",
 "667": "<code>CM.Ex5_3.sâ‚„ : B âŸ¶ A</code>",
 "666": "<code>CM.Ex5_3.sâ‚ƒ : B âŸ¶ A</code>",
 "665": "<code>CM.Ex5_3.sâ‚‚ : B âŸ¶ A</code>",
 "664": "<code>CM.Ex5_3.sâ‚ : B âŸ¶ A</code>",
 "663": "<code>CM.Ex5_3.f : A âŸ¶ B</code>",
 "662": "<code>CM.Ex5_3.B.bâ‚‚ : B</code>",
 "661": "<code>CM.Ex5_3.B.bâ‚ : B</code>",
 "660": "<code>CM.Ex5_3.B : Type</code>",
 "66": "<code><span class=\"literal string\">\"coffee\"</span> : String</code>",
 "659": "<code>CM.Ex5_3.A.aâ‚‚â‚‚ : A</code>",
 "658": "<code>CM.Ex5_3.A.aâ‚‚â‚ : A</code>",
 "657": "<code>CM.Ex5_3.A.aâ‚â‚„ : A</code>",
 "656": "<code>CM.Ex5_3.A.aâ‚â‚ƒ : A</code>",
 "655": "<code>CM.Ex5_3.A.aâ‚â‚‚ : A</code>",
 "654": "<code>CM.Ex5_3.A.aâ‚â‚ : A</code>",
 "653": "<code>CM.Ex5_3.A : Type</code>",
 "652": "<code>âˆ€ (a : A), h a = g (f_fun a)</code>",
 "651": "<code>A â†’ B</code>",
 "650":
 "<code class=\"docstring\">* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `âˆ€ (x : X) (y : Y), âˆƒ (a : A) (b : B), P x y a b âˆ§ Q x y a b`\n  for some `P Q : X â†’ Y â†’ A â†’ B â†’ Prop` and outputs\n  into context a function `a : X â†’ Y â†’ A`, `b : X â†’ Y â†’ B` and two assumptions:\n  `h : âˆ€ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : âˆ€ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X â†’ A`, `b : X â†’ B`, and the assumptions\n  `h : âˆ€ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : âˆ€ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : âˆ€ n m : â„•, âˆƒ i j, m = n + i âˆ¨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : â„• â†’ â„• â†’ â„•\n  guard_hyp j : â„• â†’ â„• â†’ â„•\n  guard_hyp h : âˆ€ (n m : â„•), m = n + i n m âˆ¨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : âˆ€ i : â„•, i &lt; 7 â†’ âˆƒ j, i &lt; j âˆ§ j &lt; i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : â„• â†’ â„•\n  guard_hyp h : âˆ€ (i : â„•), i &lt; 7 â†’ i &lt; f i\n  guard_hyp h' : âˆ€ (i : â„•), i &lt; 7 â†’ f i &lt; i + i\n  trivial\n```\n</code>",
 "65": "<code><span class=\"literal string\">\"eggs\"</span> : String</code>",
 "649": "<code>âˆ€ (a : A), âˆƒ b, h a = g b</code>",
 "648": "<code>g âŠš f = h</code>",
 "647": "<code>âˆƒ f, g âŠš f = h</code>",
 "646": "<code>One âŸ¶ C</code>",
 "645": "<code>A âŸ¶ One</code>",
 "644": "<code>CM.IsConstantMap {A C : Type} (h : A âŸ¶ C) : Prop</code>",
 "643":
 "<code>CategoryTheory.types_comp_apply.{u} {X Y Z : Type u} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (x : X) : (g âŠš f) x = g (f x)</code>",
 "642":
 "<code>dif_pos.{u} {c : Prop} {h : Decidable c} (hc : c) {Î± : Sort u} {t : c â†’ Î±} {e : Â¬c â†’ Î±} : dite c t e = t hc</code>",
 "641": "<code>âˆƒ Î±_1, f Î±_1 = f Î±</code>",
 "640": "<code>g (f Î±) = h (choose Î²_in_image_exists)</code>",
 "64": "<code>CM.CM_Finset.B : Finset String</code>",
 "639":
 "<code>Unit.unit : Unit</code><span class=\"sep\"></span><code class=\"docstring\">The only element of the unit type.\n\nIt can be written as an empty tuple: `()`.\n</code>",
 "638": "<code>h Î± = h (choose Î²_in_image_exists)</code>",
 "637":
 "<code>Classical.choose_spec.{u} {Î± : Sort u} {p : Î± â†’ Prop} (h : âˆƒ x, p x) : p (choose h)</code>",
 "636": "<code>_fvar.428</code>",
 "635":
 "<code>Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p</code><span class=\"sep\"></span><code class=\"docstring\">Existential introduction. If `a : Î±` and `h : p a`,\nthen `âŸ¨a, hâŸ©` is a proof that `âˆƒ x : Î±, p x`. </code>",
 "634": "<code>âˆƒ Î±', f Î±' = f Î±</code>",
 "633":
 "<code>inferInstance.{u} {Î± : Sort u} [i : Î±] : Î±</code><span class=\"sep\"></span><code class=\"docstring\">`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : Î±]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`Î±` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat Ã— Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n</code>",
 "632":
 "<code>Classical.choice.{u} {Î± : Sort u} : Nonempty Î± â†’ Î±</code><span class=\"sep\"></span><code class=\"docstring\">**The axiom of choice**. `Nonempty Î±` is a proof that `Î±` has an element,\nbut the element itself is erased. The axiom `choice` supplies a particular\nelement of `Î±` given only this proof.\n\nThe textbook axiom of choice normally makes a family of choices all at once,\nbut that is implied from this formulation, because if `Î± : Î¹ â†’ Type` is a\nfamily of types and `h : âˆ€ i, Nonempty (Î± i)` is a proof that they are all\nnonempty, then `fun i =&gt; Classical.choice (h i) : âˆ€ i, Î± i` is a family of\nchosen elements. This is actually a bit stronger than the ZFC choice axiom;\nthis is sometimes called \"[global choice](https://en.wikipedia.org/wiki/Axiom_of_global_choice)\".\n\nIn Lean, we use the axiom of choice to derive the law of excluded middle\n(see `Classical.em`), so it will often show up in axiom listings where you\nmay not expect. You can use `#print axioms my_thm` to find out if a given\ntheorem depends on this or other axioms.\n\nThis axiom can be used to construct \"data\", but obviously there is no algorithm\nto compute it, so Lean will require you to mark any definition that would\ninvolve executing `Classical.choice` or other axioms as `noncomputable`, and\nwill not produce any executable code for such definitions.\n</code>",
 "631": "<code>âˆƒ Î±, f Î± = Î²</code>",
 "630":
 "<code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : Â¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "63": "<code><span class=\"literal string\">\"Sam\"</span> : String</code>",
 "629": "<code>Nonempty C</code>",
 "628": "<code>h âŠš aâ‚ = h âŠš aâ‚‚</code>",
 "627":
 "<code>Eq.symm.{u} {Î± : Sort u} {a b : Î±} (h : a = b) : b = a</code><span class=\"sep\"></span><code class=\"docstring\">Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "626":
 "<code>Classical.choose_spec.{u} {Î± : Sort u} {p : Î± â†’ Prop} (h : âˆƒ x, p x) : p (Classical.choose h)</code>",
 "625": "<code>f âŠš aâ‚ = f âŠš aâ‚‚</code>",
 "624": "<code>CM.One</code>",
 "623": "<code>_fvar.433</code>",
 "622": "<code>_fvar.434</code>",
 "621":
 "<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by `have`.\n\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : Î± Ã— Î² Ã— Î³`, `let âŸ¨x, y, zâŸ© := p` produces the\n  local variables `x : Î±`, `y : Î²`, and `z : Î³`.\n* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `let` term.\n\n## Properties and relations\n\n* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics\n  such as `simp`, `dsimp`, `unfold`, and `subst`.\n* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.\n  The tactic might fail if the local context depends on the value of the variable.\n* The `let` tactic is preferred for data (non-propositions).\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n</code>",
 "620":
 "<code>Function.Surjective.{u_1, u_2} {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f : Î± â†’ Î²` is called surjective if every `b : Î²` is equal to `f a`\nfor some `a : Î±`. </code>",
 "62": "<code><span class=\"literal string\">\"Mary\"</span> : String</code>",
 "619": "<code>Function.Surjective f</code>",
 "618": "<code>âˆ€ (aâ‚ aâ‚‚ : Point A), f âŠš aâ‚ = f âŠš aâ‚‚ â†’ h âŠš aâ‚ = h âŠš aâ‚‚</code>",
 "617": "<code>f âŠš aâ‚âœ = f âŠš aâ‚‚âœ</code>",
 "616": "<code>h = g âŠš f</code>",
 "615": "<code>âˆƒ g, h = g âŠš f</code>",
 "614": "<code>0 &lt; aâœ</code>",
 "613":
 "<code>LT.lt.{u} {Î± : Type u} [self : LT Î±] : Î± â†’ Î± â†’ Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>",
 "612": "<code>â„pos</code>",
 "611": "<code>âˆ€ (x : â„), â†‘(c x) = x ^ 3</code>",
 "610": "<code>â„ â†’ â„pos</code>",
 "61": "<code><span class=\"literal string\">\"John\"</span> : String</code>",
 "609": "<code>CM.Ex4_3_f.â„pos : Type</code>",
 "608":
 "<code>mul_one.{u} {M : Type u} [MulOneClass M] (a : M) : a * 1 = a</code>",
 "607": "<code>âˆ€ (x : â„), m x = -x</code>",
 "606": "<code>â†‘m âˆ˜ â†‘minv = id</code>",
 "605": "<code>â†‘minv âˆ˜ â†‘m = id</code>",
 "604":
 "<code>âˆƒ inv, inv âŠš m = ğŸ™ RealAdd âˆ§ m âŠš inv = ğŸ™ RealAdd</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "603": "<code>CM.Ex4_3_d.minv : RealAdd âŸ¶ RealAdd</code>",
 "602":
 "<code>Neg.neg.{u} {Î± : Type u} [self : Neg Î±] : Î± â†’ Î±</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "601": "<code>CM.Ex4_3_d.m : RealAdd âŸ¶ RealAdd</code>",
 "600": "<code>r â†‘(sq (-1)) = -1</code>",
 "60":
 "<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode code points.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>",
 "6": "<code>CM.ExI_1.A.aâ‚‚ : A</code>",
 "599": "<code>r â†‘(sq 1) = 1</code>",
 "598": "<code>âˆ€ (x : â„), r â†‘(sq x) = x</code>",
 "597": "<code>âˆƒ r, âˆ€ (x : â„), r â†‘(sq x) = x</code>",
 "596": "<code>âˆ€ (x : â„), â†‘(sq x) = x ^ 2</code>",
 "595": "<code>â„ âŸ¶ â„â‰¥0</code>",
 "594": "<code>1 = -1</code>",
 "593":
 "<code>neg_sq.{u} {R : Type u} [Monoid R] [HasDistribNeg R] (a : R) : (-a) ^ 2 = a ^ 2</code>",
 "592": "<code>r ((-1) ^ 2) = -1</code>",
 "591": "<code>r (1 ^ 2) = 1</code>",
 "590": "<code>r (sq (-1)) = -1</code>",
 "59": "<code>CM.CM_Finset.A : Finset String</code>",
 "589": "<code>r (sq 1) = 1</code>",
 "588": "<code>âˆ€ (x : â„), r (sq x) = x</code>",
 "587": "<code>âˆƒ r, âˆ€ (x : â„), r (sq x) = x</code>",
 "586":
 "<code>HPow.hPow.{u, v, w} {Î± : Type u} {Î² : Type v} {Î³ : outParam (Type w)} [self : HPow Î± Î² Î³] : Î± â†’ Î² â†’ Î³</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.</code>",
 "585": "<code>âˆ€ (x : â„), sq x = x ^ 2</code>",
 "584":
 "<code>left_eq_add.{u_4} {M : Type u_4} [AddMonoid M] [IsLeftCancelAdd M] {a b : M} : a = a + b â†” b = 0</code>",
 "583": "<code>ne_eq.{u_1} {Î± : Sort u_1} (a b : Î±) : (a â‰  b) = Â¬a = b</code>",
 "582":
 "<code>add_zero.{u} {M : Type u} [AddZeroClass M] (a : M) : a + 0 = a</code>",
 "581": "<code>âˆ€ (x : â„), p x = x + 1</code>",
 "580": "<code>â„ âŸ¶ â„</code>",
 "58":
 "<code>CM.CM_Finset.Point.{u_1} {Î² : Type u_1} (Y : Finset Î²) : Type u_1</code>",
 "579": "<code>â†‘f âˆ˜ â†‘finv = id</code>",
 "578": "<code>â†‘finv âˆ˜ â†‘f = id</code>",
 "577": "<code>signMul âŸ¶ parityAdd</code>",
 "576":
 "<code>âˆƒ inv, inv âŠš f = ğŸ™ parityAdd âˆ§ f âŠš inv = ğŸ™ signMul</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "575": "<code>Sign.neg âˆˆ signMul.carrier</code>",
 "574": "<code>Sign.pos âˆˆ signMul.carrier</code>",
 "573": "<code>b âˆˆ signMul.carrier</code>",
 "572": "<code>a âˆˆ signMul.carrier</code>",
 "571": "<code>signMul.t</code>",
 "570": "<code>CM.Ex4_2.finv : signMul âŸ¶ parityAdd</code>",
 "57": "<code>Map X Y</code>",
 "569": "<code>Parity.even âˆˆ parityAdd.carrier</code>",
 "568": "<code>Parity.odd âˆˆ parityAdd.carrier</code>",
 "567": "<code>b âˆˆ parityAdd.carrier</code>",
 "566": "<code>a âˆˆ parityAdd.carrier</code>",
 "565": "<code>parityAdd.t</code>",
 "564": "<code>CM.Ex4_2.f : parityAdd âŸ¶ signMul</code>",
 "563": "<code>CM.Ex4_2.finv' : Sign âŸ¶ Parity</code>",
 "562": "<code>CM.Ex4_2.f' : Parity âŸ¶ Sign</code>",
 "561":
 "<code>âˆ€ {a b : Sign}, a âˆˆ Set.univ â†’ b âˆˆ Set.univ â†’ a * b âˆˆ Set.univ</code>",
 "560": "<code>Sign â†’ Sign â†’ Sign</code>",
 "56":
 "<code>Map X Y â†’ Î± â†’ Î²</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : Î±` to type `Î³ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "559": "<code>Set Sign</code>",
 "558": "<code>CM.Ex4_2.signMul : AlgebraicObj</code>",
 "557":
 "<code>âˆ€ {a b : Parity}, a âˆˆ Set.univ â†’ b âˆˆ Set.univ â†’ a + b âˆˆ Set.univ</code>",
 "556": "<code>Parity â†’ Parity â†’ Parity</code>",
 "555": "<code>Set Parity</code>",
 "554": "<code>CM.Ex4_2.parityAdd : AlgebraicObj</code>",
 "553":
 "<code>Sign â†’ Sign â†’ Sign</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`. See `HMul`. </code>",
 "552":
 "<code>Mul.{u} (Î± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HMul`: `a * b : Î±` where `a b : Î±`. </code>",
 "551": "<code>CM.Ex4_2.mul : Sign â†’ Sign â†’ Sign</code>",
 "550": "<code>CM.Ex4_2.Sign.neg : Sign</code>",
 "55":
 "<code>CoeFun.{u, v} (Î± : Sort u) (Î³ : outParam (Î± â†’ Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeFun Î± (Î³ : Î± â†’ Sort v)` is a coercion to a function. `Î³ a` should be a\n(coercion-to-)function type, and this is triggered whenever an element\n`f : Î±` appears in an application like `f x`, which would not make sense since\n`f` does not have a function type.\n`CoeFun` instances apply to `CoeOut` as well.\n</code>",
 "549": "<code>CM.Ex4_2.Sign.pos : Sign</code>",
 "548": "<code>CM.Ex4_2.Sign : Type</code>",
 "547":
 "<code>Parity â†’ Parity â†’ Parity</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "546":
 "<code>Add.{u} (Î± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAdd`: `a + b : Î±` where `a b : Î±`. </code>",
 "545": "<code>CM.Ex4_2.add : Parity â†’ Parity â†’ Parity</code>",
 "544": "<code>CM.Ex4_2.Parity.even : Parity</code>",
 "543": "<code>CM.Ex4_2.Parity.odd : Parity</code>",
 "542": "<code>CM.Ex4_2.Parity : Type</code>",
 "541": "<code>â†‘d âˆ˜ â†‘h = id</code>",
 "540":
 "<code>Subtype.eq.{u} {Î± : Type u} {p : Î± â†’ Prop} {a1 a2 : { x // p x }} : â†‘a1 = â†‘a2 â†’ a1 = a2</code>",
 "54": "<code>Î± â†’ Î²</code>",
 "539": "<code>â†‘h âˆ˜ â†‘d = id</code>",
 "538":
 "<code class=\"docstring\">`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n</code>",
 "537": "<code>RealAdd âŸ¶ RealAdd</code>",
 "536":
 "<code>âˆƒ inv, inv âŠš d = ğŸ™ RealAdd âˆ§ d âŠš inv = ğŸ™ RealAdd</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "535": "<code>CM.Ex4_1.h : RealAdd âŸ¶ RealAdd</code>",
 "534": "<code>xâ‚‚âœ âˆˆ RealAdd.carrier</code>",
 "533": "<code>xâ‚âœ âˆˆ RealAdd.carrier</code>",
 "532": "<code>RealAdd.t</code>",
 "531": "<code>CM.Ex4_1.d : RealAdd âŸ¶ RealAdd</code>",
 "530": "<code>Set.mem_univ.{u} {Î± : Type u} (x : Î±) : x âˆˆ Set.univ</code>",
 "53": "<code>Î±</code>",
 "529":
 "<code>âˆ€ {a b : â„}, a âˆˆ Set.univ â†’ b âˆˆ Set.univ â†’ a + b âˆˆ Set.univ</code>",
 "528": "<code>â„ â†’ â„ â†’ â„</code>",
 "527": "<code>Set â„</code>",
 "526": "<code>Type</code>",
 "525": "<code>CM.RealAdd : AlgebraicObj</code>",
 "524":
 "<code>g (Yâœ.oper (f xâ‚) (f xâ‚‚)) = Zâœ.oper (g (f xâ‚)) (g (f xâ‚‚))</code>",
 "523": "<code>f (Xâœ.oper xâ‚ xâ‚‚) = Yâœ.oper (f xâ‚) (f xâ‚‚)</code>",
 "522": "<code>xâ‚‚ âˆˆ Xâœ.carrier</code>",
 "521": "<code>xâ‚ âˆˆ Xâœ.carrier</code>",
 "520": "<code>x âˆˆ Xâœ.carrier</code>",
 "52":
 "<code>CM.CM_Finset.Map.maps_to_codomain.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} {X : Finset Î±} {Y : Finset Î²}\n  (self : Map X Y) (a : Î±) : a âˆˆ X â†’ self.toFun a âˆˆ Y</code>",
 "519":
 "<code>âˆ€ xâ‚ âˆˆ Yâœ.carrier, âˆ€ xâ‚‚ âˆˆ Yâœ.carrier, g (Yâœ.oper xâ‚ xâ‚‚) = Zâœ.oper (g xâ‚) (g xâ‚‚)</code>",
 "518": "<code>âˆ€ x âˆˆ Yâœ.carrier, g x âˆˆ Zâœ.carrier</code>",
 "517":
 "<code>âˆ€ xâ‚ âˆˆ Xâœ.carrier, âˆ€ xâ‚‚ âˆˆ Xâœ.carrier, f (Xâœ.oper xâ‚ xâ‚‚) = Yâœ.oper (f xâ‚) (f xâ‚‚)</code>",
 "516": "<code>âˆ€ x âˆˆ Xâœ.carrier, f x âˆˆ Yâœ.carrier</code>",
 "515": "<code>Xâœ.t âŸ¶ Zâœ.t</code>",
 "514": "<code>Yâœ.t</code>",
 "513": "<code>Xâœ.t</code>",
 "512":
 "<code>(âˆ€ x âˆˆ Yâœ.carrier, g x âˆˆ Zâœ.carrier) âˆ§ âˆ€ xâ‚ âˆˆ Yâœ.carrier, âˆ€ xâ‚‚ âˆˆ Yâœ.carrier, g (Yâœ.oper xâ‚ xâ‚‚) = Zâœ.oper (g xâ‚) (g xâ‚‚)</code>",
 "511": "<code>Yâœ.t âŸ¶ Zâœ.t</code>",
 "510":
 "<code>(âˆ€ x âˆˆ Xâœ.carrier, f x âˆˆ Yâœ.carrier) âˆ§ âˆ€ xâ‚ âˆˆ Xâœ.carrier, âˆ€ xâ‚‚ âˆˆ Xâœ.carrier, f (Xâœ.oper xâ‚ xâ‚‚) = Yâœ.oper (f xâ‚) (f xâ‚‚)</code>",
 "51":
 "<code>CM.CM_Finset.Map.toFun.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} {X : Finset Î±} {Y : Finset Î²} (self : Map X Y) : Î± â†’ Î²</code>",
 "509": "<code>Xâœ.t âŸ¶ Yâœ.t</code>",
 "508": "<code>X.t âŸ¶ Z.t</code>",
 "507": "<code>Y.t</code>",
 "506": "<code>Y.t âŸ¶ Z.t</code>",
 "505":
 "<code>Subtype.{u} {Î± : Sort u} (p : Î± â†’ Prop) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">All the elements of a type that satisfy a predicate.\n\n`Subtype p`, usually written `{ x : Î± // p x }` or `{ x // p x }`, contains all elements `x : Î±` for\nwhich `p x` is true. Its constructor is a pair of the value and the proof that it satisfies the\npredicate. In run-time code, `{ x : Î± // p x }` is represented identically to `Î±`.\n\nThere is a coercion from `{ x : Î± // p x }` to `Î±`, so elements of a subtype may be used where the\nunderlying type is expected.\n\nExamples:\n * `{ n : Nat // n % 2 = 0 }` is the type of even numbers.\n * `{ xs : Array String // xs.size = 5 }` is the type of arrays with five `String`s.\n * Given `xs : List Î±`, `List { x : Î± // x âˆˆ xs }` is the type of lists in which all elements are\n   contained in `xs`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{ x // p x }` in identifiers is `subtype`.</code>",
 "504":
 "<code>{X Y Z : AlgebraicObj} â†’\n  { f //\n      (âˆ€ x âˆˆ X.carrier, f x âˆˆ Y.carrier) âˆ§\n        âˆ€ xâ‚ âˆˆ X.carrier, âˆ€ xâ‚‚ âˆˆ X.carrier, f (X.oper xâ‚ xâ‚‚) = Y.oper (f xâ‚) (f xâ‚‚) } â†’\n    { f //\n        (âˆ€ x âˆˆ Y.carrier, f x âˆˆ Z.carrier) âˆ§\n          âˆ€ xâ‚ âˆˆ Y.carrier, âˆ€ xâ‚‚ âˆˆ Y.carrier, f (Y.oper xâ‚ xâ‚‚) = Z.oper (f xâ‚) (f xâ‚‚) } â†’\n      { f //\n        (âˆ€ x âˆˆ X.carrier, f x âˆˆ Z.carrier) âˆ§\n          âˆ€ xâ‚ âˆˆ X.carrier, âˆ€ xâ‚‚ âˆˆ X.carrier, f (X.oper xâ‚ xâ‚‚) = Z.oper (f xâ‚) (f xâ‚‚) }</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "503": "<code>xâ‚‚âœ âˆˆ X.carrier</code>",
 "502": "<code>xâ‚âœ âˆˆ X.carrier</code>",
 "501":
 "<code class=\"docstring\">`intros` repeatedly applies `intro` to introduce zero or more hypotheses\nuntil the goal is no longer a *binding expression*\n(i.e., a universal quantifier, function type, implication, or `have`/`let`),\nwithout performing any definitional reductions (no unfolding, beta, eta, etc.).\nThe introduced hypotheses receive inaccessible (hygienic) names.\n\n`intros x y z` is equivalent to `intro x y z` and exists only for historical reasons.\nThe `intro` tactic should be preferred in this case.\n\n## Properties and relations\n\n- `intros` succeeds even when it introduces no hypotheses.\n\n- `repeat intro` is like `intros`, but it performs definitional reductions\n  to expose binders, and as such it may introduce more hypotheses than `intros`.\n\n- `intros` is equivalent to `intro _ _ â€¦ _`,\n  with the fewest trailing `_` placeholders needed so that the goal is no longer a binding expression.\n  The trailing introductions do not perform any definitional reductions.\n\n## Examples\n\nImplications:\n```lean\nexample (p q : Prop) : p â†’ q â†’ p := by\n  intros\n  /- Tactic state\n     aâœÂ¹ : p\n     aâœ : q\n     âŠ¢ p      -/\n  assumption\n```\n\nLet-bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- nâœ : Nat := 1\n     kâœ : Nat := 2\n     âŠ¢ nâœ + kâœ = 3 -/\n  rfl\n```\n\nDoes not unfold definitions:\n```lean\ndef AllEven (f : Nat â†’ Nat) := âˆ€ n, f n % 2 = 0\n\nexample : âˆ€ (f : Nat â†’ Nat), AllEven f â†’ AllEven (fun k =&gt; f (k + 1)) := by\n  intros\n  /- Tactic state\n     fâœ : Nat â†’ Nat\n     aâœ : AllEven fâœ\n     âŠ¢ AllEven fun k =&gt; fâœ (k + 1) -/\n  sorry\n```\n</code>",
 "500": "<code>xâœ âˆˆ X.carrier</code>",
 "50": "<code>Finset Î²</code>",
 "5": "<code>CM.ExI_1.A.aâ‚ : A</code>",
 "499":
 "<code>(X : AlgebraicObj) â†’\n  { f //\n    (âˆ€ x âˆˆ X.carrier, f x âˆˆ X.carrier) âˆ§ âˆ€ xâ‚ âˆˆ X.carrier, âˆ€ xâ‚‚ âˆˆ X.carrier, f (X.oper xâ‚ xâ‚‚) = X.oper (f xâ‚) (f xâ‚‚) }</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "498": "<code>X.t</code>",
 "497": "<code>X.t âŸ¶ Y.t</code>",
 "496": "<code>AlgebraicObj</code>",
 "495":
 "<code>AlgebraicObj â†’ AlgebraicObj â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "494": "<code>t â†’ t â†’ t</code>",
 "493": "<code>Set t</code>",
 "492": "<code>t</code>",
 "491":
 "<code>CM.AlgebraicObj.oper_mem (self : AlgebraicObj) {a b : self.t} :\n  a âˆˆ self.carrier â†’ b âˆˆ self.carrier â†’ self.oper a b âˆˆ self.carrier</code>",
 "490":
 "<code>CM.AlgebraicObj.oper (self : AlgebraicObj) : self.t â†’ self.t â†’ self.t</code>",
 "49": "<code>Finset Î±</code>",
 "489":
 "<code>CM.AlgebraicObj.carrier (self : AlgebraicObj) : Set self.t</code>",
 "488": "<code>CM.AlgebraicObj.t (self : AlgebraicObj) : Type</code>",
 "487": "<code>CM.AlgebraicObj : Type 1</code>",
 "486": "<code>CM.permCount.{u_1} {Î± : Type u_1} (s : Finset Î±) : â„•</code>",
 "485": "<code>CM.autCount.{u_1} (Î± : Type u_1) [Fintype Î±] : â„•</code>",
 "484":
 "<code>Nat.factorial : â„• â†’ â„•</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.factorial n` is the factorial of `n`. </code>",
 "483":
 "<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "482":
 "<code>CM.isoCount.{u_1, u_2} (Î± : Type u_1) (Î² : Type u_2) [Fintype Î±] [Fintype Î²] : â„•</code>",
 "481":
 "<code>CategoryTheory.End.{v, u} {C : Type u} [CategoryStruct.{v, u} C] (X : C) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Endomorphisms of an object in a category. Arguments order in multiplication agrees with\n`Function.comp`, not with `CategoryTheory.CategoryStruct.comp`. </code>",
 "480":
 "<code>CategoryTheory.Aut.{v, u} {C : Type u} [Category.{v, u} C] (X : C) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">Automorphisms of an object in a category.\n\nThe order of arguments in multiplication agrees with\n`Function.comp`, not with `CategoryTheory.CategoryStruct.comp`.\n</code>",
 "48":
 "<code class=\"docstring\">The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`&gt; 0` for each variable in the sequence. </code>",
 "479": "<code>CM.ExII_11.finv : B âŸ¶ A</code>",
 "478": "<code>CM.ExII_11.f : A âŸ¶ B</code>",
 "477": "<code>CM.ExII_11.B.cocoa : B</code>",
 "476": "<code>CM.ExII_11.B.tea : B</code>",
 "475": "<code>CM.ExII_11.B.coffee : B</code>",
 "474": "<code>CM.ExII_11.B : Type</code>",
 "473": "<code>CM.ExII_11.A.Alysia : A</code>",
 "472": "<code>CM.ExII_11.A.Omer : A</code>",
 "471": "<code>CM.ExII_11.A.Fatima : A</code>",
 "470": "<code>CM.ExII_11.A : Type</code>",
 "47": "<code>Type u_2</code>",
 "469":
 "<code>CategoryTheory.IsIso.inv_comp.{v, u} {C : Type u} [Category.{v, u} C] {X Y Z : C} {f : X âŸ¶ Y} {h : Y âŸ¶ Z} [IsIso f]\n  [IsIso h] : inv (h âŠš f) = inv f âŠš inv h</code>",
 "468": "<code>C âŸ¶ A</code>",
 "467":
 "<code>âˆƒ inv, inv âŠš g âŠš f = ğŸ™ A âˆ§ (g âŠš f) âŠš inv = ğŸ™ C</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "466": "<code>ginv âŠš g = ğŸ™ B âˆ§ g âŠš ginv = ğŸ™ C</code>",
 "465": "<code>IsIso g</code>",
 "464":
 "<code>CategoryTheory.inv.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y) [I : IsIso f] : Y âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The inverse of a morphism `f` when we have `[IsIso f]`.\n</code>",
 "463":
 "<code>Classical.choose.{u} {Î± : Sort u} {p : Î± â†’ Prop} (h : âˆƒ x, p x) : Î±</code><span class=\"sep\"></span><code class=\"docstring\">Given that there exists an element satisfying `p`, returns one such element.\n\nThis is a straightforward consequence of, and equivalent to, `Classical.choice`.\n\nSee also `choose_spec`, which asserts that the returned value has property `p`.\n</code>",
 "462":
 "<code class=\"docstring\">The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | âŸ¨b, câŸ©) âŸ¨d, eâŸ©`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n</code>",
 "461":
 "<code>âˆƒ inv, inv âŠš f = ğŸ™ A âˆ§ f âŠš inv = ğŸ™ B</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "460": "<code>r.retraction = s.section_</code>",
 "46": "<code>Type u_1</code>",
 "459":
 "<code>Iff (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">If and only if, or logical bi-implication. `a â†” b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `â†”` in identifiers is `iff`.\n\n * The recommended spelling of `&lt;-&gt;` in identifiers is `iff` (prefer `â†”` over `&lt;-&gt;`).</code>",
 "458":
 "<code>f âŠš s = ğŸ™ B</code><span class=\"sep\"></span><code class=\"docstring\">`section_` composed with `f` is the identity </code>",
 "457":
 "<code>r âŠš f = ğŸ™ A</code><span class=\"sep\"></span><code class=\"docstring\">`f` composed with `retraction` is the identity </code>",
 "456":
 "<code>B âŸ¶ A</code><span class=\"sep\"></span><code class=\"docstring\">The map splitting `f` </code>",
 "455": "<code>Section f</code>",
 "454":
 "<code>CM.uniqueness_of_inverses.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’} (f : A âŸ¶ B) (r : Retraction f)\n  (s : Section f) : r.retraction = s.section_</code>",
 "453":
 "<code class=\"docstring\">`rwa` is short-hand for `rw; assumption`. </code>",
 "452": "<code>e âŠš e = e</code>",
 "451": "<code>e = f âŠš r.retraction</code>",
 "450": "<code>Retraction f</code>",
 "45":
 "<code>CM.CM_Finset.Map.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} (X : Finset Î±) (Y : Finset Î²) : Type (max u_1 u_2)</code>",
 "449": "<code>B âŸ¶ B</code>",
 "448":
 "<code>CM.IsIdempotent.idem.{u, v} {ğ’ : Type u} {instâœ : Category.{v, u} ğ’} {A : ğ’} {e : A âŸ¶ A} [self : IsIdempotent e] :\n  e âŠš e = e</code>",
 "447":
 "<code>CM.IsIdempotent.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A : ğ’} (e : A âŸ¶ A) : Prop</code>",
 "446": "<code>A âŸ¶ A</code>",
 "445":
 "<code>CM.Idempotent.idem.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A : ğ’} (self : Idempotent A) : self.e âŠš self.e = self.e</code>",
 "444":
 "<code>CM.Idempotent.e.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A : ğ’} (self : Idempotent A) : A âŸ¶ A</code>",
 "443":
 "<code>CM.Idempotent.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] (A : ğ’) : Type v</code>",
 "442":
 "<code>CategoryTheory.instIsSplitEpiComp.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z}\n  [hf : IsSplitEpi f] [hg : IsSplitEpi g] : IsSplitEpi (g âŠš f)</code>",
 "441": "<code>CategoryTheory.SplitEpi.id._autoParam : Lean.Syntax</code>",
 "440": "<code>g âŠš sâ‚‚ = ğŸ™ C</code>",
 "44":
 "<code class=\"docstring\">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed\nwith `end &lt;id&gt;`. The `end` command is optional at the end of a file.\n</code>",
 "439": "<code>f âŠš sâ‚ = ğŸ™ B</code>",
 "438": "<code>IsSection g</code>",
 "437":
 "<code>CategoryTheory.instIsSplitMonoComp.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z}\n  [hf : IsSplitMono f] [hg : IsSplitMono g] : IsSplitMono (g âŠš f)</code>",
 "436": "<code>CategoryTheory.SplitMono.id._autoParam : Lean.Syntax</code>",
 "435":
 "<code>autoParam.{u} (Î± : Sort u) (tactic : Lean.Syntax) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\nthe given tactic.\nLike `optParam`, this gadget only affects elaboration.\nFor example, the tactic will *not* be invoked during type class resolution. </code>",
 "434": "<code>râ‚‚ âŠš g = ğŸ™ B</code>",
 "433": "<code>râ‚ âŠš f = ğŸ™ A</code>",
 "432": "<code>IsRetraction g</code>",
 "431":
 "<code>CM.prop3.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B C : ğ’} (f : A âŸ¶ B) [hf : IsRetraction f] (g : B âŸ¶ C)\n  [hg : IsRetraction g] : IsRetraction (g âŠš f)</code>",
 "430":
 "<code>CategoryTheory.cancel_epi.{v, u} {C : Type u} [Category.{v, u} C] {X Y Z : C} (f : X âŸ¶ Y) [Epi f] {g h : Y âŸ¶ Z} :\n  g âŠš f = h âŠš f â†” g = h</code>",
 "43":
 "<code>Finset.univ.{u_1} {Î± : Type u_1} [Fintype Î±] : Finset Î±</code><span class=\"sep\"></span><code class=\"docstring\">`univ` is the universal finite set of type `Finset Î±` implied from\nthe assumption `Fintype Î±`. </code>",
 "429":
 "<code>CategoryTheory.cancel_mono.{v, u} {C : Type u} [Category.{v, u} C] {X Y Z : C} (f : X âŸ¶ Y) [Mono f] {g h : Z âŸ¶ X} :\n  f âŠš g = f âŠš h â†” g = h</code>",
 "428": "<code>âˆ€ {Z : C} (g h : g âŸ¶ Z), g âŠš f = h âŠš f â†’ g = h</code>",
 "427":
 "<code>CategoryTheory.Epi.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} {f : X âŸ¶ Y}\n  (left_cancellation : âˆ€ {Z : C} (g h : Y âŸ¶ Z), g âŠš f = h âŠš f â†’ g = h) : Epi f</code>",
 "426":
 "<code>CategoryTheory.Epi.left_cancellation.{v, u} {C : Type u} {instâœ : Category.{v, u} C} {X Y : C} {f : X âŸ¶ Y}\n  [self : Epi f] {Z : C} (g h : Y âŸ¶ Z) : g âŠš f = h âŠš f â†’ g = h</code><span class=\"sep\"></span><code class=\"docstring\">A morphism `f` is an epimorphism if it can be cancelled when precomposed. </code>",
 "425":
 "<code>CategoryTheory.Epi.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A morphism `f` is an epimorphism if it can be cancelled when precomposed:\n`f â‰« g = f â‰« h` implies `g = h`. </code>",
 "424": "<code>tâ‚ âŠš f = tâ‚‚ âŠš f</code>",
 "423":
 "<code>CM.Â«prop2*Â».{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’} (f : A âŸ¶ B) [hf : IsSection f] (tâ‚ tâ‚‚ : B âŸ¶ T) :\n  tâ‚ âŠš f = tâ‚‚ âŠš f â†’ tâ‚ = tâ‚‚</code>",
 "422": "<code>âˆ€ {Z : C} (g h : Z âŸ¶ X), f âŠš g = f âŠš h â†’ g = h</code>",
 "421":
 "<code>CategoryTheory.Mono.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} {f : X âŸ¶ Y}\n  (right_cancellation : âˆ€ {Z : C} (g h : Z âŸ¶ X), f âŠš g = f âŠš h â†’ g = h) : Mono f</code>",
 "420": "<code>Z âŸ¶ X</code>",
 "42":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "419":
 "<code>CategoryTheory.Mono.right_cancellation.{v, u} {C : Type u} {instâœ : Category.{v, u} C} {X Y : C} {f : X âŸ¶ Y}\n  [self : Mono f] {Z : C} (g h : Z âŸ¶ X) : f âŠš g = f âŠš h â†’ g = h</code><span class=\"sep\"></span><code class=\"docstring\">A morphism `f` is a monomorphism if it can be cancelled when postcomposed. </code>",
 "418":
 "<code>CategoryTheory.Mono.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A morphism `f` is a monomorphism if it can be cancelled when postcomposed:\n`g â‰« f = h â‰« f` implies `g = h`. </code>",
 "417": "<code>f âŠš xâ‚ = f âŠš xâ‚‚</code>",
 "416":
 "<code>CM.prop2.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’} (f : A âŸ¶ B) [hf : IsRetraction f] (xâ‚ xâ‚‚ : T âŸ¶ A) :\n  f âŠš xâ‚ = f âŠš xâ‚‚ â†’ xâ‚ = xâ‚‚</code>",
 "415": "<code>r âŠš f = ğŸ™ A</code>",
 "414": "<code>B âŸ¶ T</code>",
 "413": "<code>A âŸ¶ T</code>",
 "412": "<code>IsRetraction f</code>",
 "411":
 "<code>CM.Â«prop1*Â».{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’} (f : A âŸ¶ B) [hf : IsRetraction f] (g : A âŸ¶ T) :\n  âˆƒ t, t âŠš f = g</code>",
 "410": "<code>f âŠš s = ğŸ™ B</code>",
 "41":
 "<code>Finset.{u_4} (Î± : Type u_4) : Type u_4</code><span class=\"sep\"></span><code class=\"docstring\">`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented\nas a multiset (a list up to permutation) which has no duplicate elements. </code>",
 "409": "<code>T âŸ¶ A</code>",
 "408": "<code>T âŸ¶ B</code>",
 "407": "<code>IsSection f</code>",
 "406":
 "<code>CM.prop1.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’} (f : A âŸ¶ B) [hf : IsSection f] (y : T âŸ¶ B) : âˆƒ x, f âŠš x = y</code>",
 "405":
 "<code>CM.IsSection.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’} (f : A âŸ¶ B) : Prop</code>",
 "404":
 "<code>CM.Section.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’} (f : A âŸ¶ B) : Type v</code>",
 "403": "<code>Nonempty (SplitEpi f)</code>",
 "402":
 "<code>CategoryTheory.IsSplitEpi.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y}\n  (exists_splitEpi : Nonempty (SplitEpi f)) : IsSplitEpi f</code>",
 "401":
 "<code>CategoryTheory.IsSplitEpi.exists_splitEpi.{vâ‚, uâ‚} {C : Type uâ‚} {instâœ : Category.{vâ‚, uâ‚} C} {X Y : C} {f : X âŸ¶ Y}\n  [self : IsSplitEpi f] : Nonempty (SplitEpi f)</code><span class=\"sep\"></span><code class=\"docstring\">There is a splitting </code>",
 "400":
 "<code>CategoryTheory.IsSplitEpi.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsSplitEpi f` is the assertion that `f` admits a section </code>",
 "40": "<code>CM.CM_Finset.One : Finset Unit</code>",
 "4": "<code>CM.ExI_1.A : Type</code>",
 "399": "<code>autoParam (f âŠš section_ = ğŸ™ Y) SplitEpi.id._autoParam</code>",
 "398":
 "<code>CategoryTheory.SplitEpi.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (section_ : Y âŸ¶ X)\n  (id : f âŠš section_ = ğŸ™ Y := by cat_disch) : SplitEpi f</code>",
 "397": "<code>SplitEpi f</code>",
 "396":
 "<code>CategoryTheory.SplitEpi.id.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (self : SplitEpi f) :\n  f âŠš self.section_ = ğŸ™ Y</code><span class=\"sep\"></span><code class=\"docstring\">`section_` composed with `f` is the identity </code>",
 "395":
 "<code>CategoryTheory.SplitEpi.section_.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y}\n  (self : SplitEpi f) : Y âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The map splitting `f` </code>",
 "394":
 "<code>CategoryTheory.SplitEpi.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Type vâ‚</code><span class=\"sep\"></span><code class=\"docstring\">A split epimorphism is a morphism `f : X âŸ¶ Y` with a given section `section_ f : Y âŸ¶ X`\nsuch that `section_ f â‰« f = ğŸ™ Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism.\n</code>",
 "393":
 "<code>CM.IsRetraction.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’} (f : A âŸ¶ B) : Prop</code>",
 "392":
 "<code>CM.Retraction.{u, v} {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’} (f : A âŸ¶ B) : Type v</code>",
 "391": "<code>Nonempty (SplitMono f)</code>",
 "390":
 "<code>CategoryTheory.IsSplitMono.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y}\n  (exists_splitMono : Nonempty (SplitMono f)) : IsSplitMono f</code>",
 "39":
 "<code class=\"docstring\">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside\nthe section:\n* Declarations names are prefixed: `def seventeen : â„• := 17` inside a namespace `Nat` is given the\n  full name `Nat.seventeen`.\n* Names introduced by `export` declarations are also prefixed by the identifier.\n* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names\n  are preferred over names introduced by outer namespaces or `open`.\n* Within a namespace, declarations can be `protected`, which excludes them from the effects of\n  opening the namespace.\n\nAs with `section`, namespaces can be nested and the scope of a namespace is terminated by a\ncorresponding `end &lt;id&gt;` or the end of the file.\n\n`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.\n</code>",
 "389":
 "<code>Nonempty.{u} (Î± : Sort u) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nonempty Î±` is a typeclass that says that `Î±` is not an empty type,\nthat is, there exists an element in the type. It differs from `Inhabited Î±`\nin that `Nonempty Î±` is a `Prop`, which means that it does not actually carry\nan element of `Î±`, only a proof that *there exists* such an element.\nGiven `Nonempty Î±`, you can construct an element of `Î±` *nonconstructively*\nusing `Classical.choice`.\n</code>",
 "388":
 "<code>CategoryTheory.IsSplitMono.exists_splitMono.{vâ‚, uâ‚} {C : Type uâ‚} {instâœ : Category.{vâ‚, uâ‚} C} {X Y : C} {f : X âŸ¶ Y}\n  [self : IsSplitMono f] : Nonempty (SplitMono f)</code><span class=\"sep\"></span><code class=\"docstring\">There is a splitting </code>",
 "387":
 "<code>CategoryTheory.IsSplitMono.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsSplitMono f` is the assertion that `f` admits a retraction </code>",
 "386": "<code>autoParam (retraction âŠš f = ğŸ™ X) SplitMono.id._autoParam</code>",
 "385":
 "<code>CategoryTheory.SplitMono.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (retraction : Y âŸ¶ X)\n  (id : retraction âŠš f = ğŸ™ X := by cat_disch) : SplitMono f</code>",
 "384": "<code>SplitMono f</code>",
 "383":
 "<code>CategoryTheory.SplitMono.id.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (self : SplitMono f) :\n  self.retraction âŠš f = ğŸ™ X</code><span class=\"sep\"></span><code class=\"docstring\">`f` composed with `retraction` is the identity </code>",
 "382":
 "<code>CategoryTheory.SplitMono.retraction.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y}\n  (self : SplitMono f) : Y âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The map splitting `f` </code>",
 "381": "<code>Type uâ‚</code>",
 "380":
 "<code>CategoryTheory.SplitMono.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Type vâ‚</code><span class=\"sep\"></span><code class=\"docstring\">A split monomorphism is a morphism `f : X âŸ¶ Y` with a given retraction `retraction f : Y âŸ¶ X`\nsuch that `f â‰« retraction f = ğŸ™ X`.\n\nEvery split monomorphism is a monomorphism.\n</code>",
 "38": "<code>A</code>",
 "379":
 "<code class=\"docstring\">`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) =&gt; `(tactic| simp)\n```\n</code>",
 "378": "<code>f ((fun i â†¦ i) âŸ¨0, â‹¯âŸ©) = f ((fun i â†¦ i) âŸ¨1, â‹¯âŸ©)</code>",
 "377": "<code>f ((fun i â†¦ i) âŸ¨0, â‹¯âŸ©) = f ((fun i â†¦ i) âŸ¨0, â‹¯âŸ©)</code>",
 "376": "<code>f ((fun i â†¦ i) âŸ¨1, â‹¯âŸ©) = f ((fun i â†¦ i) âŸ¨1, â‹¯âŸ©)</code>",
 "375": "<code>f ((fun i â†¦ i) âŸ¨1, â‹¯âŸ©) = f ((fun i â†¦ i) âŸ¨0, â‹¯âŸ©)</code>",
 "374": "<code>f ((fun i â†¦ i) âŸ¨1, â‹¯âŸ©) = f y</code>",
 "373": "<code>f ((fun i â†¦ i) âŸ¨0, â‹¯âŸ©) = f y</code>",
 "372": "<code>f x = f y</code>",
 "371": "<code>CM.ExII_5.f : Fin 2 â†’ XElems</code>",
 "370": "<code>CM.ExII_5.g : XElems â†’ Fin 2</code>",
 "37": "<code>CM.ExI_1.hgf : A â†’ D</code>",
 "369": "<code>CM.ExII_5.X : Finset XElems</code>",
 "368": "<code>CM.ExII_5.A : Finset (Fin 2)</code>",
 "367": "<code>CM.ExII_5.XElems.s : XElems</code>",
 "366": "<code>CM.ExII_5.XElems.r : XElems</code>",
 "365": "<code>CM.ExII_5.XElems.q : XElems</code>",
 "364": "<code>CM.ExII_5.XElems.p : XElems</code>",
 "363": "<code>CM.ExII_5.XElems.b : XElems</code>",
 "362": "<code>CM.ExII_5.XElems : Type</code>",
 "361":
 "<code>Function.Injective.{u_1, u_2} {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f : Î± â†’ Î²` is called injective if `f x = f y` implies `x = y`. </code>",
 "360": "<code>Î± â†’ Ï‡</code>",
 "36":
 "<code class=\"docstring\">The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n</code>",
 "359":
 "<code>CM.Danilo's_formula.{u_1, u_2} {Î± : Type u_1} {Ï‡ : Type u_2} [Fintype Î±] [Fintype Ï‡] (A : Finset Î±) (X : Finset Ï‡)\n  (j : Î± â†’ Ï‡) (p : Ï‡ â†’ Î±) : p âˆ˜ j = id â†’ Function.Injective j â†’ â„•</code>",
 "358": "<code>Ï‡</code>",
 "357":
 "<code>Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±</code><span class=\"sep\"></span><code class=\"docstring\">`Finset.filter p s` is the set of elements of `s` that satisfy `p`.\n\nFor example, one can use `s.filter (Â· âˆˆ t)` to get the intersection of `s` with `t : Set Î±`\nas a `Finset Î±` (when a `DecidablePred (Â· âˆˆ t)` instance is available). </code>",
 "356":
 "<code>CM.Chad's_formula.pinvCount.{u_1, u_2} {Î± : Type u_1} {Ï‡ : Type u_2} [DecidableEq Î±] (X : Finset Ï‡) (p : Ï‡ â†’ Î±)\n  (a : Î±) : â„•</code>",
 "355": "<code>Ï‡ â†’ Î±</code>",
 "354": "<code>Finset Ï‡</code>",
 "353":
 "<code>DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Propositional equality is `Decidable` for all elements of a type.\n\nIn other words, an instance of `DecidableEq Î±` is a means of deciding the proposition `a = b` is\nfor all `a b : Î±`.\n</code>",
 "352":
 "<code>CM.Chad's_formula.{u_1, u_2} {Î± : Type u_1} {Ï‡ : Type u_2} [DecidableEq Î±] [Fintype Î±] [Fintype Ï‡] (X : Finset Ï‡)\n  (A : Finset Î±) (p : Ï‡ â†’ Î±) : â„•</code>",
 "351": "<code>kinv 1 = -1</code>",
 "350": "<code>kinv 1 = 1</code>",
 "35":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Î±`, `cases as with | nil =&gt; tacâ‚ | cons a as' =&gt; tacâ‚‚`,\n  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n</code>",
 "349": "<code>kinv (k (-1)) = -1</code>",
 "348": "<code>kinv (k 1) = 1</code>",
 "347": "<code>(kinv âˆ˜ k) (-1) = -1</code>",
 "346": "<code>(kinv âˆ˜ k) 1 = 1</code>",
 "345": "<code>k (-1) = 1</code>",
 "344": "<code>NNReal.coe_eq_one {r : â„â‰¥0} : â†‘r = 1 â†” r = 1</code>",
 "343": "<code>k 1 = 1</code>",
 "342": "<code>k âˆ˜ kinv = id</code>",
 "341": "<code>kinv âˆ˜ k = id</code>",
 "340": "<code>â„â‰¥0 â†’ â„</code>",
 "34": "<code>B</code>",
 "339": "<code>âˆ€ (x : â„), â†‘(k x) = x * x</code>",
 "338": "<code>â„ â†’ â„â‰¥0</code>",
 "337":
 "<code class=\"docstring\">`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `CommRing`, `LinearOrder` and `IsStrictOrderedRing`.\n\nAn example:\n```lean\nexample (x y z : â„š) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)\n        (h3 : 12*y - 4* z &lt; 0) : False := by\n  linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : â„š) : id x â‰¥ x := by\n  linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x â‰  y` hypothesis, `linarith` is run with both `x &lt; y` and `x &gt; y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (`false` by default.)\n* If `exfalso` is `false`, `linarith` will fail when the goal is neither an inequality nor `False`.\n  (`true` by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer- and rational-valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n</code>",
 "336": "<code>hinv 1 = -1</code>",
 "335": "<code>hinv 1 = 1</code>",
 "334": "<code>hinv (h (-1)) = -1</code>",
 "333": "<code>hinv (h 1) = 1</code>",
 "332": "<code>(hinv âˆ˜ h) (-1) = -1</code>",
 "331": "<code>(hinv âˆ˜ h) 1 = 1</code>",
 "330": "<code></code>",
 "33":
 "<code class=\"docstring\">Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))\n```\nThe variant `funext hâ‚ ... hâ‚™` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat Ã— Bool =&gt; ...) = (fun x =&gt; ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n</code>",
 "329": "<code>h (-1) = 1</code>",
 "328": "<code>h 1 = 1</code>",
 "327": "<code>h âˆ˜ hinv = id</code>",
 "326": "<code>hinv âˆ˜ h = id</code>",
 "325": "<code>âˆ€ (x : â„), h x = x * x</code>",
 "324": "<code>NNReal.mul_self_sqrt (x : â„â‰¥0) : sqrt x * sqrt x = x</code>",
 "323": "<code>NNReal.sqrt_mul_self (x : â„â‰¥0) : sqrt (x * x) = x</code>",
 "322":
 "<code>NNReal.sqrt : â„â‰¥0 â‰ƒo â„â‰¥0</code><span class=\"sep\"></span><code class=\"docstring\">Square root of a nonnegative real number. </code>",
 "321":
 "<code>NNReal : Type</code><span class=\"sep\"></span><code class=\"docstring\">Nonnegative real numbers, denoted as `â„â‰¥0` within the NNReal namespace </code>",
 "320": "<code>â„â‰¥0</code>",
 "32":
 "<code>Function.comp.{u, v, w} {Î± : Sort u} {Î² : Sort v} {Î´ : Sort w} (f : Î² â†’ Î´) (g : Î± â†’ Î²) : Î± â†’ Î´</code><span class=\"sep\"></span><code class=\"docstring\">Function composition, usually written with the infix operator `âˆ˜`. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.\n\nExamples:\n * `Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]`\n * `(List.reverse âˆ˜ List.drop 2) [3, 2, 4, 1] = [1, 4]`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `âˆ˜` in identifiers is `comp`.</code>",
 "319": "<code>âˆ€ (x : â„â‰¥0), g x = x * x</code>",
 "318": "<code>â„â‰¥0 â†’ â„â‰¥0</code>",
 "317":
 "<code class=\"docstring\">Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent. If the goal is not appropriate for `ring` (e.g. not an equality) `ring_nf` will be\nsuggested.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : â„•) (m : â„¤) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : â„¤) (n : â„•) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : â„•) : x + id y = y + id x := by ring!\nexample (x : â„•) (h : x * 2 &gt; 5): x + x &gt; 5 := by ring; assumption -- suggests ring_nf\n```\n</code>",
 "316":
 "<code>id_eq.{u_1} {Î± : Sort u_1} (a : Î±) : id a = a</code><span class=\"sep\"></span><code class=\"docstring\">`id x = x`, as a `@[simp]` lemma. </code>",
 "315":
 "<code>HDiv.hDiv.{u, v, w} {Î± : Type u} {Î² : Type v} {Î³ : outParam (Type w)} [self : HDiv Î± Î² Î³] : Î± â†’ Î² â†’ Î³</code><span class=\"sep\"></span><code class=\"docstring\">`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 â‰¤ a % b &lt; natAbs b` for `b â‰  0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.</code>",
 "314":
 "<code>HSub.hSub.{u, v, w} {Î± : Type u} {Î² : Type v} {Î³ : outParam (Type w)} [self : HSub Î± Î² Î³] : Î± â†’ Î² â†’ Î³</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a â‰¤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>",
 "313":
 "<code>HAdd.hAdd.{u, v, w} {Î± : Type u} {Î² : Type v} {Î³ : outParam (Type w)} [self : HAdd Î± Î² Î³] : Î± â†’ Î² â†’ Î³</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>",
 "312":
 "<code>HMul.hMul.{u, v, w} {Î± : Type u} {Î² : Type v} {Î³ : outParam (Type w)} [self : HMul Î± Î² Î³] : Î± â†’ Î² â†’ Î³</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>",
 "311":
 "<code>Real : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type `â„` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. </code>",
 "310": "<code>â„</code>",
 "31":
 "<code>Eq.{u_1} {Î± : Sort u_1} : Î± â†’ Î± â†’ Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (Î± : Type) (a b c d : Î±)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (Î± : Type) (a b : Î±) (p : Î± â†’ Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (Î± : Type) (a b : Î±) (p : Î± â†’ Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 â–¸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "309": "<code>âˆ€ (x : â„), f x = 3 * x + 7</code>",
 "308": "<code>â„ â†’ â„</code>",
 "307":
 "<code class=\"docstring\">Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `â»Â¹` `^` and `%`\nover numerical types such as `â„•`, `â„¤`, `â„š`, `â„`, `â„‚` and some general algebraic types,\nand can prove goals of the form `A = B`, `A â‰  B`, `A &lt; B` and `A â‰¤ B`, where `A` and `B` are\nnumerical expressions. It also has a relatively simple primality prover.\n</code>",
 "306": "<code>1 = 0</code>",
 "305": "<code>k 0 = 0</code>",
 "304": "<code>h 0 = 1</code>",
 "303":
 "<code class=\"docstring\">`by_contra h` proves `âŠ¢ p` by contradiction,\nintroducing a hypothesis `h : Â¬p` and proving `False`.\n* If `p` is a negation `Â¬q`, `h : q` will be introduced instead of `Â¬Â¬q`.\n* If `p` is decidable, it uses `Decidable.byContradiction` instead of `Classical.byContradiction`.\n* If `h` is omitted, the introduced variable `_: Â¬p` will be anonymous.\n</code>",
 "302": "<code>CM.ExII_3.k : Fin 2 âŸ¶ Fin 2</code>",
 "301": "<code>CM.ExII_3.h : Fin 2 âŸ¶ Fin 2</code>",
 "300":
 "<code>Fin.mk {n : â„•} (val : â„•) (isLt : val &lt; n) : Fin n</code><span class=\"sep\"></span><code class=\"docstring\">Creates a `Fin n` from `i : Nat` and a proof that `i &lt; n`. </code>",
 "30":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "3":
 "<code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List Î±` is the list of elements of type `Î±`, and is defined as follows:\n```\ninductive List (Î± : Type u) where\n| nil\n| cons (head : Î±) (tail : List Î±)\n```\nA list of elements of type `Î±` is either the empty list, `nil`,\nor an element `head : Î±` followed by a list `tail : List Î±`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>",
 "299":
 "<code class=\"docstring\">`fin_cases h` performs case analysis on a hypothesis of the form\n`h : A`, where `[Fintype A]` is available, or\n`h : a âˆˆ A`, where `A : Finset X`, `A : Multiset X` or `A : List X`.\n\nAs an example, in\n```\nexample (f : â„• â†’ Prop) (p : Fin 3) (h0 : f 0) (h1 : f 1) (h2 : f 2) : f p.val := by\n  fin_cases p; simp\n  all_goals assumption\n```\nafter `fin_cases p; simp`, there are three goals, `f 0`, `f 1`, and `f 2`.\n</code>",
 "298": "<code>Fin 2</code>",
 "297":
 "<code>Fin (n : â„•) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>",
 "296": "<code>CM.ExII_3.f : Fin 2 âŸ¶ Fin 2</code>",
 "295": "<code>h âŠš ğŸ™ B = k âŠš ğŸ™ B</code>",
 "294": "<code>h âŠš f âŠš finv = k âŠš f âŠš finv</code>",
 "293": "<code>(h âŠš f) âŠš finv = (k âŠš f) âŠš finv</code>",
 "292": "<code>h âŠš f = k âŠš f</code>",
 "291": "<code>h = k</code>",
 "290": "<code>ğŸ™ A âŠš h = ğŸ™ A âŠš k</code>",
 "29": "<code>CM.ExI_1.hg : B â†’ D</code>",
 "289": "<code>(finv âŠš f) âŠš h = (finv âŠš f) âŠš k</code>",
 "288": "<code>finv âŠš f âŠš h = finv âŠš f âŠš k</code>",
 "287": "<code>f âŠš h = f âŠš k</code>",
 "286": "<code>f âŠš finv = ğŸ™ B</code>",
 "285": "<code>finv âŠš f = ğŸ™ A</code>",
 "284": "<code>âˆƒ finv, finv âŠš f = ğŸ™ A âˆ§ f âŠš finv = ğŸ™ B</code>",
 "283":
 "<code class=\"docstring\">Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `&lt;lhs&gt;\\n  _ = &lt;rhs&gt; :=\n&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n</code>",
 "282": "<code>k âŠš f = ğŸ™ A âˆ§ f âŠš k = ğŸ™ B</code>",
 "281": "<code>kinv âŠš k = ğŸ™ B âˆ§ k âŠš kinv = ğŸ™ C</code>",
 "280": "<code>finv âŠš f = ğŸ™ A âˆ§ f âŠš finv = ğŸ™ B</code>",
 "28": "<code>CM.ExI_1.h : C â†’ D</code>",
 "279": "<code>IsIso k</code>",
 "278": "<code>B âŸ¶ C</code>",
 "277":
 "<code>And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b</code><span class=\"sep\"></span><code class=\"docstring\">`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. </code>",
 "276": "<code>IsIso f</code>",
 "275": "<code>g âŠš f = ğŸ™ A âˆ§ f âŠš g = ğŸ™ B</code>",
 "274":
 "<code class=\"docstring\">If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>",
 "273":
 "<code class=\"docstring\">`use eâ‚, eâ‚‚, â‹¯` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic\n`refine âŸ¨eâ‚, eâ‚‚, â‹¯, ?_, â‹¯, ?_âŸ©` with any number of placeholders (rather than just one) and\nthen trying to close goals associated to the placeholders with a configurable discharger (rather\nthan just `try trivial`).\n\nExamples:\n\n```lean\nexample : âˆƒ x : Nat, x = x := by use 42\n\nexample : âˆƒ x : Nat, âˆƒ y : Nat, x = y := by use 42, 42\n\nexample : âˆƒ x : String Ã— String, x.1 = x.2 := by use (\"forty-two\", \"forty-two\")\n```\n\n`use! eâ‚, eâ‚‚, â‹¯` is similar but it applies constructors everywhere rather than just for\ngoals that correspond to the last argument of a constructor. This gives the effect that\nnested constructors are being flattened out, with the supplied values being used along the\nleaves and nodes of the tree of constructors.\nWith `use!` one can feed in each `42` one at a time:\n\n```lean\nexample : âˆƒ p : Nat Ã— Nat, p.1 = p.2 := by use! 42, 42\n\nexample : âˆƒ p : Nat Ã— Nat, p.1 = p.2 := by use! (42, 42)\n```\n\nThe second line makes use of the fact that `use!` tries refining with the argument before\napplying a constructor. Also note that `use`/`use!` by default uses a tactic\ncalled `use_discharger` to discharge goals, so `use! 42` will close the goal in this example since\n`use_discharger` applies `rfl`, which as a consequence solves for the other `Nat` metavariable.\n\nThese tactics take an optional discharger to handle remaining explicit `Prop` constructor arguments.\nBy default it is `use (discharger := try with_reducible use_discharger) eâ‚, eâ‚‚, â‹¯`.\nTo turn off the discharger and keep all goals, use `(discharger := skip)`.\nTo allow \"heavy refls\", use `(discharger := try use_discharger)`.\n</code>",
 "272": "<code>Category.{v, u} ğ’</code>",
 "271":
 "<code>CategoryTheory.Iso.trans.{v, u} {C : Type u} [Category.{v, u} C] {X Y Z : C} (Î± : X â‰… Y) (Î² : Y â‰… Z) : X â‰… Z</code><span class=\"sep\"></span><code class=\"docstring\">Composition of two isomorphisms </code>",
 "270":
 "<code>(Î².hom âŠš Î±.hom) âŠš Î±.inv âŠš Î².inv = ğŸ™ Z</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "27": "<code>CM.ExI_1.g : B â†’ C</code>",
 "269":
 "<code>(Î±.inv âŠš Î².inv) âŠš Î².hom âŠš Î±.hom = ğŸ™ X</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "268":
 "<code>Z âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "267":
 "<code>X âŸ¶ Z</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "266": "<code>Y â‰… Z</code>",
 "265":
 "<code>CategoryTheory.Iso.symm.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (I : X â‰… Y) : Y â‰… X</code><span class=\"sep\"></span><code class=\"docstring\">Inverse isomorphism. </code>",
 "264":
 "<code>I.inv âŠš I.hom = ğŸ™ X</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "263":
 "<code>I.hom âŠš I.inv = ğŸ™ Y</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "262":
 "<code>X âŸ¶ Y</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "261":
 "<code>Y âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "260":
 "<code>CategoryTheory.Iso.refl.{v, u} {C : Type u} [Category.{v, u} C] (X : C) : X â‰… X</code><span class=\"sep\"></span><code class=\"docstring\">Identity isomorphism. </code>",
 "26": "<code>CM.ExI_1.f : A â†’ B</code>",
 "259":
 "<code>ğŸ™ X âŠš ğŸ™ X = ğŸ™ X</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "258":
 "<code>ğŸ™ X âŠš ğŸ™ X = ğŸ™ X</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "257":
 "<code>X âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "256":
 "<code>X âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "255": "<code>Category.{v, u} C</code>",
 "254": "<code>âˆƒ inv, inv âŠš f = ğŸ™ X âˆ§ f âŠš inv = ğŸ™ Y</code>",
 "253":
 "<code>CategoryTheory.IsIso.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} {f : X âŸ¶ Y}\n  (out : âˆƒ inv, inv âŠš f = ğŸ™ X âˆ§ f âŠš inv = ğŸ™ Y) : IsIso f</code>",
 "252":
 "<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a âˆ§ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`âŸ¨ha, hbâŸ© : a âˆ§ b`, and if `h : a âˆ§ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `âˆ§` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `âˆ§` over `/\\`).</code>",
 "251":
 "<code>CategoryTheory.IsIso.out.{v, u} {C : Type u} {instâœ : Category.{v, u} C} {X Y : C} {f : X âŸ¶ Y} [self : IsIso f] :\n  âˆƒ inv, inv âŠš f = ğŸ™ X âˆ§ f âŠš inv = ğŸ™ Y</code><span class=\"sep\"></span><code class=\"docstring\">The existence of an inverse morphism. </code>",
 "250":
 "<code class=\"docstring\">The universe of propositions. `Prop â‰¡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>",
 "25": "<code>CM.ExI_1.D.dâ‚† : D</code>",
 "249":
 "<code>CategoryTheory.IsIso.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">The `IsIso` typeclass expresses that a morphism is invertible.\n\nGiven a morphism `f` with `IsIso f`, one can view `f` as an isomorphism via `asIso f` and get\nthe inverse using `inv f`. </code>",
 "248": "<code>autoParam (hom âŠš inv = ğŸ™ Y) Iso.inv_hom_id._autoParam</code>",
 "247": "<code>autoParam (inv âŠš hom = ğŸ™ X) Iso.hom_inv_id._autoParam</code>",
 "246": "<code>Y âŸ¶ X</code>",
 "245":
 "<code>CategoryTheory.Iso.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (hom : X âŸ¶ Y) (inv : Y âŸ¶ X)\n  (hom_inv_id : inv âŠš hom = ğŸ™ X := by cat_disch) (inv_hom_id : hom âŠš inv = ğŸ™ Y := by cat_disch) : X â‰… Y</code>",
 "244":
 "<code>CategoryTheory.Iso.inv_hom_id.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (self : X â‰… Y) :\n  self.hom âŠš self.inv = ğŸ™ Y</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "243": "<code>X â‰… Y</code>",
 "242":
 "<code>CategoryTheory.Iso.hom_inv_id.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (self : X â‰… Y) :\n  self.inv âŠš self.hom = ğŸ™ X</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "241":
 "<code>CategoryTheory.Iso.inv.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (self : X â‰… Y) : Y âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "240":
 "<code>CategoryTheory.Iso.hom.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (self : X â‰… Y) : X âŸ¶ Y</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "24": "<code>CM.ExI_1.D.dâ‚… : D</code>",
 "239": "<code>C</code>",
 "238":
 "<code>CategoryTheory.Iso.{v, u} {C : Type u} [Category.{v, u} C] (X Y : C) : Type v</code><span class=\"sep\"></span><code class=\"docstring\">An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `CategoryTheory.Core` for the category with the same objects and isomorphisms playing\nthe role of morphisms. </code>",
 "237": "<code>C âŸ¶ B</code>",
 "236": "<code>A âŸ¶ C</code>",
 "235": "<code>B âŸ¶ A</code>",
 "234": "<code>ğ’</code>",
 "233": "<code class=\"docstring\">The universe parameter u</code>",
 "232":
 "<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {Î± : Type u}      -- implicit\n    (a : Î±)           -- explicit\n    [instBEq : BEq Î±] -- instance implicit, named\n    [Hashable Î±]      -- instance implicit, anonymous\n\n  def isEqual (b : Î±) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {Î± : Type u} (a : Î±) [instBEq : BEq Î±] (b : Î±) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : Î±} := a == b â†” b == a\n\n  #check eqComm\n  -- eqComm.{u} {Î± : Type u} {a : Î±} [instBEq : BEq Î±] {b : Î±} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src Ã— String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {Î± : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString Î±]  -- available in the proof as `Î±` is included\n  (a : Î±)       -- available in the proof as mentioned in the header\n  {Î² : Type}    -- not available in the proof\n  [ToString Î²]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString Î±]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>",
 "231":
 "<code>congrFun.{u, v} {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x} (h : f = g) (a : Î±) : f a = g a</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function part of an application: If `f = g` then `f a = g a`. </code>",
 "230":
 "<code class=\"docstring\">Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n</code>",
 "23": "<code>CM.ExI_1.D.dâ‚„ : D</code>",
 "229": "<code>âˆ€ (a : Point A), f âŠš a = g âŠš a</code>",
 "228": "<code>Point A</code>",
 "227": "<code>A âŸ¶ B</code>",
 "226":
 "<code>Quiver.{v, u} (V : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">A quiver `G` on a type `V` of vertices assigns to every pair `a b : V` of vertices\na type `a âŸ¶ b` of arrows from `a` to `b`.\n\nFor graphs with no repeated edges, one can use `Quiver.{0} V`, which ensures\n`a âŸ¶ b : Prop`. For multigraphs, one can use `Quiver.{v+1} V`, which ensures\n`a âŸ¶ b : Type v`.\n\nBecause `Category` will later extend this class, we call the field `Hom`.\nExcept when constructing instances, you should rarely see this, and use the `âŸ¶` notation instead.\n</code>",
 "225":
 "<code>autoParam (âˆ€ {W X Y Z : obj} (f : W âŸ¶ X) (g : X âŸ¶ Y) (h : Y âŸ¶ Z), h âŠš g âŠš f = (h âŠš g) âŠš f) Category.assoc._autoParam</code>",
 "224":
 "<code>autoParam (âˆ€ {X Y : obj} (f : X âŸ¶ Y), ğŸ™ Y âŠš f = f) Category.comp_id._autoParam</code>",
 "223":
 "<code>autoParam (âˆ€ {X Y : obj} (f : X âŸ¶ Y), f âŠš ğŸ™ X = f) Category.id_comp._autoParam</code>",
 "222": "<code>CategoryStruct.{v, u} obj</code>",
 "221":
 "<code>CategoryTheory.Category.mk.{v, u} {obj : Type u} [toCategoryStruct : CategoryStruct.{v, u} obj]\n  (id_comp : âˆ€ {X Y : obj} (f : X âŸ¶ Y), f âŠš ğŸ™ X = f := by cat_disch)\n  (comp_id : âˆ€ {X Y : obj} (f : X âŸ¶ Y), ğŸ™ Y âŠš f = f := by cat_disch)\n  (assoc : âˆ€ {W X Y Z : obj} (f : W âŸ¶ X) (g : X âŸ¶ Y) (h : Y âŸ¶ Z), h âŠš g âŠš f = (h âŠš g) âŠš f := by cat_disch) :\n  Category.{v, u} obj</code>",
 "220": "<code>Y âŸ¶ Z</code>",
 "22": "<code>CM.ExI_1.D.dâ‚ƒ : D</code>",
 "219": "<code>W âŸ¶ X</code>",
 "218":
 "<code>CategoryTheory.Category.assoc.{v, u} {obj : Type u} [self : Category.{v, u} obj] {W X Y Z : obj} (f : W âŸ¶ X) (g : X âŸ¶ Y)\n  (h : Y âŸ¶ Z) : h âŠš g âŠš f = (h âŠš g) âŠš f</code><span class=\"sep\"></span><code class=\"docstring\">Composition in a category is associative. </code>",
 "217":
 "<code>CategoryTheory.Category.comp_id.{v, u} {obj : Type u} [self : Category.{v, u} obj] {X Y : obj} (f : X âŸ¶ Y) : ğŸ™ Y âŠš f = f</code><span class=\"sep\"></span><code class=\"docstring\">Identity morphisms are right identities for composition. </code>",
 "216": "<code>X âŸ¶ Y</code>",
 "215":
 "<code>CategoryTheory.Category.id_comp.{v, u} {obj : Type u} [self : Category.{v, u} obj] {X Y : obj} (f : X âŸ¶ Y) : f âŠš ğŸ™ X = f</code><span class=\"sep\"></span><code class=\"docstring\">Identity morphisms are left identities for composition. </code>",
 "214": "<code>obj</code>",
 "213":
 "<code>CategoryTheory.CategoryStruct.id.{v, u} {obj : Type u} [self : CategoryStruct.{v, u} obj] (X : obj) : X âŸ¶ X</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "212":
 "<code>Quiver.Hom.{v, u} {V : Type u} [self : Quiver V] : V â†’ V â†’ Sort v</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "211":
 "<code>CategoryTheory.CategoryStruct.{v, u} (obj : Type u) : Type (max u (v + 1))</code><span class=\"sep\"></span><code class=\"docstring\">A preliminary structure on the way to defining a category,\ncontaining the data, but none of the axioms. </code>",
 "210":
 "<code>CategoryTheory.Category.toCategoryStruct.{v, u} {obj : Type u} [self : Category.{v, u} obj] : CategoryStruct.{v, u} obj</code>",
 "21": "<code>CM.ExI_1.D.dâ‚‚ : D</code>",
 "209": "<code>Type u</code>",
 "208":
 "<code>CategoryTheory.Category.{v, u} (obj : Type u) : Type (max u (v + 1))</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.) </code>",
 "207": "<code>idB.toFun x = \"coffee\"</code>",
 "206": "<code>k.toFun \"Mary\" = \"coffee\"</code>",
 "205": "<code>h.toFun x = \"Mary\"</code>",
 "204":
 "<code>CM.ExI_9.idB : CM.CM_Finset.Map CM.CM_Finset.B CM.CM_Finset.B</code>",
 "203": "<code>idB.toFun \"eggs\" = \"eggs\"</code>",
 "202":
 "<code>CM.ExI_9.k : CM.CM_Finset.Map CM.CM_Finset.A CM.CM_Finset.B</code>",
 "201": "<code>k.toFun \"John\" = \"eggs\"</code>",
 "200":
 "<code>CM.ExI_9.h : CM.CM_Finset.Map CM.CM_Finset.B CM.CM_Finset.A</code>",
 "20": "<code>CM.ExI_1.D.dâ‚ : D</code>",
 "2":
 "<code>CategoryTheory.CategoryStruct.comp.{v, u} {obj : Type u} [self : CategoryStruct.{v, u} obj] {X Y Z : obj} :\n  (X âŸ¶ Y) â†’ (Y âŸ¶ Z) â†’ (X âŸ¶ Z)</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "199": "<code>h.toFun \"eggs\" = \"John\"</code>",
 "198": "<code>Â¬x = \"eggs\"</code>",
 "197": "<code>x = \"eggs\"</code>",
 "196":
 "<code class=\"docstring\">`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.\n</code>",
 "195":
 "<code>Function.comp_apply.{u_1, u_2, u_3} {Î² : Sort u_1} {Î´ : Sort u_2} {Î± : Sort u_3} {f : Î² â†’ Î´} {g : Î± â†’ Î²} {x : Î±} :\n  (f âˆ˜ g) x = f (g x)</code>",
 "1941": "<code>Y.yâ‚ = Y.yâ‚‚</code>",
 "1940": "<code>Î² Y.yâ‚‚ = Y.yâ‚‚</code>",
 "194":
 "<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>",
 "1939": "<code>Î² Y.yâ‚ = Y.yâ‚</code>",
 "1938": "<code>Î² y = y</code>",
 "1937": "<code>Y.yâ‚‚ = f x</code>",
 "1936": "<code>Y.yâ‚ = f x</code>",
 "1935": "<code>X.xâ‚‚ = X.xâ‚„</code>",
 "1934": "<code>(Î± âŠš Î±) X.xâ‚„ = X.xâ‚„</code>",
 "1933": "<code>(Î± âŠš Î±) X.xâ‚ƒ = X.xâ‚ƒ</code>",
 "1932": "<code>(Î± âŠš Î±) X.xâ‚‚ = X.xâ‚‚</code>",
 "1931": "<code>(Î± âŠš Î±) X.xâ‚ = X.xâ‚</code>",
 "1930": "<code>(Î± âŠš Î±) x = x</code>",
 "193":
 "<code class=\"docstring\">The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`Â¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed using the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n</code>",
 "1929": "<code>(Î± ^ 2) x = x</code>",
 "1928": "<code>y = f X.xâ‚„</code>",
 "1927": "<code>y = f X.xâ‚ƒ</code>",
 "1926": "<code>y = f X.xâ‚‚</code>",
 "1925": "<code>y = f X.xâ‚</code>",
 "1924":
 "<code class=\"docstring\">`and_intros` applies `And.intro` until it does not make progress. </code>",
 "1923": "<code>CM.Ex14_5.f : X âŸ¶ Y</code>",
 "1922": "<code>CM.Ex14_5.Î² : End Y</code>",
 "1921": "<code>CM.Ex14_5.Î± : End X</code>",
 "1920": "<code>CM.Ex14_5.Y.yâ‚‚ : Y</code>",
 "192": "<code>Lean.TSyntax `Lean.Parser.Tactic.rwRule</code>",
 "1919": "<code>CM.Ex14_5.Y.yâ‚ : Y</code>",
 "1918": "<code>CM.Ex14_5.Y : Type</code>",
 "1917": "<code>CM.Ex14_5.X.xâ‚„ : X</code>",
 "1916": "<code>CM.Ex14_5.X.xâ‚ƒ : X</code>",
 "1915": "<code>CM.Ex14_5.X.xâ‚‚ : X</code>",
 "1914": "<code>CM.Ex14_5.X.xâ‚ : X</code>",
 "1913": "<code>CM.Ex14_5.X : Type</code>",
 "1912":
 "<code class=\"docstring\">`nth_rw` is a variant of `rw` that only changes the `nâ‚, ..., nâ‚–`áµ—Ê° _occurrence_ of the expression\nto be rewritten. Like `rw`, and unlike `nth_rewrite`, it will try to close the goal by trying `rfl`\nafterwards. `nth_rw nâ‚ ... nâ‚– [eqâ‚, eqâ‚‚,..., eqâ‚˜]` will rewrite the `nâ‚, ..., nâ‚–`áµ—Ê° _occurrence_ of\neach of the `m` equalities `eqáµ¢`in that order. Occurrences are counted beginning with `1` in\norder of precedence. For example,\n```lean\nexample (h : a = 1) : a + a + a + a + a = 5 := by\n  nth_rw 2 3 [h]\n/-\na: â„•\nh: a = 1\nâŠ¢ a + 1 + 1 + a + a = 5\n-/\n```\nNotice that the second and third occurrences of `a` from the left have been rewritten by\n`nth_rw`.\n\nTo understand the importance of order of precedence, consider the example below\n```lean\nexample (a b c : Nat) : (a + b) + c = (b + a) + c := by\n  nth_rewrite 2 [Nat.add_comm] -- âŠ¢ (b + a) + c = (b + a) + c\n```\nHere, although the occurrence parameter is `2`, `(a + b)` is rewritten to `(b + a)`. This happens\nbecause in order of precedence, the first occurrence of `_ + _` is the one that adds `a + b` to `c`.\nThe occurrence in `a + b` counts as the second occurrence.\n\nIf a term `t` is introduced by rewriting with `eqáµ¢`, then this instance of `t` will be counted as an\n_occurrence_ of `t` for all subsequent rewrites of `t` with `eqâ±¼` for `j &gt; i`. This behaviour is\nillustrated by the example below\n```lean\nexample (h : a = a + b) : a + a + a + a + a = 0 := by\n  nth_rw 3 [h, h]\n/-\na b: â„•\nh: a = a + b\nâŠ¢ a + a + (a + b + b) + a + a = 0\n-/\n```\nHere, the first `nth_rw` with `h` introduces an additional occurrence of `a` in the goal. That is,\nthe goal state after the first rewrite looks like below\n```lean\n/-\na b: â„•\nh: a = a + b\nâŠ¢ a + a + (a + b) + a + a = 0\n-/\n```\nThis new instance of `a` also turns out to be the third _occurrence_ of `a`.  Therefore,\nthe next `nth_rw` with `h` rewrites this `a`.\n\nFurther, `nth_rw` will close the remaining goal with `rfl` if possible.\n</code>",
 "1911": "<code>f âŠš Î± ^ 4 = (Î² ^ 4) âŠš f</code>",
 "1910": "<code>(Î± ^ 4) x = x</code>",
 "191":
 "<code>Lean.Parser.Category.tactic : Lean.Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n</code>",
 "1909": "<code>CM.Ex14_4.Î² : Y âŸ¶ Y</code>",
 "1908": "<code>CM.Ex14_4.Î± : X âŸ¶ X</code>",
 "1907": "<code>CM.Ex14_4.Y.yâ‚ : Y</code>",
 "1906": "<code>CM.Ex14_4.Y : Type</code>",
 "1905": "<code>CM.Ex14_4.X.xâ‚‚ : X</code>",
 "1904": "<code>CM.Ex14_4.X.xâ‚ : X</code>",
 "1903": "<code>CM.Ex14_4.X : Type</code>",
 "1902": "<code>Î± x = x</code>",
 "1901": "<code>y = f x</code>",
 "1900":
 "<code>Function.Semiconj.iterate_right.{u, v} {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {ga : Î± â†’ Î±} {gb : Î² â†’ Î²}\n  (h : Semiconj f ga gb) (n : â„•) : Semiconj f ga^[n] gb^[n]</code>",
 "190":
 "<code>Lean.Parser.Tactic.rwRule : Lean.ParserDescr</code><span class=\"sep\"></span><code class=\"docstring\">If `thm` is a theorem `a = b`, then as a rewrite rule,\n* `thm` means to replace `a` with `b`, and\n* `â† thm` means to replace `b` with `a`.\n</code>",
 "19": "<code>CM.ExI_1.D : Type</code>",
 "1899": "<code>Semiconj f Î±^[n] Î²^[n]</code>",
 "1898":
 "<code>Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. </code>",
 "1897":
 "<code>Function.semiconj_iff_comp_eq.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {ga : Î± â†’ Î±} {gb : Î² â†’ Î²} :\n  Semiconj f ga gb â†” f âˆ˜ ga = gb âˆ˜ f</code><span class=\"sep\"></span><code class=\"docstring\">Definition of `Function.Semiconj` in terms of functional equality. </code>",
 "1896":
 "<code>Function.Semiconj.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (ga : Î± â†’ Î±) (gb : Î² â†’ Î²) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">We say that `f : Î± â†’ Î²` semiconjugates `ga : Î± â†’ Î±` to `gb : Î² â†’ Î²` if `f âˆ˜ ga = gb âˆ˜ f`.\nWe use `âˆ€ x, f (ga x) = gb (f x)` as the definition, so given `h : Function.Semiconj f ga gb` and\n`a : Î±`, we have `h a : f (ga a) = gb (f a)` and `h.comp_eq : f âˆ˜ ga = gb âˆ˜ f`.\n</code>",
 "1895": "<code>Semiconj f Î± Î²</code>",
 "1894":
 "<code class=\"docstring\">`have` is used to declare local hypotheses and opaque local definitions.\n\nIt has the same syntax as `let`, and it is equivalent to `let +nondep`,\ncreating a *nondependent* let expression.\n</code>",
 "1893":
 "<code>pow_comm {X Y : Type} (f : X âŸ¶ Y) (Î± : End X) (Î² : End Y) (hf_comm : f âŠš Î± = Î² âŠš f) (n : â„•) : f âŠš Î±^[n] = Î²^[n] âŠš f</code>",
 "1892": "<code>f âŠš Î± ^ 5 = (Î² ^ 5) âŠš f</code>",
 "1891": "<code>xâ‚‚ = (Î± ^ 5) xâ‚</code>",
 "1890": "<code>f (Î± xâ‚) = f (Î± xâ‚‚)</code>",
 "189":
 "<code><span class=\"literal string\">\"eval_map\"</span> : String</code>",
 "1889": "<code>CategoryTheory.types.{u} : LargeCategory (Type u)</code>",
 "1888": "<code>_fvar.2 âŸ¶ _fvar.4</code>",
 "1887": "<code>_fvar.4</code>",
 "1886": "<code>Î² yâ‚‚ = f (Î± xâ‚‚)</code>",
 "1885": "<code>Î² yâ‚ = f (Î± xâ‚)</code>",
 "1884": "<code>Î± xâ‚ = Î± xâ‚‚</code>",
 "1883": "<code>yâ‚‚ = f xâ‚‚</code>",
 "1882": "<code>yâ‚ = f xâ‚</code>",
 "1881": "<code>End Y</code>",
 "1880": "<code>End X</code>",
 "188":
 "<code>âˆ€ a âˆˆ B,\n  (match a with\n    | \"eggs\" =&gt; \"eggs\"\n    | x =&gt; \"coffee\") âˆˆ\n    B</code>",
 "1879":
 "<code>CategoryTheory.SingleObj.{u_1} : Type u_1 â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">Abbreviation that allows writing `CategoryTheory.SingleObj` rather than `Quiver.SingleObj`.\n</code>",
 "1878":
 "<code>Quiver.SingleObj.{u_1} : Type u_1 â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">Type tag on `Unit` used to define single-object quivers. </code>",
 "1877": "<code>ParentType</code>",
 "1876": "<code>Pâ‚ƒ.t</code>",
 "1875": "<code>CM.Ex12_3.gender_and_clan' : Pâ‚ƒ âŸ¶ GC</code>",
 "1874": "<code>CM.Ex12_3.gender_and_clan : Pâ‚ƒ.t âŸ¶ GC.t</code>",
 "1873": "<code>âˆ€ {a : Gender Ã— Clan}, a âˆˆ Set.univ â†’ mâ‚ƒ a âˆˆ Set.univ</code>",
 "1872": "<code>Gender Ã— Clan âŸ¶ Gender Ã— Clan</code>",
 "1871": "<code>Set (Gender Ã— Clan)</code>",
 "1870": "<code>CM.Ex12_3.GC : SetWithTwoEndomaps</code>",
 "187": "<code>CM.ExI_9.idB : Map B B</code>",
 "1869": "<code>CM.Ex12_3.fâ‚ƒ : Gender Ã— Clan âŸ¶ Gender Ã— Clan</code>",
 "1868": "<code>CM.Ex12_3.mâ‚ƒ : Gender Ã— Clan âŸ¶ Gender Ã— Clan</code>",
 "1867": "<code>âˆ€ {a : Personâ‚ƒ}, a âˆˆ Set.univ â†’ motherâ‚ƒ a âˆˆ Set.univ</code>",
 "1866": "<code>Personâ‚ƒ âŸ¶ Personâ‚ƒ</code>",
 "1865": "<code>Set Personâ‚ƒ</code>",
 "1864": "<code>CM.Ex12_3.Pâ‚ƒ : SetWithTwoEndomaps</code>",
 "1863": "<code>CM.Ex12_3.fatherâ‚ƒ : Personâ‚ƒ âŸ¶ Personâ‚ƒ</code>",
 "1862":
 "<code>CM.Ex12_3.Personâ‚ƒ.mk (parentType : ParentType) (parentClan : ParentClan) : Personâ‚ƒ</code>",
 "1861": "<code>Personâ‚ƒ</code>",
 "1860": "<code>CM.Ex12_3.motherâ‚ƒ : Personâ‚ƒ âŸ¶ Personâ‚ƒ</code>",
 "186":
 "<code>âˆ€ a âˆˆ A,\n  (match a with\n    | \"John\" =&gt; \"eggs\"\n    | x =&gt; \"coffee\") âˆˆ\n    B</code>",
 "1859":
 "<code>CM.Ex12_3.Personâ‚ƒ.parentClan (self : Personâ‚ƒ) : ParentClan</code>",
 "1858":
 "<code>CM.Ex12_3.Personâ‚ƒ.parentType (self : Personâ‚ƒ) : ParentType</code>",
 "1857": "<code>CM.Ex12_3.Personâ‚ƒ : Type</code>",
 "1856": "<code>ParentClan</code>",
 "1855":
 "<code class=\"docstring\">`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 =&gt; rfl\n  | i+1 =&gt; simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n</code>",
 "1854": "<code>Pâ‚‚.t</code>",
 "1853": "<code>CM.Ex12_3.clan' : Pâ‚‚ âŸ¶ C</code>",
 "1852": "<code>CM.Ex12_3.clan : Pâ‚‚.t âŸ¶ C.t</code>",
 "1851": "<code>âˆ€ {a : Personâ‚‚}, a âˆˆ Set.univ â†’ motherâ‚‚ a âˆˆ Set.univ</code>",
 "1850": "<code>Personâ‚‚ âŸ¶ Personâ‚‚</code>",
 "185": "<code>CM.ExI_9.k : Map A B</code>",
 "1849": "<code>Set Personâ‚‚</code>",
 "1848": "<code>CM.Ex12_3.Pâ‚‚ : SetWithTwoEndomaps</code>",
 "1847": "<code>CM.Ex12_3.fatherâ‚‚ : Personâ‚‚ âŸ¶ Personâ‚‚</code>",
 "1846":
 "<code>CM.Ex12_3.Personâ‚‚.mk (parentClan : ParentClan) : Personâ‚‚</code>",
 "1845": "<code>Personâ‚‚</code>",
 "1844": "<code>CM.Ex12_3.motherâ‚‚ : Personâ‚‚ âŸ¶ Personâ‚‚</code>",
 "1843":
 "<code>CM.Ex12_3.Personâ‚‚.parentClan (self : Personâ‚‚) : ParentClan</code>",
 "1842": "<code>CM.Ex12_3.Personâ‚‚ : Type</code>",
 "1841": "<code>CM.Ex12_3.ParentClan.isBear : ParentClan</code>",
 "1840": "<code>CM.Ex12_3.ParentClan.isWolf : ParentClan</code>",
 "184": "<code>aâœ = \"coffee\"</code>",
 "1839": "<code>CM.Ex12_3.ParentClan : Type</code>",
 "1838": "<code>Pâ‚.t</code>",
 "1837": "<code>CM.Ex12_3.gender' : Pâ‚ âŸ¶ G</code>",
 "1836": "<code>CM.Ex12_3.gender : Pâ‚.t âŸ¶ G.t</code>",
 "1835": "<code>âˆ€ {a : Personâ‚}, a âˆˆ Set.univ â†’ motherâ‚ a âˆˆ Set.univ</code>",
 "1834": "<code>Personâ‚ âŸ¶ Personâ‚</code>",
 "1833": "<code>Set Personâ‚</code>",
 "1832": "<code>CM.Ex12_3.Pâ‚ : SetWithTwoEndomaps</code>",
 "1831": "<code>CM.Ex12_3.fatherâ‚ : Personâ‚ âŸ¶ Personâ‚</code>",
 "1830":
 "<code>CM.Ex12_3.Personâ‚.mk (parentType : ParentType) : Personâ‚</code>",
 "183": "<code>aâœ = \"eggs\"</code>",
 "1829": "<code>CM.Ex12_3.motherâ‚ : Personâ‚ âŸ¶ Personâ‚</code>",
 "1828":
 "<code>CM.Ex12_3.Personâ‚.parentType (self : Personâ‚) : ParentType</code>",
 "1827": "<code>CM.Ex12_3.Personâ‚ : Type</code>",
 "1826": "<code>CM.Ex12_3.ParentType.isFather : ParentType</code>",
 "1825": "<code>CM.Ex12_3.ParentType.isMother : ParentType</code>",
 "1824": "<code>CM.Ex12_3.ParentType : Type</code>",
 "1823": "<code>âˆ€ {a : Clan}, a âˆˆ Set.univ â†’ mâ‚‚ a âˆˆ Set.univ</code>",
 "1822": "<code>Clan âŸ¶ Clan</code>",
 "1821": "<code>Set Clan</code>",
 "1820": "<code>CM.Ex12_3.C : SetWithTwoEndomaps</code>",
 "182": "<code>aâœ = \"eggs\" âˆ¨ aâœ = \"coffee\"</code>",
 "1819": "<code>CM.Ex12_3.fâ‚‚ : Clan âŸ¶ Clan</code>",
 "1818": "<code>Clan</code>",
 "1817": "<code>CM.Ex12_3.mâ‚‚ : Clan âŸ¶ Clan</code>",
 "1816": "<code>CM.Ex12_3.Clan.bear : Clan</code>",
 "1815": "<code>CM.Ex12_3.Clan.wolf : Clan</code>",
 "1814": "<code>CM.Ex12_3.Clan : Type</code>",
 "1813": "<code>âˆ€ {a : Gender}, a âˆˆ Set.univ â†’ mâ‚ a âˆˆ Set.univ</code>",
 "1812": "<code>Gender âŸ¶ Gender</code>",
 "1811": "<code>Set Gender</code>",
 "1810": "<code>CM.Ex12_3.G : SetWithTwoEndomaps</code>",
 "181": "<code>aâœ = \"eggs\" âˆ¨ aâœ âˆˆ {\"coffee\"}</code>",
 "1809": "<code>CM.Ex12_3.fâ‚ : Gender âŸ¶ Gender</code>",
 "1808": "<code>CM.Ex12_3.mâ‚ : Gender âŸ¶ Gender</code>",
 "1807": "<code>CM.Ex12_3.Gender.male : Gender</code>",
 "1806": "<code>CM.Ex12_3.Gender.female : Gender</code>",
 "1805": "<code>CM.Ex12_3.Gender : Type</code>",
 "1804": "<code>g âŠš Yâœ.toEnd2 = Zâœ.toEnd2 âŠš g</code>",
 "1803": "<code>g âŠš Yâœ.toEnd = Zâœ.toEnd âŠš g</code>",
 "1802": "<code>f âŠš Xâœ.toEnd2 = Yâœ.toEnd2 âŠš f</code>",
 "1801": "<code>f âŠš Xâœ.toEnd = Yâœ.toEnd âŠš f</code>",
 "1800":
 "<code>(âˆ€ x âˆˆ Yâœ.carrier, g x âˆˆ Zâœ.carrier) âˆ§ g âŠš Yâœ.toEnd = Zâœ.toEnd âŠš g âˆ§ g âŠš Yâœ.toEnd2 = Zâœ.toEnd2 âŠš g</code>",
 "180": "<code>aâœ âˆˆ {\"eggs\", \"coffee\"}</code>",
 "18": "<code>CM.ExI_1.C.câ‚… : C</code>",
 "1799":
 "<code>(âˆ€ x âˆˆ Xâœ.carrier, f x âˆˆ Yâœ.carrier) âˆ§ f âŠš Xâœ.toEnd = Yâœ.toEnd âŠš f âˆ§ f âŠš Xâœ.toEnd2 = Yâœ.toEnd2 âŠš f</code>",
 "1798":
 "<code>{X Y Z : SetWithTwoEndomaps} â†’\n  { f // (âˆ€ x âˆˆ X.carrier, f x âˆˆ Y.carrier) âˆ§ f âŠš X.toEnd = Y.toEnd âŠš f âˆ§ f âŠš X.toEnd2 = Y.toEnd2 âŠš f } â†’\n    { f // (âˆ€ x âˆˆ Y.carrier, f x âˆˆ Z.carrier) âˆ§ f âŠš Y.toEnd = Z.toEnd âŠš f âˆ§ f âŠš Y.toEnd2 = Z.toEnd2 âŠš f } â†’\n      { f // (âˆ€ x âˆˆ X.carrier, f x âˆˆ Z.carrier) âˆ§ f âŠš X.toEnd = Z.toEnd âŠš f âˆ§ f âŠš X.toEnd2 = Z.toEnd2 âŠš f }</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "1797":
 "<code>(X : SetWithTwoEndomaps) â†’\n  { f // (âˆ€ x âˆˆ X.carrier, f x âˆˆ X.carrier) âˆ§ f âŠš X.toEnd = X.toEnd âŠš f âˆ§ f âŠš X.toEnd2 = X.toEnd2 âŠš f }</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "1796": "<code>SetWithTwoEndomaps</code>",
 "1795":
 "<code>SetWithTwoEndomaps â†’ SetWithTwoEndomaps â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "1794":
 "<code>CM.instCatSetWithTwoEndomaps : Category.{0, 1} SetWithTwoEndomaps</code>",
 "1793":
 "<code>CM.SetWithTwoEndomaps.toEnd2_mem (self : SetWithTwoEndomaps) {a : self.t} :\n  a âˆˆ self.carrier â†’ self.toEnd a âˆˆ self.carrier</code>",
 "1792":
 "<code>CM.SetWithTwoEndomaps.toEnd2 (self : SetWithTwoEndomaps) : self.t âŸ¶ self.t</code>",
 "1791": "<code>CM.SetWithTwoEndomaps : Type 1</code>",
 "1790":
 "<code>StateT.run.{u, v} {Ïƒ : Type u} {m : Type u â†’ Type v} {Î± : Type u} (x : StateT Ïƒ m Î±) (s : Ïƒ) : m (Î± Ã— Ïƒ)</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value paired with the final state.\n</code>",
 "179": "<code>aâœ âˆˆ B</code>",
 "1789": "<code>CM.Ex12_2.getResult : BulbState Ã— LitCount</code>",
 "1788":
 "<code>List.foldlM.{u, v, w} {m : Type u â†’ Type v} [_root_.Monad m] {s : Type u} {Î± : Type w} (f : s â†’ Î± â†’ m s) (init : s) :\n  List Î± â†’ m s</code><span class=\"sep\"></span><code class=\"docstring\">Folds a monadic function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nExample:\n```lean example\nexample [Monad m] (f : Î± â†’ Î² â†’ m Î±) :\n    List.foldlM (m := m) f xâ‚€ [a, b, c] = (do\n      let xâ‚ â† f xâ‚€ a\n      let xâ‚‚ â† f xâ‚ b\n      let xâ‚ƒ â† f xâ‚‚ c\n      pure xâ‚ƒ)\n  := by rfl\n```\n</code>",
 "1787":
 "<code>CM.Ex12_2.simulateEightPresses : StateM LitCount BulbState</code>",
 "1786":
 "<code>List.replicate.{u} {Î± : Type u} (n : â„•) (a : Î±) : List Î±</code><span class=\"sep\"></span><code class=\"docstring\">Creates a list that contains `n` copies of `a`.\n\n* `List.replicate 5 \"five\" = [\"five\", \"five\", \"five\", \"five\", \"five\"]`\n* `List.replicate 0 \"zero\" = []`\n* `List.replicate 2 ' ' = [' ', ' ']`\n</code>",
 "1785": "<code>CM.Ex12_2.EightPresses : List Unit</code>",
 "1784":
 "<code class=\"docstring\">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,\nskipping any further statements.\nNote that uses of the `do` keyword in other syntax like in `for _ in _ do`\ndo not constitute a surrounding block in this sense;\nin supported editors, the corresponding `do` keyword of the surrounding block\nis highlighted when hovering over `return`.\n\n`return` not followed by a term starting on the same line is equivalent to `return ()`.\n</code>",
 "1783": "<code>LitCount</code>",
 "1782":
 "<code>modify.{u, v} {Ïƒ : Type u} {m : Type u â†’ Type v} [MonadState Ïƒ m] (f : Ïƒ â†’ Ïƒ) : m PUnit.{u + 1}</code><span class=\"sep\"></span><code class=\"docstring\">Mutates the current state, replacing its value with the result of applying `f` to it.\n\nUse `modifyThe` to explicitly select a state type to modify.\n\nIt is equivalent to `do set (f (â† get))`. However, using `modify` may lead to higher performance\nbecause it doesn't add a new reference to the state value. Additional references can inhibit\nin-place updates of data.\n</code>",
 "1781":
 "<code>StateM.{u} (Ïƒ Î± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A tuple-based state monad.\n\nActions in `StateM Ïƒ` are functions that take an initial state and return a value paired with a\nfinal state.\n</code>",
 "1780": "<code>BulbState</code>",
 "178":
 "<code>âˆ€ a âˆˆ B,\n  (match a with\n    | \"eggs\" =&gt; \"John\"\n    | x =&gt; \"Mary\") âˆˆ\n    A</code>",
 "1779":
 "<code>CM.Ex12_2.pressAndCount (this : BulbState) : StateM LitCount BulbState</code>",
 "1778":
 "<code>List.{u} (Î± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List Î±` is isomorphic to `Array Î±`, but they are useful for different things:\n* `List Î±` is easier for reasoning, and `Array Î±` is modeled as a wrapper around `List Î±`.\n* `List Î±` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array Î±` will have better performance because it can do destructive\n  updates.\n</code>",
 "1777": "<code>CM.Ex12_2.LitStates : List BulbState</code>",
 "1776": "<code>CM.Ex12_2.LitCount : Type</code>",
 "1775": "<code>CM.Ex12_2.pressButton : BulbState âŸ¶ BulbState</code>",
 "1774": "<code>CM.Ex12_2.BulbState.burntOut : BulbState</code>",
 "1773": "<code>CM.Ex12_2.BulbState.onâ‚„ : BulbState</code>",
 "1772": "<code>CM.Ex12_2.BulbState.offâ‚ƒ : BulbState</code>",
 "1771": "<code>CM.Ex12_2.BulbState.onâ‚ƒ : BulbState</code>",
 "1770": "<code>CM.Ex12_2.BulbState.offâ‚‚ : BulbState</code>",
 "177": "<code>CM.ExI_9.h : Map B A</code>",
 "1769": "<code>CM.Ex12_2.BulbState.onâ‚‚ : BulbState</code>",
 "1768": "<code>CM.Ex12_2.BulbState.offâ‚ : BulbState</code>",
 "1767": "<code>CM.Ex12_2.BulbState.onâ‚ : BulbState</code>",
 "1766": "<code>CM.Ex12_2.BulbState.offâ‚€ : BulbState</code>",
 "1765": "<code>CM.Ex12_2.BulbState : Type</code>",
 "1764": "<code>â†‘f âŠš XÎ±.toEnd = YÎ².toEnd âŠš â†‘f</code>",
 "1763": "<code>y' = (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) y</code>",
 "1762": "<code>y = â†‘f x</code>",
 "1761": "<code>x' = (XÎ±.toEnd âŠš XÎ±.toEnd âŠš XÎ±.toEnd) x</code>",
 "1760": "<code>e âˆˆ G.carrierD</code>",
 "176":
 "<code class=\"docstring\">`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : Â¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x â‰  x) : p := by contradiction\n  ```\n</code>",
 "1759": "<code>b âˆˆ G.carrierD</code>",
 "1758": "<code>G.tD</code>",
 "1757":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; 0\n      | A.aâ‚‚ =&gt; 0\n      | A.aâ‚ƒ =&gt; 1) âˆˆ\n      Set.univ</code>",
 "1756":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; 0\n      | A.aâ‚‚ =&gt; 1\n      | A.aâ‚ƒ =&gt; 1) âˆˆ\n      Set.univ</code>",
 "1755": "<code>CM.Ex11_8.J : IrreflexiveGraph</code>",
 "1754": "<code>CM.Ex11_8.D : Type</code>",
 "1753": "<code>CM.Ex11_8.A.aâ‚ƒ : A</code>",
 "1752": "<code>CM.Ex11_8.A.aâ‚‚ : A</code>",
 "1751": "<code>CM.Ex11_8.A.aâ‚ : A</code>",
 "1750": "<code>CM.Ex11_8.A : Type</code>",
 "175": "<code>3 â‰¤ 2</code>",
 "1749":
 "<code>((â†‘f).1 âŠš (â†‘finv).1, (â†‘f).2 âŠš (â†‘finv).2) = (ğŸ™ graph_R.tA, ğŸ™ graph_R.tD)</code>",
 "1748":
 "<code>(â†‘f).1 âŠš (â†‘finv).1 = ğŸ™ graph_R.tA âˆ§ (â†‘f).2 âŠš (â†‘finv).2 = ğŸ™ graph_R.tD</code>",
 "1747":
 "<code>f âŠš finv = ğŸ™ graph_R</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "1746":
 "<code>((â†‘finv).1 âŠš (â†‘f).1, (â†‘finv).2 âŠš (â†‘f).2) = (ğŸ™ graph_L.tA, ğŸ™ graph_L.tD)</code>",
 "1745":
 "<code>(â†‘finv).1 âŠš (â†‘f).1 = ğŸ™ graph_L.tA âˆ§ (â†‘finv).2 âŠš (â†‘f).2 = ğŸ™ graph_L.tD</code>",
 "1744":
 "<code>finv âŠš f = ğŸ™ graph_L</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "1743":
 "<code>graph_R âŸ¶ graph_L</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "1742":
 "<code>graph_L âŸ¶ graph_R</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "1741": "<code>graph_R.tD</code>",
 "1740": "<code>graph_R.tA</code>",
 "174":
 "<code>CM.ExI_8.idA : CM.CM_Finset.Map CM.CM_Finset.A CM.CM_Finset.A</code>",
 "1739":
 "<code>(âˆ€ x âˆˆ graph_R.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚†\n            | A.aâ‚‚ =&gt; A.aâ‚…\n            | A.aâ‚ƒ =&gt; A.aâ‚\n            | A.aâ‚„ =&gt; A.aâ‚‚\n            | A.aâ‚… =&gt; A.aâ‚ƒ\n            | A.aâ‚† =&gt; A.aâ‚„,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚ƒ\n            | D.dâ‚‚ =&gt; D.dâ‚…\n            | D.dâ‚ƒ =&gt; D.dâ‚\n            | D.dâ‚„ =&gt; D.dâ‚‚\n            | D.dâ‚… =&gt; D.dâ‚„).1\n        x âˆˆ\n      graph_L.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_R.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚†\n              | A.aâ‚‚ =&gt; A.aâ‚…\n              | A.aâ‚ƒ =&gt; A.aâ‚\n              | A.aâ‚„ =&gt; A.aâ‚‚\n              | A.aâ‚… =&gt; A.aâ‚ƒ\n              | A.aâ‚† =&gt; A.aâ‚„,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚…\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚‚\n              | D.dâ‚… =&gt; D.dâ‚„).2\n          x âˆˆ\n        graph_L.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚†\n              | A.aâ‚‚ =&gt; A.aâ‚…\n              | A.aâ‚ƒ =&gt; A.aâ‚\n              | A.aâ‚„ =&gt; A.aâ‚‚\n              | A.aâ‚… =&gt; A.aâ‚ƒ\n              | A.aâ‚† =&gt; A.aâ‚„,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚…\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚‚\n              | D.dâ‚… =&gt; D.dâ‚„).2 âŠš\n          graph_R.toSrc =\n        graph_L.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚†\n              | A.aâ‚‚ =&gt; A.aâ‚…\n              | A.aâ‚ƒ =&gt; A.aâ‚\n              | A.aâ‚„ =&gt; A.aâ‚‚\n              | A.aâ‚… =&gt; A.aâ‚ƒ\n              | A.aâ‚† =&gt; A.aâ‚„,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚…\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚‚\n              | D.dâ‚… =&gt; D.dâ‚„).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚†\n              | A.aâ‚‚ =&gt; A.aâ‚…\n              | A.aâ‚ƒ =&gt; A.aâ‚\n              | A.aâ‚„ =&gt; A.aâ‚‚\n              | A.aâ‚… =&gt; A.aâ‚ƒ\n              | A.aâ‚† =&gt; A.aâ‚„,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚…\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚‚\n              | D.dâ‚… =&gt; D.dâ‚„).2 âŠš\n          graph_R.toTgt =\n        graph_L.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚†\n              | A.aâ‚‚ =&gt; A.aâ‚…\n              | A.aâ‚ƒ =&gt; A.aâ‚\n              | A.aâ‚„ =&gt; A.aâ‚‚\n              | A.aâ‚… =&gt; A.aâ‚ƒ\n              | A.aâ‚† =&gt; A.aâ‚„,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚…\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚‚\n              | D.dâ‚… =&gt; D.dâ‚„).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1738":
 "<code>(graph_R.tA âŸ¶ graph_L.tA) Ã— (graph_R.tD âŸ¶ graph_L.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1737": "<code>CM.Ex11_7.finv : graph_R âŸ¶ graph_L</code>",
 "1736": "<code>graph_L.tD</code>",
 "1735": "<code>graph_L.tA</code>",
 "1734":
 "<code>(âˆ€ x âˆˆ graph_L.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚ƒ\n            | A.aâ‚‚ =&gt; A.aâ‚„\n            | A.aâ‚ƒ =&gt; A.aâ‚…\n            | A.aâ‚„ =&gt; A.aâ‚†\n            | A.aâ‚… =&gt; A.aâ‚‚\n            | A.aâ‚† =&gt; A.aâ‚,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚ƒ\n            | D.dâ‚‚ =&gt; D.dâ‚„\n            | D.dâ‚ƒ =&gt; D.dâ‚\n            | D.dâ‚„ =&gt; D.dâ‚…\n            | D.dâ‚… =&gt; D.dâ‚‚).1\n        x âˆˆ\n      graph_R.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_L.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚„\n              | A.aâ‚ƒ =&gt; A.aâ‚…\n              | A.aâ‚„ =&gt; A.aâ‚†\n              | A.aâ‚… =&gt; A.aâ‚‚\n              | A.aâ‚† =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚„\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚…\n              | D.dâ‚… =&gt; D.dâ‚‚).2\n          x âˆˆ\n        graph_R.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚„\n              | A.aâ‚ƒ =&gt; A.aâ‚…\n              | A.aâ‚„ =&gt; A.aâ‚†\n              | A.aâ‚… =&gt; A.aâ‚‚\n              | A.aâ‚† =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚„\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚…\n              | D.dâ‚… =&gt; D.dâ‚‚).2 âŠš\n          graph_L.toSrc =\n        graph_R.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚„\n              | A.aâ‚ƒ =&gt; A.aâ‚…\n              | A.aâ‚„ =&gt; A.aâ‚†\n              | A.aâ‚… =&gt; A.aâ‚‚\n              | A.aâ‚† =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚„\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚…\n              | D.dâ‚… =&gt; D.dâ‚‚).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚„\n              | A.aâ‚ƒ =&gt; A.aâ‚…\n              | A.aâ‚„ =&gt; A.aâ‚†\n              | A.aâ‚… =&gt; A.aâ‚‚\n              | A.aâ‚† =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚„\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚…\n              | D.dâ‚… =&gt; D.dâ‚‚).2 âŠš\n          graph_L.toTgt =\n        graph_R.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚„\n              | A.aâ‚ƒ =&gt; A.aâ‚…\n              | A.aâ‚„ =&gt; A.aâ‚†\n              | A.aâ‚… =&gt; A.aâ‚‚\n              | A.aâ‚† =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚„\n              | D.dâ‚ƒ =&gt; D.dâ‚\n              | D.dâ‚„ =&gt; D.dâ‚…\n              | D.dâ‚… =&gt; D.dâ‚‚).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1733":
 "<code>(graph_L.tA âŸ¶ graph_R.tA) Ã— (graph_L.tD âŸ¶ graph_R.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1732": "<code>CM.Ex11_7.f : graph_L âŸ¶ graph_R</code>",
 "1731":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚\n      | A.aâ‚‚ =&gt; D.dâ‚‚\n      | A.aâ‚ƒ =&gt; D.dâ‚„\n      | A.aâ‚„ =&gt; D.dâ‚\n      | A.aâ‚… =&gt; D.dâ‚…\n      | A.aâ‚† =&gt; D.dâ‚ƒ) âˆˆ\n      Set.univ</code>",
 "1730":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚‚\n      | A.aâ‚‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚ƒ =&gt; D.dâ‚ƒ\n      | A.aâ‚„ =&gt; D.dâ‚„\n      | A.aâ‚… =&gt; D.dâ‚\n      | A.aâ‚† =&gt; D.dâ‚…) âˆˆ\n      Set.univ</code>",
 "173": "<code>#(image idA.toFun A) = 3</code>",
 "1729": "<code>CM.Ex11_7.graph_R : IrreflexiveGraph</code>",
 "1728":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚‚\n      | A.aâ‚‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚ƒ =&gt; D.dâ‚„\n      | A.aâ‚„ =&gt; D.dâ‚\n      | A.aâ‚… =&gt; D.dâ‚…\n      | A.aâ‚† =&gt; D.dâ‚ƒ) âˆˆ\n      Set.univ</code>",
 "1727":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚\n      | A.aâ‚‚ =&gt; D.dâ‚‚\n      | A.aâ‚ƒ =&gt; D.dâ‚ƒ\n      | A.aâ‚„ =&gt; D.dâ‚„\n      | A.aâ‚… =&gt; D.dâ‚\n      | A.aâ‚† =&gt; D.dâ‚…) âˆˆ\n      Set.univ</code>",
 "1726": "<code>CM.Ex11_7.graph_L : IrreflexiveGraph</code>",
 "1725": "<code>CM.Ex11_7.D.dâ‚… : D</code>",
 "1724": "<code>CM.Ex11_7.D.dâ‚„ : D</code>",
 "1723": "<code>CM.Ex11_7.D.dâ‚ƒ : D</code>",
 "1722": "<code>CM.Ex11_7.D.dâ‚‚ : D</code>",
 "1721": "<code>CM.Ex11_7.D.dâ‚ : D</code>",
 "1720": "<code>CM.Ex11_7.D : Type</code>",
 "172": "<code>f.toFun a = aâœ</code>",
 "1719": "<code>CM.Ex11_7.A.aâ‚† : A</code>",
 "1718": "<code>CM.Ex11_7.A.aâ‚… : A</code>",
 "1717": "<code>CM.Ex11_7.A.aâ‚„ : A</code>",
 "1716": "<code>CM.Ex11_7.A.aâ‚ƒ : A</code>",
 "1715": "<code>CM.Ex11_7.A.aâ‚‚ : A</code>",
 "1714": "<code>CM.Ex11_7.A.aâ‚ : A</code>",
 "1713": "<code>CM.Ex11_7.A : Type</code>",
 "1712":
 "<code>((â†‘fâ‚ƒ).1 âŠš (â†‘finvâ‚ƒ).1, (â†‘fâ‚ƒ).2 âŠš (â†‘finvâ‚ƒ).2) = (ğŸ™ graph_f.tA, ğŸ™ graph_f.tD)</code>",
 "1711":
 "<code>(â†‘fâ‚ƒ).1 âŠš (â†‘finvâ‚ƒ).1 = ğŸ™ graph_f.tA âˆ§ (â†‘fâ‚ƒ).2 âŠš (â†‘finvâ‚ƒ).2 = ğŸ™ graph_f.tD</code>",
 "1710":
 "<code>fâ‚ƒ âŠš finvâ‚ƒ = ğŸ™ graph_f</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "171": "<code>a âˆˆ A</code>",
 "1709":
 "<code>((â†‘finvâ‚ƒ).1 âŠš (â†‘fâ‚ƒ).1, (â†‘finvâ‚ƒ).2 âŠš (â†‘fâ‚ƒ).2) = (ğŸ™ graph_c.tA, ğŸ™ graph_c.tD)</code>",
 "1708":
 "<code>(â†‘finvâ‚ƒ).1 âŠš (â†‘fâ‚ƒ).1 = ğŸ™ graph_c.tA âˆ§ (â†‘finvâ‚ƒ).2 âŠš (â†‘fâ‚ƒ).2 = ğŸ™ graph_c.tD</code>",
 "1707":
 "<code>finvâ‚ƒ âŠš fâ‚ƒ = ğŸ™ graph_c</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "1706":
 "<code>graph_f âŸ¶ graph_c</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "1705":
 "<code>graph_c âŸ¶ graph_f</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "1704": "<code>graph_f.tD</code>",
 "1703": "<code>graph_f.tA</code>",
 "1702":
 "<code>(âˆ€ x âˆˆ graph_f.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚‚\n            | A.aâ‚‚ =&gt; A.aâ‚\n            | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚\n            | D.dâ‚‚ =&gt; D.dâ‚‚\n            | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1\n        x âˆˆ\n      graph_c.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_f.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2\n          x âˆˆ\n        graph_c.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_f.toSrc =\n        graph_c.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_f.toTgt =\n        graph_c.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1701":
 "<code>(graph_f.tA âŸ¶ graph_c.tA) Ã— (graph_f.tD âŸ¶ graph_c.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1700": "<code>CM.Ex11_6.finvâ‚ƒ : graph_f âŸ¶ graph_c</code>",
 "170":
 "<code class=\"docstring\">The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain âŸ¨pattâŸ© : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with âŸ¨pattâŸ©\n```\n\nIf `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n</code>",
 "17": "<code>CM.ExI_1.C.câ‚„ : C</code>",
 "1699": "<code>graph_c.tD</code>",
 "1698": "<code>graph_c.tA</code>",
 "1697":
 "<code>(âˆ€ x âˆˆ graph_c.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚‚\n            | A.aâ‚‚ =&gt; A.aâ‚\n            | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚\n            | D.dâ‚‚ =&gt; D.dâ‚‚\n            | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1\n        x âˆˆ\n      graph_f.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_c.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2\n          x âˆˆ\n        graph_f.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_c.toSrc =\n        graph_f.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_c.toTgt =\n        graph_f.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚‚\n              | A.aâ‚‚ =&gt; A.aâ‚\n              | A.aâ‚ƒ =&gt; A.aâ‚ƒ,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1696":
 "<code>(graph_c.tA âŸ¶ graph_f.tA) Ã— (graph_c.tD âŸ¶ graph_f.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1695": "<code>CM.Ex11_6.fâ‚ƒ : graph_c âŸ¶ graph_f</code>",
 "1694":
 "<code>((â†‘fâ‚‚).1 âŠš (â†‘finvâ‚‚).1, (â†‘fâ‚‚).2 âŠš (â†‘finvâ‚‚).2) = (ğŸ™ graph_e.tA, ğŸ™ graph_e.tD)</code>",
 "1693":
 "<code>(â†‘fâ‚‚).1 âŠš (â†‘finvâ‚‚).1 = ğŸ™ graph_e.tA âˆ§ (â†‘fâ‚‚).2 âŠš (â†‘finvâ‚‚).2 = ğŸ™ graph_e.tD</code>",
 "1692":
 "<code>fâ‚‚ âŠš finvâ‚‚ = ğŸ™ graph_e</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "1691":
 "<code>((â†‘finvâ‚‚).1 âŠš (â†‘fâ‚‚).1, (â†‘finvâ‚‚).2 âŠš (â†‘fâ‚‚).2) = (ğŸ™ graph_b.tA, ğŸ™ graph_b.tD)</code>",
 "1690":
 "<code>(â†‘finvâ‚‚).1 âŠš (â†‘fâ‚‚).1 = ğŸ™ graph_b.tA âˆ§ (â†‘finvâ‚‚).2 âŠš (â†‘fâ‚‚).2 = ğŸ™ graph_b.tD</code>",
 "169": "<code>âˆƒ a âˆˆ A, f.toFun a = aâœ</code>",
 "1689":
 "<code>finvâ‚‚ âŠš fâ‚‚ = ğŸ™ graph_b</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "1688":
 "<code>graph_e âŸ¶ graph_b</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "1687":
 "<code>graph_b âŸ¶ graph_e</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "1686": "<code>graph_e.tD</code>",
 "1685": "<code>graph_e.tA</code>",
 "1684":
 "<code>(âˆ€ x âˆˆ graph_e.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚ƒ\n            | A.aâ‚‚ =&gt; A.aâ‚‚\n            | A.aâ‚ƒ =&gt; A.aâ‚,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚‚\n            | D.dâ‚‚ =&gt; D.dâ‚ƒ\n            | D.dâ‚ƒ =&gt; D.dâ‚).1\n        x âˆˆ\n      graph_b.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_e.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚‚\n              | D.dâ‚‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚ƒ =&gt; D.dâ‚).2\n          x âˆˆ\n        graph_b.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚‚\n              | D.dâ‚‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚ƒ =&gt; D.dâ‚).2 âŠš\n          graph_e.toSrc =\n        graph_b.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚‚\n              | D.dâ‚‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚ƒ =&gt; D.dâ‚).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚‚\n              | D.dâ‚‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚ƒ =&gt; D.dâ‚).2 âŠš\n          graph_e.toTgt =\n        graph_b.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚‚\n              | D.dâ‚‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚ƒ =&gt; D.dâ‚).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1683":
 "<code>(graph_e.tA âŸ¶ graph_b.tA) Ã— (graph_e.tD âŸ¶ graph_b.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1682": "<code>CM.Ex11_6.finvâ‚‚ : graph_e âŸ¶ graph_b</code>",
 "1681": "<code>graph_b.tD</code>",
 "1680": "<code>graph_b.tA</code>",
 "168":
 "<code>Finset.mem_image.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î²] {f : Î± â†’ Î²} {s : Finset Î±} {b : Î²} :\n  b âˆˆ image f s â†” âˆƒ a âˆˆ s, f a = b</code>",
 "1679":
 "<code>(âˆ€ x âˆˆ graph_b.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚ƒ\n            | A.aâ‚‚ =&gt; A.aâ‚‚\n            | A.aâ‚ƒ =&gt; A.aâ‚,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚ƒ\n            | D.dâ‚‚ =&gt; D.dâ‚\n            | D.dâ‚ƒ =&gt; D.dâ‚‚).1\n        x âˆˆ\n      graph_e.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_b.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚\n              | D.dâ‚ƒ =&gt; D.dâ‚‚).2\n          x âˆˆ\n        graph_e.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚\n              | D.dâ‚ƒ =&gt; D.dâ‚‚).2 âŠš\n          graph_b.toSrc =\n        graph_e.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚\n              | D.dâ‚ƒ =&gt; D.dâ‚‚).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚\n              | D.dâ‚ƒ =&gt; D.dâ‚‚).2 âŠš\n          graph_b.toTgt =\n        graph_e.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚ƒ\n              | D.dâ‚‚ =&gt; D.dâ‚\n              | D.dâ‚ƒ =&gt; D.dâ‚‚).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1678":
 "<code>(graph_b.tA âŸ¶ graph_e.tA) Ã— (graph_b.tD âŸ¶ graph_e.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1677": "<code>CM.Ex11_6.fâ‚‚ : graph_b âŸ¶ graph_e</code>",
 "1676":
 "<code>((â†‘fâ‚).1 âŠš (â†‘finvâ‚).1, (â†‘fâ‚).2 âŠš (â†‘finvâ‚).2) = (ğŸ™ graph_d.tA, ğŸ™ graph_d.tD)</code>",
 "1675":
 "<code>(â†‘fâ‚).1 âŠš (â†‘finvâ‚).1 = ğŸ™ graph_d.tA âˆ§ (â†‘fâ‚).2 âŠš (â†‘finvâ‚).2 = ğŸ™ graph_d.tD</code>",
 "1674":
 "<code>fâ‚ âŠš finvâ‚ = ğŸ™ graph_d</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. </code>",
 "1673":
 "<code>((â†‘finvâ‚).1 âŠš (â†‘fâ‚).1, (â†‘finvâ‚).2 âŠš (â†‘fâ‚).2) = (ğŸ™ graph_a.tA, ğŸ™ graph_a.tD)</code>",
 "1672":
 "<code>(â†‘finvâ‚).1 âŠš (â†‘fâ‚).1 = ğŸ™ graph_a.tA âˆ§ (â†‘finvâ‚).2 âŠš (â†‘fâ‚).2 = ğŸ™ graph_a.tD</code>",
 "1671":
 "<code>finvâ‚ âŠš fâ‚ = ğŸ™ graph_a</code><span class=\"sep\"></span><code class=\"docstring\">Composition of the two directions of an isomorphism is the identity on the source. </code>",
 "1670":
 "<code>graph_d âŸ¶ graph_a</code><span class=\"sep\"></span><code class=\"docstring\">The backwards direction of an isomorphism. </code>",
 "167": "<code>aâœ âˆˆ image f.toFun A</code>",
 "1669":
 "<code>graph_a âŸ¶ graph_d</code><span class=\"sep\"></span><code class=\"docstring\">The forward direction of an isomorphism. </code>",
 "1668": "<code>graph_d.tD</code>",
 "1667": "<code>graph_d.tA</code>",
 "1666":
 "<code>(âˆ€ x âˆˆ graph_d.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚ƒ\n            | A.aâ‚‚ =&gt; A.aâ‚‚\n            | A.aâ‚ƒ =&gt; A.aâ‚,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚\n            | D.dâ‚‚ =&gt; D.dâ‚‚\n            | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1\n        x âˆˆ\n      graph_a.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_d.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2\n          x âˆˆ\n        graph_a.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_d.toSrc =\n        graph_a.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_d.toTgt =\n        graph_a.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1665":
 "<code>(graph_d.tA âŸ¶ graph_a.tA) Ã— (graph_d.tD âŸ¶ graph_a.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1664": "<code>CM.Ex11_6.finvâ‚ : graph_d âŸ¶ graph_a</code>",
 "1663": "<code>graph_a.tD</code>",
 "1662": "<code>graph_a.tA</code>",
 "1661":
 "<code>(âˆ€ x âˆˆ graph_a.carrierA,\n    (fun x â†¦\n            match x with\n            | A.aâ‚ =&gt; A.aâ‚ƒ\n            | A.aâ‚‚ =&gt; A.aâ‚‚\n            | A.aâ‚ƒ =&gt; A.aâ‚,\n            fun x â†¦\n            match x with\n            | D.dâ‚ =&gt; D.dâ‚\n            | D.dâ‚‚ =&gt; D.dâ‚‚\n            | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1\n        x âˆˆ\n      graph_d.carrierA) âˆ§\n  (âˆ€ x âˆˆ graph_a.carrierD,\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2\n          x âˆˆ\n        graph_d.carrierD) âˆ§\n    (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_a.toSrc =\n        graph_d.toSrc âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1 âˆ§\n      (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).2 âŠš\n          graph_a.toTgt =\n        graph_d.toTgt âŠš\n          (fun x â†¦\n              match x with\n              | A.aâ‚ =&gt; A.aâ‚ƒ\n              | A.aâ‚‚ =&gt; A.aâ‚‚\n              | A.aâ‚ƒ =&gt; A.aâ‚,\n              fun x â†¦\n              match x with\n              | D.dâ‚ =&gt; D.dâ‚\n              | D.dâ‚‚ =&gt; D.dâ‚‚\n              | D.dâ‚ƒ =&gt; D.dâ‚ƒ).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1660":
 "<code>(graph_a.tA âŸ¶ graph_d.tA) Ã— (graph_a.tD âŸ¶ graph_d.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "166":
 "<code>HasSubset.Subset.{u} {Î± : Type u} [self : HasSubset Î±] : Î± â†’ Î± â†’ Prop</code><span class=\"sep\"></span><code class=\"docstring\">Subset relation: `a âŠ† b`  \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `âŠ†` in identifiers is `subset`.</code>",
 "1659": "<code>CM.Ex11_6.fâ‚ : graph_a âŸ¶ graph_d</code>",
 "1658":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚‚\n      | A.aâ‚‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚ƒ =&gt; D.dâ‚ƒ) âˆˆ\n      Set.univ</code>",
 "1657": "<code>CM.Ex11_6.graph_f : IrreflexiveGraph</code>",
 "1656":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚‚ =&gt; D.dâ‚‚\n      | A.aâ‚ƒ =&gt; D.dâ‚) âˆˆ\n      Set.univ</code>",
 "1655":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚\n      | A.aâ‚‚ =&gt; D.dâ‚\n      | A.aâ‚ƒ =&gt; D.dâ‚ƒ) âˆˆ\n      Set.univ</code>",
 "1654": "<code>CM.Ex11_6.graph_e : IrreflexiveGraph</code>",
 "1653":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚‚\n      | A.aâ‚‚ =&gt; D.dâ‚‚\n      | A.aâ‚ƒ =&gt; D.dâ‚ƒ) âˆˆ\n      Set.univ</code>",
 "1652":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚‚ =&gt; D.dâ‚\n      | A.aâ‚ƒ =&gt; D.dâ‚‚) âˆˆ\n      Set.univ</code>",
 "1651": "<code>CM.Ex11_6.graph_d : IrreflexiveGraph</code>",
 "1650":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚‚ =&gt; D.dâ‚‚\n      | A.aâ‚ƒ =&gt; D.dâ‚ƒ) âˆˆ\n      Set.univ</code>",
 "165":
 "<code>Finset.card_le_card.{u_1} {Î± : Type u_1} {s t : Finset Î±} : s âŠ† t â†’ #s â‰¤ #t</code>",
 "1649":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚\n      | A.aâ‚‚ =&gt; D.dâ‚\n      | A.aâ‚ƒ =&gt; D.dâ‚) âˆˆ\n      Set.univ</code>",
 "1648": "<code>CM.Ex11_6.graph_c : IrreflexiveGraph</code>",
 "1647":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚‚\n      | A.aâ‚‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚ƒ =&gt; D.dâ‚) âˆˆ\n      Set.univ</code>",
 "1646":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚\n      | A.aâ‚‚ =&gt; D.dâ‚‚\n      | A.aâ‚ƒ =&gt; D.dâ‚‚) âˆˆ\n      Set.univ</code>",
 "1645": "<code>CM.Ex11_6.graph_b : IrreflexiveGraph</code>",
 "1644":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚ƒ\n      | A.aâ‚‚ =&gt; D.dâ‚‚\n      | A.aâ‚ƒ =&gt; D.dâ‚‚) âˆˆ\n      Set.univ</code>",
 "1643":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; D.dâ‚‚\n      | A.aâ‚‚ =&gt; D.dâ‚\n      | A.aâ‚ƒ =&gt; D.dâ‚ƒ) âˆˆ\n      Set.univ</code>",
 "1642": "<code>A â†’ D</code>",
 "1641": "<code>CM.Ex11_6.graph_a : IrreflexiveGraph</code>",
 "1640": "<code>CM.Ex11_6.D.dâ‚ƒ : D</code>",
 "164":
 "<code class=\"docstring\">* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n</code>",
 "1639": "<code>CM.Ex11_6.D.dâ‚‚ : D</code>",
 "1638": "<code>CM.Ex11_6.D.dâ‚ : D</code>",
 "1637": "<code>CM.Ex11_6.D : Type</code>",
 "1636": "<code>CM.Ex11_6.A.aâ‚ƒ : A</code>",
 "1635": "<code>CM.Ex11_6.A.aâ‚‚ : A</code>",
 "1634": "<code>CM.Ex11_6.A.aâ‚ : A</code>",
 "1633": "<code>CM.Ex11_6.A : Type</code>",
 "1632": "<code>{0, 1, 2}.ncard = 3</code>",
 "1631": "<code>{â†‘f 0 % 3, â†‘f 1 % 3}.ncard â‰¤ 1 + 1</code>",
 "1630":
 "<code>Set.ncard_singleton.{u_1} {Î± : Type u_1} (a : Î±) : {a}.ncard = 1</code>",
 "163":
 "<code>Finset.card_image_le.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} {s : Finset Î±} {f : Î± â†’ Î²} [DecidableEq Î²] :\n  #(image f s) â‰¤ #s</code>",
 "1629":
 "<code>Set.ncard_insert_le.{u_1} {Î± : Type u_1} (a : Î±) (s : Set Î±) : (insert a s).ncard â‰¤ s.ncard + 1</code>",
 "1628": "<code>{â†‘f 0 % 3, â†‘f 1 % 3}.ncard â‰¤ {â†‘f 1 % 3}.ncard + 1</code>",
 "1627":
 "<code>Set.ncard.{u_1} {Î± : Type u_1} (s : Set Î±) : â„•</code><span class=\"sep\"></span><code class=\"docstring\">The cardinality of `s : Set Î±` . Has the junk value `0` if `s` is infinite </code>",
 "1626": "<code>{â†‘f 0 % 3, â†‘f 1 % 3}.ncard â‰¤ 2</code>",
 "1625": "<code>â†‘f a = b</code>",
 "1624": "<code>b âˆˆ {2}</code>",
 "1623": "<code>b = 1</code>",
 "1622": "<code>b = 0</code>",
 "1621":
 "<code class=\"docstring\">`bound` tactic for proving inequalities via straightforward recursion on expression structure.\n\nAn example use case is\n\n```\n-- Calc example: A weak lower bound for `z â†¦ z^2 + c`\nlemma le_sqr_add (c z : â„) (cz : â€–câ€– â‰¤ â€–zâ€–) (z3 : 3 â‰¤ â€–zâ€–) :\n    2 * â€–zâ€– â‰¤ â€–z^2 + câ€– := by\n  calc â€–z^2 + câ€–\n    _ â‰¥ â€–z^2â€– - â€–câ€– := by bound\n    _ â‰¥ â€–z^2â€– - â€–zâ€– := by  bound\n    _ â‰¥ (â€–zâ€– - 1) * â€–zâ€– := by\n      rw [mul_comm, mul_sub_one, â† pow_two, â† norm_pow]\n    _ â‰¥ 2 * â€–zâ€– := by bound\n```\n\n`bound` is built on top of `aesop`, and uses\n1. Apply lemmas registered via the `@[bound]` attribute\n2. Forward lemmas registered via the `@[bound_forward]` attribute\n3. Local hypotheses from the context\n4. Optionally: additional hypotheses provided as `bound [hâ‚€, hâ‚]` or similar. These are added to the\n   context as if by `have := háµ¢`.\n\nThe functionality of `bound` overlaps with `positivity` and `gcongr`, but can jump back and forth\nbetween `0 â‰¤ x` and `x â‰¤ y`-type inequalities.  For example, `bound` proves\n  `0 â‰¤ c â†’ b â‰¤ a â†’ 0 â‰¤ a * c - b * c`\nby turning the goal into `b * c â‰¤ a * c`, then using `mul_le_mul_of_nonneg_right`.  `bound` also\ncontains lemmas for goals of the form `1 â‰¤ x, 1 &lt; x, x â‰¤ 1, x &lt; 1`.  Conversely, `gcongr` can prove\ninequalities for more types of relations, supports all `positivity` functionality, and is likely\nfaster since it is more specialized (not built atop `aesop`). </code>",
 "1620": "<code>2 &lt; 3</code>",
 "162":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "1619": "<code>0 â‰¤ 2</code>",
 "1618": "<code>2 = b</code>",
 "1617": "<code>â†‘f a % 3 = 2</code>",
 "1616": "<code>1 &lt; 3</code>",
 "1615": "<code>0 â‰¤ 1</code>",
 "1614": "<code>1 = b</code>",
 "1613": "<code>â†‘f a % 3 = 1</code>",
 "1612": "<code>0 &lt; 3</code>",
 "1611": "<code>0 â‰¤ 0</code>",
 "1610": "<code>0 = b</code>",
 "161":
 "<code>LE.le.{u} {Î± : Type u} [self : LE Î±] : Î± â†’ Î± â†’ Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x â‰¤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `â‰¤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `â‰¤` over `&lt;=`).</code>",
 "1609": "<code>â†‘f a % 3 = 0</code>",
 "1608":
 "<code class=\"docstring\">`interval_cases n` searches for upper and lower bounds on a variable `n`,\nand if bounds are found,\nsplits into separate cases for each possible value of `n`.\n\nAs an example, in\n```\nexample (n : â„•) (wâ‚ : n â‰¥ 3) (wâ‚‚ : n &lt; 5) : n = 3 âˆ¨ n = 4 := by\n  interval_cases n\n  all_goals simp\n```\nafter `interval_cases n`, the goals are `3 = 3 âˆ¨ 3 = 4` and `4 = 3 âˆ¨ 4 = 4`.\n\nYou can also explicitly specify a lower and upper bound to use,\nas `interval_cases using hl, hu`.\nThe hypotheses should be in the form `hl : a â‰¤ n` and `hu : n &lt; b`,\nin which case `interval_cases` calls `fin_cases` on the resulting fact `n âˆˆ Set.Ico a b`.\n\nYou can specify a name `h` for the new hypothesis,\nas `interval_cases h : n` or `interval_cases h : n using hl, hu`.\n</code>",
 "1607":
 "<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>",
 "1606":
 "<code>Int.emod_lt_of_pos (a : â„¤) {b : â„¤} (H : 0 &lt; b) : a % b &lt; b</code>",
 "1605": "<code>â†‘f a % 3 &lt; 3</code>",
 "1604":
 "<code class=\"docstring\">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nThe target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,\nor you can use the `+revert` option, described below.\n\nOptions:\n- `decide +revert` begins by reverting local variables that the target depends on,\n  after cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,\n  or if it is a proposition that refers to a relevant variable.\n- `decide +kernel` uses kernel for reduction instead of the elaborator.\n  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\n  and (2) it reduces the `Decidable` instance only once instead of twice.\n- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,\n  admitting the result via the `Lean.ofReduceBool` axiom.\n  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size\n  of the trusted code base.\n  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.\n  Like with `+kernel`, the `Decidable` instance is evaluated only once.\n\nLimitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,\n`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on `Decidable` instances with `Eq.rec` terms.\nThese can appear in instances defined using tactics (such as `rw` and `simp`).\nTo avoid this, create such instances using definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 â‰  5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 â‰  1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 â‰  1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice â‹¯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n</code>",
 "1603": "<code>b âˆˆ {â†‘_fvar.97 1 % 3}</code>",
 "1602": "<code>b = â†‘_fvar.97 0 % 3</code>",
 "1601": "<code>b âˆˆ {â†‘_fvar.97 0 % 3, â†‘_fvar.97 1 % 3}</code>",
 "1600":
 "<code>b âˆˆ {â†‘_fvar.97 0 % 3, â†‘_fvar.97 1 % 3} â†’ b âˆˆ Set.range fun x â†¦ â†‘_fvar.97 x % 3</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. </code>",
 "160":
 "<code>le_trans.{u_1} {Î± : Type u_1} [Preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c</code><span class=\"sep\"></span><code class=\"docstring\">The relation `â‰¤` on a preorder is transitive. </code>",
 "16": "<code>CM.ExI_1.C.câ‚ƒ : C</code>",
 "1599": "<code>Prop</code>",
 "1598": "<code>(fun x â†¦ â†‘_fvar.97 x % 3) a = b</code>",
 "1597": "<code>b âˆˆ Set.range fun x â†¦ â†‘_fvar.97 x % 3</code>",
 "1596":
 "<code>(b âˆˆ Set.range fun x â†¦ â†‘_fvar.97 x % 3) â†’ b âˆˆ {â†‘_fvar.97 0 % 3, â†‘_fvar.97 1 % 3}</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. </code>",
 "1595": "<code>â†‘_fvar.97 (2 * -â†‘x' + 1) % 3 = â†‘_fvar.97 1 % 3</code>",
 "1594": "<code>â†‘_fvar.97 (2 * â†‘x' + 1) % 3 = â†‘_fvar.97 1 % 3</code>",
 "1593": "<code>â†‘_fvar.97 (2 * -â†‘x') % 3 = â†‘_fvar.97 0 % 3</code>",
 "1592": "<code>â†‘_fvar.97 (2 * â†‘x') % 3 = â†‘_fvar.97 0 % 3</code>",
 "1591": "<code>Â¬(â†‘_fvar.97 x + 3) % 3 = â†‘_fvar.97 x % 3</code>",
 "1590": "<code>CM.Ex11_5.â„¤Î².t</code>",
 "159":
 "<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>",
 "1589": "<code>Int.emod_nonneg (a : â„¤) {b : â„¤} : b â‰  0 â†’ 0 â‰¤ a % b</code>",
 "1588": "<code>0 â‰¤ â†‘f a % 3</code>",
 "1587": "<code>(Set.range fun x â†¦ â†‘f x % 3) = {0, 1, 2}</code>",
 "1586":
 "<code>And.right {a b : Prop} (self : a âˆ§ b) : b</code><span class=\"sep\"></span><code class=\"docstring\">Extract the right conjunct from a conjunction. `h : a âˆ§ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. </code>",
 "1585": "<code>Function.Surjective â†‘f</code>",
 "1584": "<code>CM.Ex11_5.â„¤Î±.t</code>",
 "1583":
 "<code>CategoryTheory.ConcreteCategory.bijective_of_isIso.{w, v, u, u_1} {C : Type u} [Category.{v, u} C]\n  {FC : C â†’ C â†’ Type u_1} {CC : C â†’ Type w} [(X Y : C) â†’ FunLike (FC X Y) (CC X) (CC Y)] [ConcreteCategory C FC]\n  {X Y : C} (f : X âŸ¶ Y) [IsIso f] : Function.Bijective â‡‘(ConcreteCategory.hom f)</code>",
 "1582":
 "<code>Function.Bijective.{uâ‚, uâ‚‚} {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function is called bijective if it is both injective and surjective. </code>",
 "1581": "<code>Function.Bijective â†‘f</code>",
 "1580": "<code>b âˆˆ {â†‘f 1 % 3}</code>",
 "158": "<code>#(image g.toFun (image f.toFun A)) â‰¤ 2</code>",
 "1579": "<code>b = â†‘f 0 % 3</code>",
 "1578": "<code>b âˆˆ {â†‘f 0 % 3, â†‘f 1 % 3}</code>",
 "1577": "<code>a = 2 * a' + 1</code>",
 "1576":
 "<code class=\"docstring\">Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p âˆ¨ q := by\n  right\n  exact h\n```\n</code>",
 "1575":
 "<code>two_mul.{u} {Î± : Type u} [NonAssocSemiring Î±] (n : Î±) : 2 * n = n + n</code>",
 "1574": "<code>a = a' + a'</code>",
 "1573":
 "<code class=\"docstring\">Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True âˆ¨ False := by\n  left\n  trivial\n```\n</code>",
 "1572":
 "<code>Odd.{u_2} {Î± : Type u_2} [Semiring Î±] (a : Î±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. </code>",
 "1571":
 "<code>Even.{u_2} {Î± : Type u_2} [Add Î±] (a : Î±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An element `a` of a type `Î±` with addition satisfies `Even a` if `a = r + r`,\nfor some `r : Î±`. </code>",
 "1570": "<code>Odd a</code>",
 "157":
 "<code>Finset.image_image.{u_1, u_2, u_3} {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [DecidableEq Î²] {f : Î± â†’ Î²}\n  {s : Finset Î±} [DecidableEq Î³] {g : Î² â†’ Î³} : image g (image f s) = image (g âˆ˜ f) s</code>",
 "1569": "<code>Even a</code>",
 "1568": "<code>Int.even_or_odd (n : â„¤) : Even n âˆ¨ Odd n</code>",
 "1567": "<code>â†‘f a % 3 = b</code>",
 "1566": "<code>(fun x â†¦ â†‘f x % 3) a = b</code>",
 "1565":
 "<code>Set.range.{u, u_1} {Î± : Type u} {Î¹ : Sort u_1} (f : Î¹ â†’ Î±) : Set Î±</code><span class=\"sep\"></span><code class=\"docstring\">Range of a function.\n\nThis function is more flexible than `f '' univ`, as the image requires that the domain is in Type\nand not an arbitrary Sort. </code>",
 "1564": "<code>(Set.range fun x â†¦ â†‘f x % 3) = {â†‘f 0 % 3, â†‘f 1 % 3}</code>",
 "1563": "<code>2 * -â†‘x' - 2 * 1 + 1 + 2 = 2 * -â†‘x' + 1</code>",
 "1562": "<code>â†‘f (2 * -â†‘x' + 1) % 3 = â†‘f 1 % 3</code>",
 "1561":
 "<code>add_comm.{u_1} {G : Type u_1} [AddCommMagma G] (a b : G) : a + b = b + a</code>",
 "1560":
 "<code>add_assoc.{u_1} {G : Type u_1} [AddSemigroup G] (a b c : G) : a + b + c = a + (b + c)</code>",
 "156":
 "<code>Finset.card.{u_1} {Î± : Type u_1} (s : Finset Î±) : â„•</code><span class=\"sep\"></span><code class=\"docstring\">`s.card` is the number of elements of `s`, aka its cardinality.\n\nThe notation `#s` can be accessed in the `Finset` locale. </code>",
 "1559": "<code>â†‘f (2 * â†‘x' + 1) % 3 = â†‘f 1 % 3</code>",
 "1558": "<code>âˆ€ (x : â„¤), â†‘f (2 * x + 1) â‰¡ â†‘f 1 [ZMOD 3]</code>",
 "1557":
 "<code>sub_add_cancel.{u_1} {G : Type u_1} [AddGroup G] (a b : G) : a - b + b = a</code>",
 "1556":
 "<code>mul_sub.{u} {Î± : Type u} [NonUnitalNonAssocRing Î±] (a b c : Î±) : a * (b - c) = a * b - a * c</code><span class=\"sep\"></span><code class=\"docstring\">**Alias** of `mul_sub_left_distrib`.</code>",
 "1555": "<code>â†‘f (2 * -â†‘x') % 3 = â†‘f 0 % 3</code>",
 "1554":
 "<code>Int.pred (a : â„¤) : â„¤</code><span class=\"sep\"></span><code class=\"docstring\">Immediate predecessor of an integer: `pred n = n - 1` </code>",
 "1553":
 "<code>mul_add.{v} {R : Type v} [Mul R] [Add R] [LeftDistribClass R] (a b c : R) : a * (b + c) = a * b + a * c</code><span class=\"sep\"></span><code class=\"docstring\">**Alias** of `left_distrib`.</code>",
 "1552": "<code>â†‘f (2 * â†‘x') % 3 = â†‘f 0 % 3</code>",
 "1551":
 "<code>Int.succ (a : â„¤) : â„¤</code><span class=\"sep\"></span><code class=\"docstring\">Immediate successor of an integer: `succ n = n + 1` </code>",
 "1550": "<code>âˆ€ (x : â„¤), â†‘f (2 * x) â‰¡ â†‘f 0 [ZMOD 3]</code>",
 "155":
 "<code>Finset.image.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} [DecidableEq Î²] (f : Î± â†’ Î²) (s : Finset Î±) : Finset Î²</code><span class=\"sep\"></span><code class=\"docstring\">`image f s` is the forward image of `s` under `f`. </code>",
 "1549":
 "<code class=\"docstring\">The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`\nCurrently, all of these are on by default.\n</code>",
 "1548":
 "<code>HMod.hMod.{u, v, w} {Î± : Type u} {Î² : Type v} {Î³ : outParam (Type w)} [self : HMod Î± Î² Î³] : Î± â†’ Î² â†’ Î³</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `%` in identifiers is `mod`.</code>",
 "1547":
 "<code>Int.ModEq (n a b : â„¤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a â‰¡ b [ZMOD n]` when `a % n = b % n`. </code>",
 "1546": "<code>âˆ€ (x : â„¤), â†‘f (x + 2) â‰¡ â†‘f x [ZMOD 3]</code>",
 "1545": "<code>CM.Ex11_5.â„¤Î² : CM.SetWithEndomap</code>",
 "1544": "<code>CM.Ex11_5.â„¤Î± : CM.SetWithEndomap</code>",
 "1543": "<code>â„¤Î².t</code>",
 "1542": "<code>â„¤Î±.t</code>",
 "1541": "<code>âˆ€ (x : â„¤), â†‘f (x + 2) = â†‘f x + 3</code>",
 "1540": "<code>âˆ€ (x : â„¤), (â†‘f âˆ˜ â„¤Î±.toEnd) x = (â„¤Î².toEnd âˆ˜ â†‘f) x</code>",
 "154":
 "<code>#(image g.toFun (image f.toFun A)) = #(image idA.toFun A)</code>",
 "1539": "<code>â„¤Î± âŸ¶ â„¤Î²</code>",
 "1538": "<code>âˆ€ {a : â„¤}, a âˆˆ Set.univ â†’ Î² a âˆˆ Set.univ</code>",
 "1537": "<code>CM.Ex11_5.â„¤Î² : SetWithEndomap</code>",
 "1536": "<code>âˆ€ {a : â„¤}, a âˆˆ Set.univ â†’ Î± a âˆˆ Set.univ</code>",
 "1535": "<code>CM.Ex11_5.â„¤Î± : SetWithEndomap</code>",
 "1534": "<code>CM.Ex11_5.Î² : â„¤ â†’ â„¤</code>",
 "1533": "<code>CM.Ex11_5.Î± : â„¤ â†’ â„¤</code>",
 "1532": "<code>ğŸ™ AÎ±.t aâ‚ = ğŸ™ AÎ±.t aâ‚‚</code>",
 "1531": "<code>g (f aâ‚) = g (f aâ‚‚)</code>",
 "1530": "<code>f aâ‚ = f aâ‚‚</code>",
 "153":
 "<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the\n  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition's value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>",
 "1529":
 "<code class=\"docstring\">Apply a function to an equality or inequality in either a local hypothesis or the goal.\n\n* If we have `h : a = b`, then `apply_fun f at h` will replace this with `h : f a = f b`.\n* If we have `h : a â‰¤ b`, then `apply_fun f at h` will replace this with `h : f a â‰¤ f b`,\n  and create a subsidiary goal `Monotone f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using `mono`,\n  or an explicit solution can be provided with `apply_fun f at h using P`, where `P : Monotone f`.\n* If we have `h : a &lt; b`, then `apply_fun f at h` will replace this with `h : f a &lt; f b`,\n  and create a subsidiary goal `StrictMono f` and behaves as in the previous case.\n* If we have `h : a â‰  b`, then `apply_fun f at h` will replace this with `h : f a â‰  f b`,\n  and create a subsidiary goal `Injective f` and behaves as in the previous two cases.\n* If the goal is `a â‰  b`, `apply_fun f` will replace this with `f a â‰  f b`.\n* If the goal is `a = b`, `apply_fun f` will replace this with `f a = f b`,\n  and create a subsidiary goal `injective f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using local hypotheses,\n  or if `f` is actually an `Equiv`,\n  or an explicit solution can be provided with `apply_fun f using P`, where `P : Injective f`.\n* If the goal is `a â‰¤ b` (or similarly for `a &lt; b`), and `f` is actually an `OrderIso`,\n  `apply_fun f` will replace the goal with `f a â‰¤ f b`.\n  If `f` is anything else (e.g. just a function, or an `Equiv`), `apply_fun` will fail.\n\n\nTypical usage is:\n```lean\nopen Function\n\nexample (X Y Z : Type) (f : X â†’ Y) (g : Y â†’ Z) (H : Injective &lt;| g âˆ˜ f) :\n    Injective f := by\n  intro x x' h\n  apply_fun g at h\n  exact H h\n```\n\nThe function `f` is handled similarly to how it would be handled by `refine` in that `f` can contain\nplaceholders. Named placeholders (like `?a` or `?_`) will produce new goals.\n</code>",
 "1528": "<code>g âŠš â†‘âŸ¨f, â‹¯âŸ© = ğŸ™ AÎ±.t âˆ§ â†‘âŸ¨f, â‹¯âŸ© âŠš g = ğŸ™ BÎ².t</code>",
 "1527": "<code>AÎ±.t</code>",
 "1526": "<code>âˆ€ x âˆˆ AÎ±.carrier, f x âˆˆ BÎ².carrier</code>",
 "1525": "<code>f âŠš AÎ±.toEnd = BÎ².toEnd âŠš f</code>",
 "1524": "<code>AÎ±.t âŸ¶ BÎ².t</code>",
 "1523": "<code>BÎ² âŸ¶ AÎ±</code>",
 "1522": "<code>g âŠš â†‘f = ğŸ™ AÎ±.t âˆ§ â†‘f âŠš g = ğŸ™ BÎ².t</code>",
 "1521": "<code>BÎ².t</code>",
 "1520": "<code>âˆ€ b âˆˆ BÎ².carrier, g b âˆˆ AÎ±.carrier</code>",
 "152":
 "<code>False : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "1519": "<code>BÎ².t âŸ¶ AÎ±.t</code>",
 "1518": "<code>AÎ± âŸ¶ BÎ²</code>",
 "1517": "<code>(YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) (â†‘f X.xâ‚‚) â‰  â†‘f X.xâ‚‚</code>",
 "1516": "<code>(YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) (â†‘f X.xâ‚‚) = â†‘f X.xâ‚‚</code>",
 "1515": "<code>CM.Ex11_3.YÎ² : CM.SetWithEndomap</code>",
 "1514": "<code>CM.Ex11_3.Y</code>",
 "1513":
 "<code>â†‘f ((XÎ±.toEnd âŠš XÎ±.toEnd âŠš XÎ±.toEnd) X.xâ‚‚) = (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) (â†‘f X.xâ‚‚)</code>",
 "1512": "<code>(YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) Y.yâ‚„ = Y.yâ‚„</code>",
 "1511": "<code>(YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) Y.yâ‚ = Y.yâ‚</code>",
 "1510": "<code>CM.Ex11_3.X.xâ‚‚ : CM.Ex11_3.X</code>",
 "151": "<code>g.toFun âˆ˜ f.toFun = idA.toFun</code>",
 "1509": "<code>CM.Ex11_3.XÎ± : CM.SetWithEndomap</code>",
 "1508": "<code>âˆ€ (y : Y), (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) y â‰  y</code>",
 "1507": "<code>(XÎ±.toEnd âŠš XÎ±.toEnd âŠš XÎ±.toEnd) X.xâ‚‚ = X.xâ‚‚</code>",
 "1506": "<code>CM.Ex11_3.YÎ² : SetWithEndomap</code>",
 "1505": "<code>CM.Ex11_3.Î² : Y âŸ¶ Y</code>",
 "1504": "<code>CM.Ex11_3.Y.yâ‚„ : Y</code>",
 "1503": "<code>CM.Ex11_3.Y.yâ‚ƒ : Y</code>",
 "1502": "<code>CM.Ex11_3.Y.yâ‚‚ : Y</code>",
 "1501": "<code>CM.Ex11_3.Y.yâ‚ : Y</code>",
 "1500": "<code>CM.Ex11_3.Y : Type</code>",
 "150":
 "<code>Ne.{u} {Î± : Sort u} (a b : Î±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a â‰  b`, or `Ne a b` is defined as `Â¬ (a = b)` or `a = b â†’ False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `â‰ ` in identifiers is `ne`.</code>",
 "15": "<code>CM.ExI_1.C.câ‚‚ : C</code>",
 "1499": "<code>CM.Ex11_3.XÎ± : SetWithEndomap</code>",
 "1498": "<code>CM.Ex11_3.Î± : X âŸ¶ X</code>",
 "1497": "<code>CM.Ex11_3.X.xâ‚„ : X</code>",
 "1496": "<code>CM.Ex11_3.X.xâ‚ƒ : X</code>",
 "1495": "<code>CM.Ex11_3.X.xâ‚‚ : X</code>",
 "1494": "<code>CM.Ex11_3.X.xâ‚ : X</code>",
 "1493": "<code>CM.Ex11_3.X : Type</code>",
 "1492": "<code>CM.Ex11_2.fâ‚ƒ : CM.Ex11_2.X âŸ¶ CM.Ex11_2.Y</code>",
 "1491": "<code>CM.Ex11_2.fâ‚ƒ : X âŸ¶ Y</code>",
 "1490": "<code>CM.Ex11_2.fâ‚‚ : CM.Ex11_2.X âŸ¶ CM.Ex11_2.Y</code>",
 "149":
 "<code class=\"docstring\">Push negations into the conclusion or a hypothesis.\nFor instance, a hypothesis `h : Â¬ âˆ€ x, âˆƒ y, x â‰¤ y` will be transformed by `push_neg at h` into\n`h : âˆƒ x, âˆ€ y, y &lt; x`. Binder names are preserved.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`, so that it can preserve binder names, and so that `Â¬ (p âˆ§ q)` can be\ntransformed to either `p â†’ Â¬ q` (the default) or `Â¬ p âˆ¨ Â¬ q`. To get `Â¬ p âˆ¨ Â¬ q`, use\n`set_option push_neg.use_distrib true`.\n\nAnother example: given a hypothesis\n```lean\nh : Â¬ âˆ€ Îµ &gt; 0, âˆƒ Î´ &gt; 0, âˆ€ x, |x - xâ‚€| â‰¤ Î´ â†’ |f x - yâ‚€| â‰¤ Îµ\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : âˆƒ Îµ &gt; 0, âˆ€ Î´ &gt; 0, âˆƒ x, |x - xâ‚€| â‰¤ Î´ âˆ§ Îµ &lt; |f x - yâ‚€|\n```\nNote that binder names are preserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can use this tactic at the goal using `push_neg`,\nat every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal\nusing say `push_neg at h h' âŠ¢`, as usual.\n</code>",
 "1489": "<code>CM.Ex11_2.fâ‚‚ : X âŸ¶ Y</code>",
 "1488": "<code>â†‘f âŠš â†‘finv = ğŸ™ Y</code>",
 "1487": "<code>â†‘finv âŠš â†‘f = ğŸ™ X</code>",
 "1486": "<code>CM.Ex11_2.X.a : CM.Ex11_2.X</code>",
 "1485": "<code>CM.Ex11_2.X.b : CM.Ex11_2.X</code>",
 "1484": "<code>CM.Ex11_2.X.c : CM.Ex11_2.X</code>",
 "1483": "<code>CM.Ex11_2.YÎ².t</code>",
 "1482": "<code>CM.Ex11_2.fâ‚ : CM.Ex11_2.X âŸ¶ CM.Ex11_2.Y</code>",
 "1481": "<code>CM.Ex11_2.YÎ² : CM.SetWithEndomap</code>",
 "1480": "<code>CM.Ex11_2.XÎ± : CM.SetWithEndomap</code>",
 "148":
 "<code>Not (a : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Not p`, or `Â¬p`, is the negation of `p`. It is defined to be `p â†’ False`,\nso if your goal is `Â¬p` you can use `intro h` to turn the goal into\n`h : p âŠ¢ False`, and if you have `hn : Â¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `Â¬` in identifiers is `not`.</code>",
 "1479": "<code>XÎ± âŸ¶ YÎ²</code>",
 "1478": "<code>CM.Ex11_2.fâ‚ : X âŸ¶ Y</code>",
 "1477": "<code>CM.Ex11_2.YÎ² : SetWithEndomap</code>",
 "1476": "<code>CM.Ex11_2.Î² : Y âŸ¶ Y</code>",
 "1475": "<code>CM.Ex11_2.Y.r : Y</code>",
 "1474": "<code>CM.Ex11_2.Y.q : Y</code>",
 "1473": "<code>CM.Ex11_2.Y.p : Y</code>",
 "1472": "<code>CM.Ex11_2.Y : Type</code>",
 "1471": "<code>CM.Ex11_2.XÎ± : SetWithEndomap</code>",
 "1470": "<code>CM.Ex11_2.Î± : X âŸ¶ X</code>",
 "147": "<code>Map B A</code>",
 "1469": "<code>CM.Ex11_2.X.c : X</code>",
 "1468": "<code>CM.Ex11_2.X.b : X</code>",
 "1467": "<code>CM.Ex11_2.X.a : X</code>",
 "1466": "<code>CM.Ex11_2.X : Type</code>",
 "1465": "<code>CM.Ex11_1.fâ‚„ : A âŸ¶ X</code>",
 "1464": "<code>CM.Ex11_1.fâ‚ƒ : A âŸ¶ X</code>",
 "1463": "<code>CM.Ex11_1.fâ‚‚ : A âŸ¶ X</code>",
 "1462": "<code>A'.t</code>",
 "1461": "<code>CM.Ex11_1.fâ‚ : A âŸ¶ X</code>",
 "1460":
 "<code>âˆ€ {a : X},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | X.xâ‚ =&gt; X.xâ‚\n      | X.xâ‚‚ =&gt; X.xâ‚ƒ\n      | X.xâ‚ƒ =&gt; X.xâ‚„\n      | X.xâ‚„ =&gt; X.xâ‚‚) âˆˆ\n      Set.univ</code>",
 "146": "<code>Map A B</code>",
 "1459": "<code>X â†’ X</code>",
 "1458": "<code>CM.Ex11_1.X' : SetWithEndomap</code>",
 "1457":
 "<code>âˆ€ {a : A},\n  a âˆˆ Set.univ â†’\n    (match a with\n      | A.aâ‚ =&gt; A.aâ‚‚\n      | A.aâ‚‚ =&gt; A.aâ‚ƒ\n      | A.aâ‚ƒ =&gt; A.aâ‚) âˆˆ\n      Set.univ</code>",
 "1456": "<code>A â†’ A</code>",
 "1455": "<code>CM.Ex11_1.A' : SetWithEndomap</code>",
 "1454": "<code>CM.Ex11_1.X.xâ‚„ : X</code>",
 "1453": "<code>CM.Ex11_1.X.xâ‚ƒ : X</code>",
 "1452": "<code>CM.Ex11_1.X.xâ‚‚ : X</code>",
 "1451": "<code>CM.Ex11_1.X.xâ‚ : X</code>",
 "1450": "<code>CM.Ex11_1.X : Type</code>",
 "145": "<code>âˆ€ a âˆˆ A, id a âˆˆ A</code>",
 "1449": "<code>CM.Ex11_1.A.aâ‚ƒ : A</code>",
 "1448": "<code>CM.Ex11_1.A.aâ‚‚ : A</code>",
 "1447": "<code>CM.Ex11_1.A.aâ‚ : A</code>",
 "1446": "<code>CM.Ex11_1.A : Type</code>",
 "1445": "<code>â†‘f âŠš xâ‚ = â†‘f âŠš xâ‚‚</code>",
 "1444": "<code>ğŸ™ YÎ².t âŠš â†‘f âŠš xâ‚ = ğŸ™ YÎ².t âŠš â†‘f âŠš xâ‚‚</code>",
 "1443": "<code>Î²inv âŠš YÎ².toEnd âŠš â†‘f âŠš xâ‚ = Î²inv âŠš YÎ².toEnd âŠš â†‘f âŠš xâ‚‚</code>",
 "1442": "<code>Î²inv âŠš YÎ².toEnd = ğŸ™ YÎ².t âˆ§ YÎ².toEnd âŠš Î²inv = ğŸ™ YÎ².t</code>",
 "1441": "<code>(YÎ².toEnd âŠš â†‘f) âŠš xâ‚ = (YÎ².toEnd âŠš â†‘f) âŠš xâ‚‚</code>",
 "1440": "<code>â†‘f âŠš XÎ±.toEnd âŠš xâ‚ = â†‘f âŠš XÎ±.toEnd âŠš xâ‚‚</code>",
 "144":
 "<code>id.{u} {Î± : Sort u} (a : Î±) : Î±</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `Î± : Sort u`\n(a type in any universe), and an argument `a : Î±`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>",
 "1439": "<code>XÎ±.toEnd âŠš xâ‚ = XÎ±.toEnd âŠš xâ‚‚</code>",
 "1438": "<code>Tâœ âŸ¶ XÎ±.t</code>",
 "1437": "<code>T âŸ¶ XÎ±.t</code>",
 "1436": "<code>U âŸ¶ XÎ±.t</code>",
 "1435":
 "<code>âˆ€ {U : Type} (yâ‚ yâ‚‚ : U âŸ¶ XÎ±.t), â†‘f âŠš yâ‚ = â†‘f âŠš yâ‚‚ â†’ yâ‚ = yâ‚‚</code>",
 "1434": "<code>XÎ± âŸ¶ YÎ².toSetWithEndomap</code>",
 "1433": "<code>ğŸ™ YÎ².t (f X.xâ‚€) = ğŸ™ YÎ².t (f X.xâ‚)</code>",
 "1432": "<code>(Î²inv âŠš YÎ².toEnd) (f X.xâ‚€) = (Î²inv âŠš YÎ².toEnd) (f X.xâ‚)</code>",
 "1431": "<code>YÎ².toEnd (f X.xâ‚€) = YÎ².toEnd (f X.xâ‚)</code>",
 "1430": "<code>f X.xâ‚€ = YÎ².toEnd (f X.xâ‚)</code>",
 "143": "<code>CM.ExI_8.idA : Map A A</code>",
 "1429": "<code>f X.xâ‚€ = YÎ².toEnd (f X.xâ‚€)</code>",
 "1428": "<code>CM.ExIII_27.X.xâ‚ : CM.ExIII_27.X</code>",
 "1427": "<code>(f âŠš XÎ±.toEnd) X.xâ‚ = (YÎ².toEnd âŠš f) X.xâ‚</code>",
 "1426": "<code>CM.ExIII_27.X.xâ‚€ : CM.ExIII_27.X</code>",
 "1425": "<code>CM.ExIII_27.XÎ± : CM.SetWithIdemEndomap</code>",
 "1424": "<code>(f âŠš XÎ±.toEnd) X.xâ‚€ = (YÎ².toEnd âŠš f) X.xâ‚€</code>",
 "1423": "<code>âˆ€ x âˆˆ XÎ±.carrier, f x âˆˆ YÎ².carrier</code>",
 "1422": "<code>f âŠš XÎ±.toEnd = YÎ².toEnd âŠš f</code>",
 "1421": "<code>XÎ±.t âŸ¶ YÎ².t</code>",
 "1420": "<code>YÎ².toEnd âŠš Î²inv = ğŸ™ YÎ².t</code>",
 "142":
 "<code>Nat.choose : â„• â†’ â„• â†’ â„•</code><span class=\"sep\"></span><code class=\"docstring\">`choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial\ncoefficients. For the fact that this is the number of `k`-element-subsets of an `n`-element\nset, see `Fintype.card_powersetCard`. </code>",
 "1419": "<code>Î²inv âŠš YÎ².toEnd = ğŸ™ YÎ².t</code>",
 "1418": "<code>YÎ².t âŸ¶ YÎ².t</code>",
 "1417": "<code>XÎ±.toSetWithEndomap âŸ¶ YÎ².toSetWithEndomap</code>",
 "1416": "<code>CM.ExIII_27.XÎ± : SetWithIdemEndomap</code>",
 "1415": "<code>CM.ExIII_27.Î± : X âŸ¶ X</code>",
 "1414": "<code>CM.ExIII_27.X.xâ‚ : X</code>",
 "1413": "<code>CM.ExIII_27.X.xâ‚€ : X</code>",
 "1412": "<code>CM.ExIII_27.X : Type</code>",
 "1411": "<code>Tâœ âŸ¶ â„¤</code>",
 "1410":
 "<code class=\"docstring\">Apply congruence (recursively) to goals of the form `âŠ¢ f as = f bs` and `âŠ¢ f as â‰ f bs`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `âŠ¢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `âŠ¢ x = y` and `âŠ¢ y = x`,\nwhile `congr 2` produces the intended `âŠ¢ x + y = y + x`.\n</code>",
 "141":
 "<code>Finset.range (n : â„•) : Finset â„•</code><span class=\"sep\"></span><code class=\"docstring\">`range n` is the set of natural numbers less than `n`. </code>",
 "1409": "<code>p âŠš f = ğŸ™ â„¤</code>",
 "1408":
 "<code>Rat.num (self : â„š) : â„¤</code><span class=\"sep\"></span><code class=\"docstring\">The numerator of the rational number is an integer. </code>",
 "1407": "<code>â„š âŸ¶ â„¤</code>",
 "1406": "<code>T âŸ¶ â„¤</code>",
 "1405": "<code>Q.t</code>",
 "1404":
 "<code>Rat : Type</code><span class=\"sep\"></span><code class=\"docstring\">Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n</code>",
 "1403": "<code>â„š âŸ¶ â„š</code>",
 "1402": "<code>Q.t âŸ¶ Q.t</code>",
 "1401": "<code>âˆƒ inv, inv âŠš Q.toEnd = ğŸ™ Q.t âˆ§ Q.toEnd âŠš inv = ğŸ™ Q.t</code>",
 "1400": "<code>âˆ€ {a : Q.t}, a âˆˆ Q.carrier â†’ Q.toEnd a âˆˆ Set.univ</code>",
 "140": "<code>â„•</code>",
 "14": "<code>CM.ExI_1.C.câ‚ : C</code>",
 "1399": "<code>Q.t âŸ¶ Q.t</code>",
 "1398": "<code>Set Q.t</code>",
 "1397": "<code>Z.t</code>",
 "1396": "<code>âˆ€ {a : â„š}, a âˆˆ Set.univ â†’ 5 * a âˆˆ Set.univ</code>",
 "1395": "<code>â„š</code>",
 "1394": "<code>â„š â†’ â„š</code>",
 "1393": "<code>Set â„š</code>",
 "1392": "<code>CM.ExIII_26.Q : SetWithEndomap</code>",
 "1391": "<code>âˆ€ {a : â„¤}, a âˆˆ Set.univ â†’ 5 * a âˆˆ Set.univ</code>",
 "1390": "<code>â„¤ â†’ â„¤</code>",
 "139":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat Ã— Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n</code>",
 "1389": "<code>Set â„¤</code>",
 "1388": "<code>CM.ExIII_26.Z : SetWithEndomap</code>",
 "1387": "<code>CM.ExIII_26.f : â„¤ âŸ¶ â„š</code>",
 "1386": "<code>âˆ€ (x : XP.tA), YQ.toSrc (f.1 x) = YQ.toTgt (f.1 x)</code>",
 "1385": "<code>f.2 âŠš XP.toSrc = f.2 âŠš XP.toTgt</code>",
 "1384": "<code>XP.tD</code>",
 "1383": "<code>âˆ€ x âˆˆ XP.carrierD, f.2 x âˆˆ YQ.carrierD</code>",
 "1382": "<code>âˆ€ x âˆˆ XP.carrierA, f.1 x âˆˆ YQ.carrierA</code>",
 "1381": "<code>f.2 âŠš XP.toTgt = YQ.toTgt âŠš f.1</code>",
 "1380": "<code>f.2 âŠš XP.toSrc = YQ.toSrc âŠš f.1</code>",
 "138": "<code>CM.idempotentCount (Î± : Type) [Fintype Î±] : â„•</code>",
 "1379": "<code>(XP.tA âŸ¶ YQ.tA) Ã— (XP.tD âŸ¶ YQ.tD)</code>",
 "1378": "<code>XP.tA</code>",
 "1377": "<code>XP âŸ¶ YQ</code>",
 "1376": "<code>âˆ€ (x : X), s' (fA x) = t' (fA x)</code>",
 "1375": "<code>fD âŠš s = fD âŠš t</code>",
 "1374": "<code>p Y.yâ‚ = X.xâ‚</code>",
 "1373": "<code>p (a X.xâ‚) = X.xâ‚</code>",
 "1372": "<code>âˆ€ (x : X), p (a x) = x</code>",
 "1371": "<code>(p âŠš a, p âŠš a) = (ğŸ™ X, ğŸ™ X)</code>",
 "1370":
 "<code>âŸ¨(â‡‘(ConcreteCategory.hom âŸ¨p, â‹¯âŸ©) âˆ˜ â‡‘(ConcreteCategory.hom âŸ¨a, a'._proof_1âŸ©),\n      â‡‘(ConcreteCategory.hom âŸ¨p, â‹¯âŸ©) âˆ˜ â‡‘(ConcreteCategory.hom âŸ¨a, a'._proof_1âŸ©)),\n    â‹¯âŸ© =\n  âŸ¨(â‡‘(ConcreteCategory.hom (SetWithEndomapHom.id XÎ±)), â‡‘(ConcreteCategory.hom (SetWithEndomapHom.id XÎ±))), â‹¯âŸ©</code>",
 "137":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "1369":
 "<code>CM.ExIII_19_24.a'._proof_1 : (âˆ€ x âˆˆ XÎ±.carrier, ExIII_19_24.a x âˆˆ YÎ².carrier) âˆ§ a âŠš XÎ±.toEnd = YÎ².toEnd âŠš a</code>",
 "1368": "<code>p Y.yâ‚ = X.xâ‚€</code>",
 "1367": "<code>p (Î² Y.yâ‚‚) = X.xâ‚€</code>",
 "1366": "<code>âˆ€ (y : Y), p (Î² y) = X.xâ‚€</code>",
 "1365": "<code>âˆ€ (y : YÎ².t), (p âŠš Î²) y = X.xâ‚€</code>",
 "1364": "<code>âˆ€ (y : YÎ².t), (Î± âŠš p) y = X.xâ‚€</code>",
 "1363": "<code>p âŠš Î² = Î± âŠš p</code>",
 "1362": "<code>YÎ².t</code>",
 "1361": "<code>âˆ€ x âˆˆ YÎ².carrier, p x âˆˆ XÎ±.carrier</code>",
 "1360": "<code>p âŠš YÎ².toEnd = XÎ±.toEnd âŠš p</code>",
 "136":
 "<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : Î±) : Î± := a\n  def K (a : Î±) : Î² â†’ Î± := fun _ =&gt; a\n  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I â†’ identity,\n      K â†’ konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" â‰‹ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `â‰‹` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val â‰‹ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>",
 "1359": "<code>YÎ².t âŸ¶ XÎ±.t</code>",
 "1358": "<code>YÎ² âŸ¶ XÎ±</code>",
 "1357": "<code>X.xâ‚€ = X.xâ‚</code>",
 "1356": "<code>p.2 Y.yâ‚ = X.xâ‚</code>",
 "1355": "<code>a X.xâ‚ = Y.yâ‚</code>",
 "1354": "<code>p.2 (a X.xâ‚) = X.xâ‚</code>",
 "1353": "<code>âˆ€ (x : X), p.2 (a x) = x</code>",
 "1352":
 "<code>Prod.snd.{u, v} {Î± : Type u} {Î² : Type v} (self : Î± Ã— Î²) : Î²</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "1351": "<code>p.2 âŠš a = ğŸ™ X</code>",
 "1350":
 "<code>congrArg.{u, v} {Î± : Sort u} {Î² : Sort v} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²) (h : aâ‚ = aâ‚‚) : f aâ‚ = f aâ‚‚</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function argument: if `aâ‚ = aâ‚‚` then `f aâ‚ = f aâ‚‚` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`&lt;something containing aâ‚&gt; = &lt;something containing aâ‚‚&gt;`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "135":
 "<code>Fintype.card.{u_4} (Î± : Type u_4) [Fintype Î±] : â„•</code><span class=\"sep\"></span><code class=\"docstring\">`card Î±` is the number of elements in `Î±`, defined when `Î±` is a fintype. </code>",
 "1349": "<code>(p.1 âŠš a, p.2 âŠš a) = (ğŸ™ X, ğŸ™ X)</code>",
 "1348": "<code>âŸ¨(p.1 âˆ˜ a, p.2 âˆ˜ a), â‹¯âŸ© = âŸ¨(id, id), â‹¯âŸ©</code>",
 "1347": "<code>p.2 Y.yâ‚ = X.xâ‚€</code>",
 "1346": "<code>Î² Y.yâ‚‚ = Y.yâ‚</code>",
 "1345": "<code>p.2 (Î² Y.yâ‚‚) = X.xâ‚€</code>",
 "1344": "<code>âˆ€ (y : Y), p.2 (Î² y) = X.xâ‚€</code>",
 "1343": "<code>âˆ€ (y : Y'.tA), (p.2 âŠš Î²) y = X.xâ‚€</code>",
 "1342": "<code>âˆ€ (y : Y'.tA), (Î± âŠš p.1) y = X.xâ‚€</code>",
 "1341": "<code>p.2 âŠš Î² = Î± âŠš p.1</code>",
 "1340": "<code>Y'.tD</code>",
 "134":
 "<code>Fintype.{u_4} (Î± : Type u_4) : Type u_4</code><span class=\"sep\"></span><code class=\"docstring\">`Fintype Î±` means that `Î±` is finite, i.e. there are only\nfinitely many distinct elements of type `Î±`. The evidence of this\nis a finset `elems` (a list up to permutation without duplicates),\ntogether with a proof that everything of type `Î±` is in the list. </code>",
 "1339": "<code>âˆ€ x âˆˆ Y'.carrierD, p.2 x âˆˆ X'.carrierD</code>",
 "1338": "<code>Y'.tA</code>",
 "1337": "<code>âˆ€ x âˆˆ Y'.carrierA, p.1 x âˆˆ X'.carrierA</code>",
 "1336": "<code>p.2 âŠš Y'.toFun = X'.toFun âŠš p.1</code>",
 "1335": "<code>(Y'.tA âŸ¶ X'.tA) Ã— (Y'.tD âŸ¶ X'.tD)</code>",
 "1334": "<code>Y' âŸ¶ X'</code>",
 "1333": "<code>X'.tD</code>",
 "1332": "<code>X'.tA</code>",
 "1331": "<code>CM.ExIII_19_24.a'' : X' âŸ¶ Y'</code>",
 "1330": "<code>CM.ExIII_19_24.Y' : SimpleGraph</code>",
 "133":
 "<code>CM.Alysia's_formula.{u_1, u_2} (Î± : Type u_1) (Î² : Type u_2) [Fintype Î±] [Fintype Î²] : â„•</code>",
 "1329": "<code>CM.ExIII_19_24.X' : SimpleGraph</code>",
 "1328": "<code>CM.ExIII_19_24.bâ‚ˆ : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "1327": "<code>(bâ‚ˆ âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚ˆ) Y.yâ‚‚</code>",
 "1326": "<code>bâ‚ˆ âŠš Î² = Î± âŠš bâ‚ˆ</code>",
 "1325": "<code>CM.ExIII_19_24.bâ‚ˆ : Y âŸ¶ X</code>",
 "1324": "<code>CM.ExIII_19_24.bâ‚‡ : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "1323": "<code>(bâ‚‡ âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚‡) Y.yâ‚‚</code>",
 "1322": "<code>bâ‚‡ âŠš Î² = Î± âŠš bâ‚‡</code>",
 "1321": "<code>CM.ExIII_19_24.bâ‚‡ : Y âŸ¶ X</code>",
 "1320": "<code>CM.ExIII_19_24.bâ‚† : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "132": "<code>CM.Point (Y : Type) : Type</code>",
 "1319": "<code>(bâ‚† âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚†) Y.yâ‚‚</code>",
 "1318": "<code>bâ‚† âŠš Î² = Î± âŠš bâ‚†</code>",
 "1317": "<code>CM.ExIII_19_24.bâ‚† : Y âŸ¶ X</code>",
 "1316": "<code>CM.ExIII_19_24.bâ‚… : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "1315": "<code>(bâ‚… âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚…) Y.yâ‚‚</code>",
 "1314": "<code>bâ‚… âŠš Î² = Î± âŠš bâ‚…</code>",
 "1313": "<code>CM.ExIII_19_24.bâ‚… : Y âŸ¶ X</code>",
 "1312": "<code>CM.ExIII_19_24.bâ‚„ : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "1311": "<code>(bâ‚„ âŠš Î²) Y.yâ‚€ = (Î± âŠš bâ‚„) Y.yâ‚€</code>",
 "1310": "<code>bâ‚„ âŠš Î² = Î± âŠš bâ‚„</code>",
 "131": "<code>CM.CM_Type.eggs : Point B</code>",
 "1309": "<code>CM.ExIII_19_24.bâ‚„ : Y âŸ¶ X</code>",
 "1308": "<code>CM.ExIII_19_24.bâ‚ƒ : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "1307": "<code>(bâ‚ƒ âŠš Î²) Y.yâ‚€ = (Î± âŠš bâ‚ƒ) Y.yâ‚€</code>",
 "1306": "<code>bâ‚ƒ âŠš Î² = Î± âŠš bâ‚ƒ</code>",
 "1305": "<code>CM.ExIII_19_24.bâ‚ƒ : Y âŸ¶ X</code>",
 "1304": "<code>CM.ExIII_19_24.bâ‚‚ : Y âŸ¶ X</code>",
 "1303": "<code>Y</code>",
 "1302": "<code>CM.ExIII_19_24.bâ‚ : Y âŸ¶ X</code>",
 "1301": "<code>CM.ExIII_19_24.pâ‚‚ : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "1300": "<code>(pâ‚‚ âŠš Î²) Y.yâ‚‚ = (Î± âŠš pâ‚‚) Y.yâ‚‚</code>",
 "130":
 "<code>Subtype.val.{u} {Î± : Sort u} {p : Î± â†’ Prop} (self : Subtype p) : Î±</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "13": "<code>CM.ExI_1.C : Type</code>",
 "1299": "<code>pâ‚‚ âŠš Î² = Î± âŠš pâ‚‚</code>",
 "1298": "<code>X.xâ‚ = X.xâ‚€</code>",
 "1297": "<code>CM.ExIII_19_24.Î± : CM.ExIII_19_24.X âŸ¶ CM.ExIII_19_24.X</code>",
 "1296": "<code>CM.ExIII_19_24.pâ‚ : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.X</code>",
 "1295": "<code>CM.ExIII_19_24.Î² : CM.ExIII_19_24.Y âŸ¶ CM.ExIII_19_24.Y</code>",
 "1294": "<code>(pâ‚ âŠš Î²) Y.yâ‚‚ = (Î± âŠš pâ‚) Y.yâ‚‚</code>",
 "1293": "<code>pâ‚ âŠš Î² = Î± âŠš pâ‚</code>",
 "1292": "<code>CM.ExIII_19_24.pâ‚‚ : Y âŸ¶ X</code>",
 "1291": "<code>a X.xâ‚€ = a X.xâ‚</code>",
 "1290": "<code>a X.xâ‚€ = a X.xâ‚€</code>",
 "129":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "1289": "<code>a X.xâ‚ = a X.xâ‚</code>",
 "1288": "<code>a X.xâ‚ = a X.xâ‚€</code>",
 "1287": "<code>a X.xâ‚ = a y</code>",
 "1286": "<code>a X.xâ‚€ = a y</code>",
 "1285": "<code>a x = a y</code>",
 "1284": "<code>CM.ExIII_19_24.pâ‚ : Y âŸ¶ X</code>",
 "1283": "<code>x = CM.ExIII_19_24.X.xâ‚</code>",
 "1282": "<code>x = CM.ExIII_19_24.X.xâ‚€</code>",
 "1281": "<code>CM.ExIII_19_24.X</code>",
 "1280": "<code>CM.ExIII_19_24.a : CM.ExIII_19_24.X âŸ¶ CM.ExIII_19_24.Y</code>",
 "128": "<code>CM.CM_Type.f : A â†’ B</code>",
 "1279": "<code>Tâœ âŸ¶ X</code>",
 "1278": "<code>CM.ExIII_19_24.Y.yâ‚‚ : CM.ExIII_19_24.Y</code>",
 "1277": "<code>CM.ExIII_19_24.X.xâ‚ : CM.ExIII_19_24.X</code>",
 "1276": "<code>CM.ExIII_19_24.Y.yâ‚ : CM.ExIII_19_24.Y</code>",
 "1275": "<code>CM.ExIII_19_24.X.xâ‚€ : CM.ExIII_19_24.X</code>",
 "1274": "<code>CM.ExIII_19_24.Y.yâ‚€ : CM.ExIII_19_24.Y</code>",
 "1273": "<code>CM.ExIII_19_24.Y</code>",
 "1272": "<code>XÎ±.t</code>",
 "1271": "<code>CM.ExIII_19_24.a' : XÎ± âŸ¶ YÎ²</code>",
 "1270": "<code>âˆ€ {a : Y}, a âˆˆ Set.univ â†’ Î² a âˆˆ Set.univ</code>",
 "127": "<code>One</code>",
 "1269": "<code>Y âŸ¶ Y</code>",
 "1268": "<code>Set Y</code>",
 "1267": "<code>CM.ExIII_19_24.YÎ² : SetWithEndomap</code>",
 "1266": "<code>âˆ€ {a : X}, a âˆˆ Set.univ â†’ Î± a âˆˆ Set.univ</code>",
 "1265": "<code>X âŸ¶ X</code>",
 "1264": "<code>Set X</code>",
 "1263": "<code>CM.ExIII_19_24.XÎ± : SetWithEndomap</code>",
 "1262": "<code>CM.ExIII_19_24.a : X âŸ¶ Y</code>",
 "1261": "<code>CM.ExIII_19_24.Î² : Y âŸ¶ Y</code>",
 "1260": "<code>CM.ExIII_19_24.Î± : X âŸ¶ X</code>",
 "126":
 "<code>Subtype.mk.{u} {Î± : Sort u} {p : Î± â†’ Prop} (val : Î±) (property : p val) : Subtype p</code>",
 "1259": "<code>CM.ExIII_19_24.Y.yâ‚‚ : Y</code>",
 "1258": "<code>CM.ExIII_19_24.Y.yâ‚ : Y</code>",
 "1257": "<code>CM.ExIII_19_24.Y.yâ‚€ : Y</code>",
 "1256": "<code>CM.ExIII_19_24.Y : Type</code>",
 "1255": "<code>CM.ExIII_19_24.X.xâ‚ : X</code>",
 "1254": "<code>CM.ExIII_19_24.X.xâ‚€ : X</code>",
 "1253": "<code>CM.ExIII_19_24.X : Type</code>",
 "1252": "<code>a âŠš xâ‚ = a âŠš xâ‚‚</code>",
 "1251": "<code>p âŠš a = ğŸ™ X</code>",
 "1250": "<code>T âŸ¶ X</code>",
 "125": "<code>CM.CM_Type.John : Point A</code>",
 "1249": "<code>x âˆˆ Xâœ.carrierF</code>",
 "1248": "<code>x âˆˆ Xâœ.carrierM</code>",
 "1247": "<code>g.2 âŠš Yâœ.Î¼' = Zâœ.Î¼' âŠš g.1</code>",
 "1246": "<code>g.2 âŠš Yâœ.Î¼ = Zâœ.Î¼ âŠš g.2</code>",
 "1245": "<code>g.1 âŠš Yâœ.Ï†' = Zâœ.Ï†' âŠš g.2</code>",
 "1244": "<code>g.1 âŠš Yâœ.Ï† = Zâœ.Ï† âŠš g.1</code>",
 "1243": "<code>âˆ€ x âˆˆ Yâœ.carrierF, g.2 x âˆˆ Zâœ.carrierF</code>",
 "1242": "<code>âˆ€ x âˆˆ Yâœ.carrierM, g.1 x âˆˆ Zâœ.carrierM</code>",
 "1241": "<code>f.2 âŠš Xâœ.Î¼' = Yâœ.Î¼' âŠš f.1</code>",
 "1240": "<code>f.2 âŠš Xâœ.Î¼ = Yâœ.Î¼ âŠš f.2</code>",
 "124": "<code>CM.CM_Type.B : Type</code>",
 "1239": "<code>f.1 âŠš Xâœ.Ï†' = Yâœ.Ï†' âŠš f.2</code>",
 "1238": "<code>f.1 âŠš Xâœ.Ï† = Yâœ.Ï† âŠš f.1</code>",
 "1237": "<code>âˆ€ x âˆˆ Xâœ.carrierF, f.2 x âˆˆ Yâœ.carrierF</code>",
 "1236": "<code>âˆ€ x âˆˆ Xâœ.carrierM, f.1 x âˆˆ Yâœ.carrierM</code>",
 "1235": "<code>Yâœ.tF</code>",
 "1234": "<code>Yâœ.tM</code>",
 "1233": "<code>Xâœ.tF</code>",
 "1232": "<code>Xâœ.tM</code>",
 "1231":
 "<code>(âˆ€ x âˆˆ Yâœ.carrierM, g.1 x âˆˆ Zâœ.carrierM) âˆ§\n  (âˆ€ x âˆˆ Yâœ.carrierF, g.2 x âˆˆ Zâœ.carrierF) âˆ§\n    g.1 âŠš Yâœ.Ï† = Zâœ.Ï† âŠš g.1 âˆ§ g.1 âŠš Yâœ.Ï†' = Zâœ.Ï†' âŠš g.2 âˆ§ g.2 âŠš Yâœ.Î¼ = Zâœ.Î¼ âŠš g.2 âˆ§ g.2 âŠš Yâœ.Î¼' = Zâœ.Î¼' âŠš g.1</code>",
 "1230": "<code>(Yâœ.tM âŸ¶ Zâœ.tM) Ã— (Yâœ.tF âŸ¶ Zâœ.tF)</code>",
 "123": "<code>CM.CM_Type.A : Type</code>",
 "1229":
 "<code>(âˆ€ x âˆˆ Xâœ.carrierM, f.1 x âˆˆ Yâœ.carrierM) âˆ§\n  (âˆ€ x âˆˆ Xâœ.carrierF, f.2 x âˆˆ Yâœ.carrierF) âˆ§\n    f.1 âŠš Xâœ.Ï† = Yâœ.Ï† âŠš f.1 âˆ§ f.1 âŠš Xâœ.Ï†' = Yâœ.Ï†' âŠš f.2 âˆ§ f.2 âŠš Xâœ.Î¼ = Yâœ.Î¼ âŠš f.2 âˆ§ f.2 âŠš Xâœ.Î¼' = Yâœ.Î¼' âŠš f.1</code>",
 "1228": "<code>(Xâœ.tM âŸ¶ Yâœ.tM) Ã— (Xâœ.tF âŸ¶ Yâœ.tF)</code>",
 "1227":
 "<code>{X Y Z : ParentLike} â†’ ParentLikeHom X Y â†’ ParentLikeHom Y Z â†’ ParentLikeHom X Z</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "1226": "<code>xâœ âˆˆ X.carrierM</code>",
 "1225":
 "<code>(X : ParentLike) â†’\n  { f //\n    (âˆ€ x âˆˆ X.carrierM, f.1 x âˆˆ X.carrierM) âˆ§\n      (âˆ€ x âˆˆ X.carrierF, f.2 x âˆˆ X.carrierF) âˆ§\n        f.1 âŠš X.Ï† = X.Ï† âŠš f.1 âˆ§ f.1 âŠš X.Ï†' = X.Ï†' âŠš f.2 âˆ§ f.2 âŠš X.Î¼ = X.Î¼ âŠš f.2 âˆ§ f.2 âŠš X.Î¼' = X.Î¼' âŠš f.1 }</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "1224":
 "<code>ParentLike â†’ ParentLike â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "1223": "<code>X.tF</code>",
 "1222": "<code>X.tM</code>",
 "1221": "<code>(X.tM âŸ¶ Y.tM) Ã— (X.tF âŸ¶ Y.tF)</code>",
 "1220": "<code>ParentLike</code>",
 "122":
 "<code class=\"docstring\">A type universe. `Type â‰¡ Type 0`, `Type u â‰¡ Sort (u + 1)`. </code>",
 "1219": "<code>CM.ExIII_17.ParentLikeHom (X Y : ParentLike) : Type</code>",
 "1218": "<code>tM âŸ¶ tF</code>",
 "1217":
 "<code>CM.ExIII_17.ParentLike.Î¼'_mem (self : ParentLike) {m : self.tM} : m âˆˆ self.carrierM â†’ self.Î¼' m âˆˆ self.carrierF</code>",
 "1216":
 "<code>CM.ExIII_17.ParentLike.Î¼' (self : ParentLike) : self.tM âŸ¶ self.tF</code>",
 "1215": "<code>tF âŸ¶ tF</code>",
 "1214":
 "<code>CM.ExIII_17.ParentLike.Î¼_mem (self : ParentLike) {f : self.tF} : f âˆˆ self.carrierF â†’ self.Î¼ f âˆˆ self.carrierF</code>",
 "1213":
 "<code>CM.ExIII_17.ParentLike.Î¼ (self : ParentLike) : self.tF âŸ¶ self.tF</code>",
 "1212": "<code>tF âŸ¶ tM</code>",
 "1211": "<code>Set tF</code>",
 "1210": "<code>tF</code>",
 "121": "<code>Type</code>",
 "1209":
 "<code>CM.ExIII_17.ParentLike.Ï†'_mem (self : ParentLike) {f : self.tF} : f âˆˆ self.carrierF â†’ self.Ï†' f âˆˆ self.carrierM</code>",
 "1208":
 "<code>CM.ExIII_17.ParentLike.Ï†' (self : ParentLike) : self.tF âŸ¶ self.tM</code>",
 "1207": "<code>tM âŸ¶ tM</code>",
 "1206": "<code>Set tM</code>",
 "1205": "<code>tM</code>",
 "1204":
 "<code>CM.ExIII_17.ParentLike.Ï†_mem (self : ParentLike) {m : self.tM} : m âˆˆ self.carrierM â†’ self.Ï† m âˆˆ self.carrierM</code>",
 "1203":
 "<code>CM.ExIII_17.ParentLike.Ï† (self : ParentLike) : self.tM âŸ¶ self.tM</code>",
 "1202":
 "<code>CM.ExIII_17.ParentLike.carrierF (self : ParentLike) : Set self.tF</code>",
 "1201": "<code>CM.ExIII_17.ParentLike.tF (self : ParentLike) : Type</code>",
 "1200":
 "<code>CM.ExIII_17.ParentLike.carrierM (self : ParentLike) : Set self.tM</code>",
 "120": "<code>CM.CM_Type.Point (Y : Type) : Type</code>",
 "12": "<code>CM.ExI_1.B.bâ‚„ : B</code>",
 "1199": "<code>CM.ExIII_17.ParentLike.tM (self : ParentLike) : Type</code>",
 "1198": "<code>CM.ExIII_17.ParentLike : Type 1</code>",
 "1197":
 "<code class=\"docstring\">`congrm e` is a tactic for proving goals of the form `lhs = rhs`, `lhs â†” rhs`, `lhs â‰ rhs`,\nor `R lhs rhs` when `R` is a reflexive relation.\nThe expression `e` is a pattern containing placeholders `?_`,\nand this pattern is matched against `lhs` and `rhs` simultaneously.\nThese placeholders generate new goals that state that corresponding subexpressions\nin `lhs` and `rhs` are equal.\nIf the placeholders have names, such as `?m`, then the new goals are given tags with those names.\n\nExamples:\n```lean\nexample {a b c d : â„•} :\n    Nat.pred a.succ * (d + (c + a.pred)) = Nat.pred b.succ * (b + (c + d.pred)) := by\n  congrm Nat.pred (Nat.succ ?h1) * (?h2 + ?h3)\n  /-  Goals left:\n  case h1 âŠ¢ a = b\n  case h2 âŠ¢ d = b\n  case h3 âŠ¢ c + a.pred = c + d.pred\n  -/\n  sorry\n  sorry\n  sorry\n\nexample {a b : â„•} (h : a = b) : (fun y : â„• =&gt; âˆ€ z, a + a = z) = (fun x =&gt; âˆ€ z, b + a = z) := by\n  congrm fun x =&gt; âˆ€ w, ?_ + a = w\n  -- âŠ¢ a = b\n  exact h\n```\n\nThe `congrm` command is a convenient frontend to `congr(...)` congruence quotations.\nIf the goal is an equality, `congrm e` is equivalent to `refine congr(e')` where `e'` is\nbuilt from `e` by replacing each placeholder `?m` by `$(?m)`.\nThe pattern `e` is allowed to contain `$(...)` expressions to immediately substitute\nequality proofs into the congruence, just like for congruence quotations.\n</code>",
 "1196": "<code><span class=\"literal string\">\"i'\"</span> : String</code>",
 "1195": "<code><span class=\"literal string\">\"i\"</span> : String</code>",
 "1194": "<code><span class=\"literal string\">\"t'\"</span> : String</code>",
 "1193": "<code><span class=\"literal string\">\"t\"</span> : String</code>",
 "1192": "<code><span class=\"literal string\">\"s'\"</span> : String</code>",
 "1191": "<code><span class=\"literal string\">\"s\"</span> : String</code>",
 "1190": "<code><span class=\"literal string\">\"fD\"</span> : String</code>",
 "119": "<code>CM.One : Type</code>",
 "1189": "<code><span class=\"literal string\">\"fA\"</span> : String</code>",
 "1188": "<code>eâ‚€ = X.toCommonSection âŠš X.toTgt</code>",
 "1187": "<code>eâ‚ = X.toCommonSection âŠš X.toSrc</code>",
 "1186": "<code>X.tA âŸ¶ X.tA</code>",
 "1185": "<code>g.1 âŠš Yâœ.toCommonSection = Zâœ.toCommonSection âŠš g.2</code>",
 "1184": "<code>f.1 âŠš Xâœ.toCommonSection = Yâœ.toCommonSection âŠš f.2</code>",
 "1183":
 "<code>(âˆ€ x âˆˆ Yâœ.carrierA, g.1 x âˆˆ Zâœ.carrierA) âˆ§\n  (âˆ€ x âˆˆ Yâœ.carrierD, g.2 x âˆˆ Zâœ.carrierD) âˆ§\n    g.2 âŠš Yâœ.toSrc = Zâœ.toSrc âŠš g.1 âˆ§\n      g.2 âŠš Yâœ.toTgt = Zâœ.toTgt âŠš g.1 âˆ§ g.1 âŠš Yâœ.toCommonSection = Zâœ.toCommonSection âŠš g.2</code>",
 "1182":
 "<code>(âˆ€ x âˆˆ Xâœ.carrierA, f.1 x âˆˆ Yâœ.carrierA) âˆ§\n  (âˆ€ x âˆˆ Xâœ.carrierD, f.2 x âˆˆ Yâœ.carrierD) âˆ§\n    f.2 âŠš Xâœ.toSrc = Yâœ.toSrc âŠš f.1 âˆ§\n      f.2 âŠš Xâœ.toTgt = Yâœ.toTgt âŠš f.1 âˆ§ f.1 âŠš Xâœ.toCommonSection = Yâœ.toCommonSection âŠš f.2</code>",
 "1181":
 "<code>{X Y Z : ReflexiveGraph} â†’\n  { f //\n      (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Y.carrierA) âˆ§\n        (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Y.carrierD) âˆ§\n          f.2 âŠš X.toSrc = Y.toSrc âŠš f.1 âˆ§\n            f.2 âŠš X.toTgt = Y.toTgt âŠš f.1 âˆ§ f.1 âŠš X.toCommonSection = Y.toCommonSection âŠš f.2 } â†’\n    { f //\n        (âˆ€ x âˆˆ Y.carrierA, f.1 x âˆˆ Z.carrierA) âˆ§\n          (âˆ€ x âˆˆ Y.carrierD, f.2 x âˆˆ Z.carrierD) âˆ§\n            f.2 âŠš Y.toSrc = Z.toSrc âŠš f.1 âˆ§\n              f.2 âŠš Y.toTgt = Z.toTgt âŠš f.1 âˆ§ f.1 âŠš Y.toCommonSection = Z.toCommonSection âŠš f.2 } â†’\n      { f //\n        (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Z.carrierA) âˆ§\n          (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Z.carrierD) âˆ§\n            f.2 âŠš X.toSrc = Z.toSrc âŠš f.1 âˆ§\n              f.2 âŠš X.toTgt = Z.toTgt âŠš f.1 âˆ§ f.1 âŠš X.toCommonSection = Z.toCommonSection âŠš f.2 }</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "1180":
 "<code>(X : ReflexiveGraph) â†’\n  { f //\n    (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ X.carrierA) âˆ§\n      (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ X.carrierD) âˆ§\n        f.2 âŠš X.toSrc = X.toSrc âŠš f.1 âˆ§\n          f.2 âŠš X.toTgt = X.toTgt âŠš f.1 âˆ§ f.1 âŠš X.toCommonSection = X.toCommonSection âŠš f.2 }</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "118": "<code>CM.CM_Set.eggs : Point B</code>",
 "1179": "<code>ReflexiveGraph</code>",
 "1178":
 "<code>ReflexiveGraph â†’ ReflexiveGraph â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "1177":
 "<code>CM.ReflexiveGraph.section_tgt (self : ReflexiveGraph) : self.toTgt âŠš self.toCommonSection = ğŸ™ self.tD</code>",
 "1176":
 "<code>CM.ReflexiveGraph.section_src (self : ReflexiveGraph) : self.toSrc âŠš self.toCommonSection = ğŸ™ self.tD</code>",
 "1175": "<code>tD âŸ¶ tA</code>",
 "1174": "<code>tD</code>",
 "1173":
 "<code>CM.ReflexiveGraph.toCommonSection_mem (self : ReflexiveGraph) {d : self.tD} :\n  d âˆˆ self.carrierD â†’ self.toCommonSection d âˆˆ self.carrierA</code>",
 "1172":
 "<code>CM.ReflexiveGraph.toCommonSection (self : ReflexiveGraph) : self.tD âŸ¶ self.tA</code>",
 "1171": "<code>CM.ReflexiveGraph : Type 1</code>",
 "1170": "<code>CM.ExIII_14.Y.yâ‚ : CM.ExIII_14.Y</code>",
 "117":
 "<code>Set.mem_singleton_iff.{u} {Î± : Type u} {a b : Î±} : a âˆˆ {b} â†” a = b</code>",
 "1169": "<code>CM.ExIII_14.Y.yâ‚‚ : CM.ExIII_14.Y</code>",
 "1168": "<code>Y.yâ‚‚ = Y.yâ‚</code>",
 "1167": "<code>CM.ExIII_14.X.xâ‚‚ : CM.ExIII_14.X</code>",
 "1166": "<code>fA X.xâ‚‚ = fD X.xâ‚‚</code>",
 "1165": "<code>fA = fD</code>",
 "1164": "<code>CM.ExIII_14.fD : X âŸ¶ Y</code>",
 "1163": "<code>CM.ExIII_14.fA : X âŸ¶ Y</code>",
 "1162": "<code>CM.ExIII_14.Î² : Y âŸ¶ Y</code>",
 "1161": "<code>CM.ExIII_14.Î± : X âŸ¶ X</code>",
 "1160": "<code>CM.ExIII_14.Y.yâ‚‚ : Y</code>",
 "116":
 "<code>Set.mem_insert_iff.{u} {Î± : Type u} {x a : Î±} {s : Set Î±} : x âˆˆ insert a s â†” x = a âˆ¨ x âˆˆ s</code>",
 "1159": "<code>CM.ExIII_14.Y.yâ‚ : Y</code>",
 "1158": "<code>CM.ExIII_14.Y : Type</code>",
 "1157": "<code>CM.ExIII_14.X.xâ‚‚ : X</code>",
 "1156": "<code>CM.ExIII_14.X.xâ‚ : X</code>",
 "1155": "<code>CM.ExIII_14.X : Type</code>",
 "1154":
 "<code>CM.J {X Y : SetWithEndomap} (f : X âŸ¶ Y) :\n  functorSetWithEndomapToSimpleGraph.obj X âŸ¶ functorSetWithEndomapToSimpleGraph.obj Y</code>",
 "1153":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierD := Set.univ,\n    toFun := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.toEnd, toFun_mem := â‹¯ }.tD</code>",
 "1152":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierD := Set.univ,\n    toFun := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.toEnd, toFun_mem := â‹¯ }.tA</code>",
 "1151":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierD := Set.univ,\n    toFun := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.toEnd, toFun_mem := â‹¯ }.tD</code>",
 "1150":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierD := Set.univ,\n    toFun := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.toEnd, toFun_mem := â‹¯ }.tA</code>",
 "115": "<code>CM.CM_Set.f : Map A B</code>",
 "1149":
 "<code>{ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd, toFun_mem := â‹¯ }.tD</code>",
 "1148":
 "<code>CM.SimpleGraph.mk (tA : Type) (carrierA : Set tA) (tD : Type) (carrierD : Set tD) (toFun : tA âŸ¶ tD)\n  (toFun_mem : âˆ€ {a : tA}, a âˆˆ carrierA â†’ toFun a âˆˆ carrierD) : SimpleGraph</code>",
 "1147":
 "<code>{ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd, toFun_mem := â‹¯ }.tA</code>",
 "1146":
 "<code>(âˆ€ x âˆˆ { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd, toFun_mem := â‹¯ }.carrierA,\n    (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).1 x âˆˆ\n      { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd, toFun_mem := â‹¯ }.carrierA) âˆ§\n  (âˆ€\n      x âˆˆ\n        { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd, toFun_mem := â‹¯ }.carrierD,\n      (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).2 x âˆˆ\n        { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd,\n            toFun_mem := â‹¯ }.carrierD) âˆ§\n    (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).2 âŠš\n        { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd, toFun_mem := â‹¯ }.toFun =\n      { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd, toFun_mem := â‹¯ }.toFun âŠš\n        (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1145":
 "<code>({ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd, toFun_mem := â‹¯ }.tA âŸ¶\n    { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd, toFun_mem := â‹¯ }.tA) Ã—\n  ({ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd, toFun_mem := â‹¯ }.tD âŸ¶\n    { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd, toFun_mem := â‹¯ }.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1144":
 "<code>{X Y : SetWithEndomap} â†’\n  (X âŸ¶ Y) â†’\n    { f //\n      (âˆ€\n          x âˆˆ\n            { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd,\n                toFun_mem := â‹¯ }.carrierA,\n          f.1 x âˆˆ\n            { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd,\n                toFun_mem := â‹¯ }.carrierA) âˆ§\n        (âˆ€\n            x âˆˆ\n              { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd,\n                  toFun_mem := â‹¯ }.carrierD,\n            f.2 x âˆˆ\n              { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd,\n                  toFun_mem := â‹¯ }.carrierD) âˆ§\n          f.2 âŠš\n              { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toFun := X.toEnd,\n                  toFun_mem := â‹¯ }.toFun =\n            { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toFun := Y.toEnd,\n                  toFun_mem := â‹¯ }.toFun âŠš\n              f.1 }</code><span class=\"sep\"></span><code class=\"docstring\">The action of a functor on morphisms. </code>",
 "1143":
 "<code>SetWithEndomap â†’ SimpleGraph</code><span class=\"sep\"></span><code class=\"docstring\">The action of a functor on objects. </code>",
 "1142":
 "<code>CM.functorSetWithEndomapToSimpleGraph : SetWithEndomap â¥¤ SimpleGraph</code>",
 "1141": "<code>g.2 âŠš Yâœ.toFun = Zâœ.toFun âŠš g.1</code>",
 "1140": "<code>f.2 âŠš Xâœ.toFun = Yâœ.toFun âŠš f.1</code>",
 "114": "<code>CM.CM_Set.John : Point A</code>",
 "1139":
 "<code>(âˆ€ x âˆˆ Yâœ.carrierA, g.1 x âˆˆ Zâœ.carrierA) âˆ§ (âˆ€ x âˆˆ Yâœ.carrierD, g.2 x âˆˆ Zâœ.carrierD) âˆ§ g.2 âŠš Yâœ.toFun = Zâœ.toFun âŠš g.1</code>",
 "1138":
 "<code>(âˆ€ x âˆˆ Xâœ.carrierA, f.1 x âˆˆ Yâœ.carrierA) âˆ§ (âˆ€ x âˆˆ Xâœ.carrierD, f.2 x âˆˆ Yâœ.carrierD) âˆ§ f.2 âŠš Xâœ.toFun = Yâœ.toFun âŠš f.1</code>",
 "1137":
 "<code>{X Y Z : SimpleGraph} â†’\n  { f //\n      (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Y.carrierA) âˆ§\n        (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Y.carrierD) âˆ§ f.2 âŠš X.toFun = Y.toFun âŠš f.1 } â†’\n    { f //\n        (âˆ€ x âˆˆ Y.carrierA, f.1 x âˆˆ Z.carrierA) âˆ§\n          (âˆ€ x âˆˆ Y.carrierD, f.2 x âˆˆ Z.carrierD) âˆ§ f.2 âŠš Y.toFun = Z.toFun âŠš f.1 } â†’\n      { f //\n        (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Z.carrierA) âˆ§\n          (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Z.carrierD) âˆ§ f.2 âŠš X.toFun = Z.toFun âŠš f.1 }</code><span class=\"sep\"></span><code class=\"docstring\">Composition of morphisms in a category, written `f â‰« g`. </code>",
 "1136":
 "<code>(X : SimpleGraph) â†’\n  { f //\n    (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ X.carrierA) âˆ§ (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ X.carrierD) âˆ§ f.2 âŠš X.toFun = X.toFun âŠš f.1 }</code><span class=\"sep\"></span><code class=\"docstring\">The identity morphism on an object. </code>",
 "1135": "<code>SimpleGraph</code>",
 "1134":
 "<code>SimpleGraph â†’ SimpleGraph â†’ Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of edges/arrows/morphisms between a given source and target. </code>",
 "1133":
 "<code>CM.SimpleGraph.toFun_mem (self : SimpleGraph) {a : self.tA} : a âˆˆ self.carrierA â†’ self.toFun a âˆˆ self.carrierD</code>",
 "1132":
 "<code>CM.SimpleGraph.toFun (self : SimpleGraph) : self.tA âŸ¶ self.tD</code>",
 "1131":
 "<code>CM.SimpleGraph.carrierD (self : SimpleGraph) : Set self.tD</code>",
 "1130": "<code>CM.SimpleGraph.tD (self : SimpleGraph) : Type</code>",
 "113": "<code>CM.CM_Set.B : Set String</code>",
 "1129":
 "<code>CM.SimpleGraph.carrierA (self : SimpleGraph) : Set self.tA</code>",
 "1128": "<code>CM.SimpleGraph.tA (self : SimpleGraph) : Type</code>",
 "1127": "<code>CM.SimpleGraph : Type 1</code>",
 "1126": "<code>(â†‘fâ‚‚).2 âŠš ğŸ™ X'.t = ğŸ™ Y'.t âŠš (â†‘fâ‚‚).1</code>",
 "1125":
 "<code>(â†‘fâ‚‚).2 âŠš (graphâ‚‚ X').toTgt = (graphâ‚‚ Y').toTgt âŠš (â†‘fâ‚‚).1</code>",
 "1124": "<code>(graphâ‚‚ X').tD</code>",
 "1123":
 "<code>âˆ€ x âˆˆ (graphâ‚‚ X').carrierD, (â†‘fâ‚‚).2 x âˆˆ (graphâ‚‚ Y').carrierD</code>",
 "1122": "<code>(graphâ‚‚ X').tA</code>",
 "1121":
 "<code>âˆ€ x âˆˆ (graphâ‚‚ X').carrierA, (â†‘fâ‚‚).1 x âˆˆ (graphâ‚‚ Y').carrierA</code>",
 "1120":
 "<code>(â†‘fâ‚‚).2 âŠš (graphâ‚‚ X').toSrc = (graphâ‚‚ Y').toSrc âŠš (â†‘fâ‚‚).1</code>",
 "112": "<code>CM.CM_Set.A : Set String</code>",
 "1119": "<code><span class=\"literal string\">\"fDâ‚‚\"</span> : String</code>",
 "1118": "<code><span class=\"literal string\">\"fAâ‚‚\"</span> : String</code>",
 "1117": "<code>graphâ‚‚ X' âŸ¶ graphâ‚‚ Y'</code>",
 "1116":
 "<code>CategoryTheory.Functor.obj.{vâ‚, vâ‚‚, uâ‚, uâ‚‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚, uâ‚‚} D]\n  (self : C â¥¤ D) : C â†’ D</code><span class=\"sep\"></span><code class=\"docstring\">The action of a functor on objects. </code>",
 "1115":
 "<code>CM.ExIII_13.graphâ‚‚ (S : SetWithEndomap) : IrreflexiveGraph</code>",
 "1114": "<code>(â†‘fâ‚).2 âŠš ğŸ™ X'.t = ğŸ™ Y'.t âŠš (â†‘fâ‚).1</code>",
 "1113":
 "<code>(â†‘fâ‚).2 âŠš (graphâ‚ X').toTgt = (graphâ‚ Y').toTgt âŠš (â†‘fâ‚).1</code>",
 "1112": "<code>(graphâ‚ X').tD</code>",
 "1111":
 "<code>âˆ€ x âˆˆ (graphâ‚ X').carrierD, (â†‘fâ‚).2 x âˆˆ (graphâ‚ Y').carrierD</code>",
 "1110": "<code>(graphâ‚ X').tA</code>",
 "111":
 "<code>CM.CM_Set.Point.{u_1} {Î² : Type u_1} (Y : Set Î²) : Type u_1</code>",
 "1109":
 "<code>âˆ€ x âˆˆ (graphâ‚ X').carrierA, (â†‘fâ‚).1 x âˆˆ (graphâ‚ Y').carrierA</code>",
 "1108":
 "<code>(â†‘fâ‚).2 âŠš (graphâ‚ X').toSrc = (graphâ‚ Y').toSrc âŠš (â†‘fâ‚).1</code>",
 "1107": "<code><span class=\"literal string\">\"fDâ‚\"</span> : String</code>",
 "1106": "<code><span class=\"literal string\">\"fAâ‚\"</span> : String</code>",
 "1105":
 "<code>quotPrecheck</code><span class=\"sep\"></span><code class=\"docstring\">Enable eager name analysis on notations in order to find unbound identifiers early.\nNote that type-sensitive syntax (\"elaborators\") needs special support for this kind of check, so it might need to be turned off when using such syntax.</code>",
 "1104":
 "<code class=\"docstring\">`set_option &lt;id&gt; &lt;value&gt;` sets the option `&lt;id&gt;` to `&lt;value&gt;`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `&lt;id&gt;` to list available options.\n\n`set_option &lt;id&gt; &lt;value&gt; in &lt;command&gt;` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option &lt;id&gt; &lt;value&gt; in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n</code>",
 "1103": "<code>graphâ‚ X' âŸ¶ graphâ‚ Y'</code>",
 "1102": "<code>âˆ€ {a : S.t}, a âˆˆ Set.univ â†’ S.toEnd a âˆˆ Set.univ</code>",
 "1101": "<code>âˆ€ {a : S.t}, a âˆˆ Set.univ â†’ ğŸ™ S.t a âˆˆ Set.univ</code>",
 "1100": "<code>S.t âŸ¶ S.t</code>",
 "110":
 "<code>CM.CM_Set.Map.maps_to_codomain.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} {X : Set Î±} {Y : Set Î²} (self : Map X Y)\n  (a : Î±) : a âˆˆ X â†’ self.toFun a âˆˆ Y</code>",
 "11": "<code>CM.ExI_1.B.bâ‚ƒ : B</code>",
 "1099": "<code>Set S.t</code>",
 "1098":
 "<code>CM.ExIII_13.graphâ‚ (S : SetWithEndomap) : IrreflexiveGraph</code>",
 "1097":
 "<code>CategoryTheory.Functor.map.{vâ‚, vâ‚‚, uâ‚, uâ‚‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚, uâ‚‚} D]\n  (self : C â¥¤ D) {X Y : C} : (X âŸ¶ Y) â†’ (self.obj X âŸ¶ self.obj Y)</code><span class=\"sep\"></span><code class=\"docstring\">The action of a functor on morphisms. </code>",
 "1096":
 "<code>CM.I {X Y : SetWithEndomap} (f : X âŸ¶ Y) :\n  functorSetWithEndomapToIrreflexiveGraph.obj X âŸ¶ functorSetWithEndomapToIrreflexiveGraph.obj Y</code>",
 "1095": "<code>f âŠš toEndX = toEndY âŠš f</code>",
 "1094": "<code>âˆ€ x âˆˆ carrierX, f x âˆˆ carrierY</code>",
 "1093": "<code>tX âŸ¶ tY</code>",
 "1092":
 "<code>{ t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t</code>",
 "1091":
 "<code>f âŠš { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.toEnd =\n  { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.toEnd âŠš f</code>",
 "1090":
 "<code>âˆ€ x âˆˆ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.carrier,\n  f x âˆˆ { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.carrier</code>",
 "109":
 "<code>CM.CM_Set.Map.toFun.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} {X : Set Î±} {Y : Set Î²} (self : Map X Y) : Î± â†’ Î²</code>",
 "1089":
 "<code>{ t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t âŸ¶\n  { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.t</code>",
 "1088":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierD := Set.univ,\n    toSrc := ğŸ™ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, toSrc_mem := â‹¯,\n    toTgt := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.toEnd, toTgt_mem := â‹¯ }.tD</code>",
 "1087":
 "<code>âˆ€ {a : { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.t},\n  a âˆˆ Set.univ â†’ { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.toEnd a âˆˆ Set.univ</code>",
 "1086":
 "<code>âˆ€ {a : { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.t},\n  a âˆˆ Set.univ â†’ ğŸ™ { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.t a âˆˆ Set.univ</code>",
 "1085":
 "<code>{ t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.t âŸ¶\n  { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.t</code>",
 "1084":
 "<code>Set { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }.t</code>",
 "1083":
 "<code>âˆ€ {a : { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t},\n  a âˆˆ Set.univ â†’ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.toEnd a âˆˆ Set.univ</code>",
 "1082":
 "<code>âˆ€ {a : { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t},\n  a âˆˆ Set.univ â†’ ğŸ™ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t a âˆˆ Set.univ</code>",
 "1081":
 "<code>{ t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t âŸ¶\n  { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t</code>",
 "1080":
 "<code>Set { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t</code>",
 "108": "<code>Set Î²</code>",
 "1079":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, carrierD := Set.univ,\n    toSrc := ğŸ™ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.t, toSrc_mem := â‹¯,\n    toTgt := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ }.toEnd, toTgt_mem := â‹¯ }.tA</code>",
 "1078": "<code>âˆ€ {a : tY}, a âˆˆ carrierY â†’ toEndY a âˆˆ carrierY</code>",
 "1077": "<code>tY âŸ¶ tY</code>",
 "1076": "<code>Set tY</code>",
 "1075":
 "<code>{ t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœÂ¹ } âŸ¶\n  { t := tY, carrier := carrierY, toEnd := toEndY, toEnd_mem := toEnd_memâœ }</code>",
 "1074": "<code>tY</code>",
 "1073": "<code>âˆ€ {a : tY}, a âˆˆ carrierY â†’ toEndY a âˆˆ carrierY</code>",
 "1072": "<code>tY âŸ¶ tY</code>",
 "1071": "<code>Set tY</code>",
 "1070":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierD := Set.univ,\n    toSrc := ğŸ™ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, toSrc_mem := â‹¯,\n    toTgt := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.toEnd, toTgt_mem := â‹¯ }.tD</code>",
 "107": "<code>Set Î±</code>",
 "1069":
 "<code>âˆ€ {a : { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t},\n  a âˆˆ Set.univ â†’ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.toEnd a âˆˆ Set.univ</code>",
 "1068":
 "<code>âˆ€ {a : { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t},\n  a âˆˆ Set.univ â†’ ğŸ™ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t a âˆˆ Set.univ</code>",
 "1067":
 "<code>{ t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t âŸ¶\n  { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t</code>",
 "1066":
 "<code>Set { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t</code>",
 "1065":
 "<code>{ tA := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierA := Set.univ,\n    tD := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, carrierD := Set.univ,\n    toSrc := ğŸ™ { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.t, toSrc_mem := â‹¯,\n    toTgt := { t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ }.toEnd, toTgt_mem := â‹¯ }.tA</code>",
 "1064": "<code>âˆ€ {a : tX}, a âˆˆ carrierX â†’ toEndX a âˆˆ carrierX</code>",
 "1063": "<code>tX âŸ¶ tX</code>",
 "1062": "<code>Set tX</code>",
 "1061":
 "<code>CM.SetWithEndomap.mk (t : Type) (carrier : Set t) (toEnd : t âŸ¶ t)\n  (toEnd_mem : âˆ€ {a : t}, a âˆˆ carrier â†’ toEnd a âˆˆ carrier) : SetWithEndomap</code>",
 "1060":
 "<code>{ t := tX, carrier := carrierX, toEnd := toEndX, toEnd_mem := toEnd_memâœ } âŸ¶ Y</code>",
 "106":
 "<code>CM.CM_Set.Map.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} (X : Set Î±) (Y : Set Î²) : Type (max u_1 u_2)</code>",
 "1059": "<code>tX</code>",
 "1058": "<code>âˆ€ {a : tX}, a âˆˆ carrierX â†’ toEndX a âˆˆ carrierX</code>",
 "1057": "<code>tX âŸ¶ tX</code>",
 "1056": "<code>Set tX</code>",
 "1055":
 "<code>{ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯, toTgt := X.toEnd,\n    toTgt_mem := â‹¯ }.tD</code>",
 "1054": "<code>âˆ€ {a : Y.t}, a âˆˆ Set.univ â†’ Y.toEnd a âˆˆ Set.univ</code>",
 "1053": "<code>âˆ€ {a : Y.t}, a âˆˆ Set.univ â†’ ğŸ™ Y.t a âˆˆ Set.univ</code>",
 "1052": "<code>Y.t âŸ¶ Y.t</code>",
 "1051": "<code>Set Y.t</code>",
 "1050":
 "<code>CategoryTheory.ConcreteCategory.hom.{w, v, u, u_1} {C : Type u} {instâœ : Category.{v, u} C}\n  {FC : outParam (C â†’ C â†’ Type u_1)} {CC : outParam (C â†’ Type w)}\n  {instâœÂ¹ : outParam ((X Y : C) â†’ FunLike (FC X Y) (CC X) (CC Y))} [self : ConcreteCategory C FC] {X Y : C} :\n  (X âŸ¶ Y) â†’ FC X Y</code><span class=\"sep\"></span><code class=\"docstring\">Convert a morphism of `C` to a bundled function. </code>",
 "105":
 "<code>Set.univ.{u} {Î± : Type u} : Set Î±</code><span class=\"sep\"></span><code class=\"docstring\">The universal set on a type `Î±` is the set containing all elements of `Î±`.\n\nThis is conceptually the \"same as\" `Î±` (in set theory, it is actually the same), but type theory\nmakes the distinction that `Î±` is a type while `Set.univ` is a term of type `Set Î±`. `Set.univ` can\nitself be coerced to a type `â†¥Set.univ` which is in bijection with (but distinct from) `Î±`. </code>",
 "1049":
 "<code>CM.IrreflexiveGraph.mk (tA : Type) (carrierA : Set tA) (tD : Type) (carrierD : Set tD) (toSrc : tA âŸ¶ tD)\n  (toSrc_mem : âˆ€ {a : tA}, a âˆˆ carrierA â†’ toSrc a âˆˆ carrierD) (toTgt : tA âŸ¶ tD)\n  (toTgt_mem : âˆ€ {a : tA}, a âˆˆ carrierA â†’ toTgt a âˆˆ carrierD) : IrreflexiveGraph</code>",
 "1048":
 "<code>{ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯, toTgt := X.toEnd,\n    toTgt_mem := â‹¯ }.tA</code>",
 "1047":
 "<code>(âˆ€\n    x âˆˆ\n      { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n          toTgt := X.toEnd, toTgt_mem := â‹¯ }.carrierA,\n    (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).1 x âˆˆ\n      { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n          toTgt := Y.toEnd, toTgt_mem := â‹¯ }.carrierA) âˆ§\n  (âˆ€\n      x âˆˆ\n        { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n            toTgt := X.toEnd, toTgt_mem := â‹¯ }.carrierD,\n      (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).2 x âˆˆ\n        { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n            toTgt := Y.toEnd, toTgt_mem := â‹¯ }.carrierD) âˆ§\n    (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).2 âŠš\n          { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n              toTgt := X.toEnd, toTgt_mem := â‹¯ }.toSrc =\n        { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n              toTgt := Y.toEnd, toTgt_mem := â‹¯ }.toSrc âŠš\n          (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).1 âˆ§\n      (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).2 âŠš\n          { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n              toTgt := X.toEnd, toTgt_mem := â‹¯ }.toTgt =\n        { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n              toTgt := Y.toEnd, toTgt_mem := â‹¯ }.toTgt âŠš\n          (â‡‘(ConcreteCategory.hom f), â‡‘(ConcreteCategory.hom f)).1</code><span class=\"sep\"></span><code class=\"docstring\">The proof that `val` satisfies the predicate `p`.\n</code>",
 "1046":
 "<code>({ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯, toTgt := X.toEnd,\n        toTgt_mem := â‹¯ }.tA âŸ¶\n    { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n        toTgt := Y.toEnd, toTgt_mem := â‹¯ }.tA) Ã—\n  ({ tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯, toTgt := X.toEnd,\n        toTgt_mem := â‹¯ }.tD âŸ¶\n    { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n        toTgt := Y.toEnd, toTgt_mem := â‹¯ }.tD)</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1045":
 "<code>{X Y : SetWithEndomap} â†’\n  (X âŸ¶ Y) â†’\n    { f //\n      (âˆ€\n          x âˆˆ\n            { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n                toTgt := X.toEnd, toTgt_mem := â‹¯ }.carrierA,\n          f.1 x âˆˆ\n            { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n                toTgt := Y.toEnd, toTgt_mem := â‹¯ }.carrierA) âˆ§\n        (âˆ€\n            x âˆˆ\n              { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n                  toTgt := X.toEnd, toTgt_mem := â‹¯ }.carrierD,\n            f.2 x âˆˆ\n              { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n                  toTgt := Y.toEnd, toTgt_mem := â‹¯ }.carrierD) âˆ§\n          f.2 âŠš\n                { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n                    toTgt := X.toEnd, toTgt_mem := â‹¯ }.toSrc =\n              { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n                    toTgt := Y.toEnd, toTgt_mem := â‹¯ }.toSrc âŠš\n                f.1 âˆ§\n            f.2 âŠš\n                { tA := X.t, carrierA := Set.univ, tD := X.t, carrierD := Set.univ, toSrc := ğŸ™ X.t, toSrc_mem := â‹¯,\n                    toTgt := X.toEnd, toTgt_mem := â‹¯ }.toTgt =\n              { tA := Y.t, carrierA := Set.univ, tD := Y.t, carrierD := Set.univ, toSrc := ğŸ™ Y.t, toSrc_mem := â‹¯,\n                    toTgt := Y.toEnd, toTgt_mem := â‹¯ }.toTgt âŠš\n                f.1 }</code><span class=\"sep\"></span><code class=\"docstring\">The action of a functor on morphisms. </code>",
 "1044": "<code>âˆ€ {a : X.t}, a âˆˆ Set.univ â†’ X.toEnd a âˆˆ Set.univ</code>",
 "1043": "<code>âˆ€ {a : X.t}, a âˆˆ Set.univ â†’ ğŸ™ X.t a âˆˆ Set.univ</code>",
 "1042": "<code>X.t âŸ¶ X.t</code>",
 "1041": "<code>Set X.t</code>",
 "1040":
 "<code>SetWithEndomap â†’ IrreflexiveGraph</code><span class=\"sep\"></span><code class=\"docstring\">The action of a functor on objects. </code>",
 "104":
 "<code>Set.{u} (Î± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A set is a collection of elements of some type `Î±`.\n\nAlthough `Set` is defined as `Î± â†’ Prop`, this is an implementation detail which should not be\nrelied on. Instead, `setOf` and membership of a set (`âˆˆ`) should be used to convert between sets\nand predicates.\n</code>",
 "1039":
 "<code>CategoryTheory.Functor.{vâ‚, vâ‚‚, uâ‚, uâ‚‚} (C : Type uâ‚) [Category.{vâ‚, uâ‚} C] (D : Type uâ‚‚) [Category.{vâ‚‚, uâ‚‚} D] :\n  Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)</code><span class=\"sep\"></span><code class=\"docstring\">`Functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality. </code>",
 "1038":
 "<code>CM.functorSetWithEndomapToIrreflexiveGraph : SetWithEndomap â¥¤ IrreflexiveGraph</code>",
 "1037": "<code>graph Y Q s' t' âŸ¶ graph Z R s'' t''</code>",
 "1036": "<code>graph X P s t âŸ¶ graph Y Q s' t'</code>",
 "1035": "<code>âˆ€ {a : A}, a âˆˆ Set.univ â†’ tgt a âˆˆ Set.univ</code>",
 "1034": "<code>âˆ€ {a : A}, a âˆˆ Set.univ â†’ src a âˆˆ Set.univ</code>",
 "1033": "<code>A âŸ¶ D</code>",
 "1032": "<code>Set D</code>",
 "1031": "<code>Set A</code>",
 "1030": "<code>A âŸ¶ D</code>",
 "103": "<code>CM.CM_Set.One : Set Unit</code>",
 "1029":
 "<code>CM.ExIII_11.graph (A D : Type) (src tgt : A âŸ¶ D) : IrreflexiveGraph</code>",
 "1028": "<code>gD âŠš t' = t'' âŠš gA</code>",
 "1027": "<code>gD âŠš s' = s'' âŠš gA</code>",
 "1026": "<code>fD âŠš t = t' âŠš fA</code>",
 "1025": "<code>fD âŠš s = s' âŠš fA</code>",
 "1024": "<code>Q âŸ¶ R</code>",
 "1023": "<code>P âŸ¶ Q</code>",
 "1022": "<code>Z âŸ¶ R</code>",
 "1021": "<code>Y âŸ¶ Q</code>",
 "1020": "<code>X âŸ¶ P</code>",
 "102": "<code>âˆ€ a âˆˆ One, \"eggs\" âˆˆ B</code>",
 "1019": "<code>x âˆˆ Xâœ.carrierD</code>",
 "1018": "<code>x âˆˆ Xâœ.carrierA</code>",
 "1017": "<code>g.2 âŠš Yâœ.toTgt = Zâœ.toTgt âŠš g.1</code>",
 "1016": "<code>g.2 âŠš Yâœ.toSrc = Zâœ.toSrc âŠš g.1</code>",
 "1015": "<code>âˆ€ x âˆˆ Yâœ.carrierD, g.2 x âˆˆ Zâœ.carrierD</code>",
 "1014": "<code>âˆ€ x âˆˆ Yâœ.carrierA, g.1 x âˆˆ Zâœ.carrierA</code>",
 "1013": "<code>f.2 âŠš Xâœ.toTgt = Yâœ.toTgt âŠš f.1</code>",
 "1012": "<code>f.2 âŠš Xâœ.toSrc = Yâœ.toSrc âŠš f.1</code>",
 "1011": "<code>âˆ€ x âˆˆ Xâœ.carrierD, f.2 x âˆˆ Yâœ.carrierD</code>",
 "1010": "<code>âˆ€ x âˆˆ Xâœ.carrierA, f.1 x âˆˆ Yâœ.carrierA</code>",
 "101": "<code>CM.CM_Finset.eggs : Point B</code>",
 "1009": "<code>(Xâœ.tA âŸ¶ Zâœ.tA) Ã— (Xâœ.tD âŸ¶ Zâœ.tD)</code>",
 "1008": "<code>Yâœ.tD</code>",
 "1007": "<code>Yâœ.tA</code>",
 "1006": "<code>Xâœ.tD</code>",
 "1005": "<code>Xâœ.tA</code>",
 "1004":
 "<code>Prod.{u, v} (Î± : Type u) (Î² : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The product type, usually written `Î± Ã— Î²`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `Î±` and the second element is a\n`Î²`.\n\nProducts nest to the right, so `(x, y, z) : Î± Ã— Î² Ã— Î³` is equivalent to `(x, (y, z)) : Î± Ã— (Î² Ã— Î³)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `Ã—` in identifiers is `Prod`.</code>",
 "1003":
 "<code>(âˆ€ x âˆˆ Yâœ.carrierA, g.1 x âˆˆ Zâœ.carrierA) âˆ§\n  (âˆ€ x âˆˆ Yâœ.carrierD, g.2 x âˆˆ Zâœ.carrierD) âˆ§ g.2 âŠš Yâœ.toSrc = Zâœ.toSrc âŠš g.1 âˆ§ g.2 âŠš Yâœ.toTgt = Zâœ.toTgt âŠš g.1</code>",
 "1002": "<code>(Yâœ.tA âŸ¶ Zâœ.tA) Ã— (Yâœ.tD âŸ¶ Zâœ.tD)</code>",
 "1001":
 "<code>(âˆ€ x âˆˆ Xâœ.carrierA, f.1 x âˆˆ Yâœ.carrierA) âˆ§\n  (âˆ€ x âˆˆ Xâœ.carrierD, f.2 x âˆˆ Yâœ.carrierD) âˆ§ f.2 âŠš Xâœ.toSrc = Yâœ.toSrc âŠš f.1 âˆ§ f.2 âŠš Xâœ.toTgt = Yâœ.toTgt âŠš f.1</code>",
 "1000": "<code>(Xâœ.tA âŸ¶ Yâœ.tA) Ã— (Xâœ.tD âŸ¶ Yâœ.tD)</code>",
 "100":
 "<code>Or.inr {a b : Prop} (h : b) : a âˆ¨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. </code>",
 "10": "<code>CM.ExI_1.B.bâ‚‚ : B</code>",
 "1": "<code><span class=\"literal string\">\" âŠš \"</span> : String</code>",
 "0": "<code>Lean.TSyntax `term</code>"}