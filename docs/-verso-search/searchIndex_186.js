window.docContents[186].resolve({"/Article-I___-Sets___-maps___-composition/#A-Lean-Companion-to-Conceptual-Mathematics--Article-I___-Sets___-maps___-composition":{"contents":"\n\n\n\nUntil the introduction of the definition of category at the end of Article I, we implement all maps in the book as Lean functions.\n\nCheck to be sure you understand how we got diagrams (ii) and (iii) from the given diagram (i). Then fill in (iv) and (v) yourself, starting over from (i). Then check to see that (v) and (iii) are the same.\n\nFor simplicity, we use types here instead of sets. We number the elements in each set/type from top to bottom (top left to bottom right for D).inductive A\n  | aâ‚ | aâ‚‚ | aâ‚ƒ\n\ninductive B\n  | bâ‚ | bâ‚‚ | bâ‚ƒ | bâ‚„\n\ninductive C\n  | câ‚ | câ‚‚ | câ‚ƒ | câ‚„ | câ‚…\n\ninductive D\n  | dâ‚ | dâ‚‚ | dâ‚ƒ | dâ‚„ | dâ‚… | dâ‚†\n\ndef f : A â†’ B\n  | A.aâ‚ => B.bâ‚\n  | A.aâ‚‚ => B.bâ‚‚\n  | A.aâ‚ƒ => B.bâ‚ƒ\n\ndef g : B â†’ C\n  | B.bâ‚ => C.câ‚‚\n  | B.bâ‚‚ => C.câ‚‚\n  | B.bâ‚ƒ => C.câ‚„\n  | B.bâ‚„ => C.câ‚…\n\ndef h : C â†’ D\n  | C.câ‚ => D.dâ‚\n  | C.câ‚‚ => D.dâ‚\n  | C.câ‚ƒ => D.dâ‚ƒ\n  | C.câ‚„ => D.dâ‚ƒ\n  | C.câ‚… => D.dâ‚…\nFor diagram (iv), we have f as above and {h \\circ g} as follows:def hg : B â†’ D\n  | B.bâ‚ => D.dâ‚\n  | B.bâ‚‚ => D.dâ‚\n  | B.bâ‚ƒ => D.dâ‚ƒ\n  | B.bâ‚„ => D.dâ‚…\n\nexample : hg = h âˆ˜ g := by\n  funext x\n  cases x <;> dsimp [g, h, hg]\nFor diagram (v), we have {(h \\circ g) \\circ f} as follows, which is indeed the same as {h \\circ (g \\circ f)} in diagram (iii):def hgf : A â†’ D\n  | A.aâ‚ => D.dâ‚\n  | A.aâ‚‚ => D.dâ‚\n  | A.aâ‚ƒ => D.dâ‚ƒ\n\nexample : hgf = (h âˆ˜ g) âˆ˜ f := by\n  funext x\n  cases x <;> dsimp [f, g, h, hgf]\n\n\nOne very useful sort of set is a 'singleton' set, a set with exactly one element.... Call this set '\\mathbf{1}'.\n\nWe define \\mathbf{1} in Lean as the finite set containing the single element of type Unit.\n\n\n\nnamespace CM_Finset\n\ndef One : Finset Unit := Finset.univ\n\nend CM_Finset\n\n\nA point of a set X is a map {\\mathbf{1} \\rightarrow X}.\n\nWe define Point in Lean as a Map between Finsets. (The coercion allows a term inhabiting Map to be used directly as a function, so we can write f, John, and eggs below rather than f.toFun, John.toFun, and eggs.toFun.)\n\n\n\nnamespace CM_Finset\n\nstructure Map {Î± Î² : Type*} (X : Finset Î±) (Y : Finset Î²) where\n  toFun : Î± â†’ Î²\n  maps_to_codomain : âˆ€ a : Î±, a âˆˆ X â†’ toFun a âˆˆ Y\n\ninstance {Î± Î² : Type*} (X : Finset Î±) (Y : Finset Î²)\n    : CoeFun (Map X Y) (fun _ â†¦ Î± â†’ Î²) where\n  coe F := F.toFun\n\nabbrev Point {Î² : Type*} (Y : Finset Î²) := Map One Y\n\nend CM_Finset\n\n\nSince a point is a map, we can compose it with another map, and get a point again.\n\nWe provide a Lean implementation below of the example given in the book on p. 19.\n\nnamespace CM_Finset\n\ndef A : Finset String := { \"John\", \"Mary\", \"Sam\" }\ndef B : Finset String := { \"eggs\", \"coffee\" }\n\ndef John : Point A := {\n  toFun := fun _ â†¦ \"John\"\n  maps_to_codomain := by simp [A]\n}\n\ndef f : Map A B := {\n  toFun\n    | \"John\" => \"eggs\"\n    | \"Mary\" => \"eggs\"\n    | _ => \"coffee\"\n  maps_to_codomain := by\n    intro _ ha\n    dsimp [A, B] at *\n    repeat rw [Finset.mem_insert] at *\n    rw [Finset.mem_singleton] at *\n    rcases ha with ha | ha | ha\n    all_goals (\n      subst ha\n      first | exact Or.inl rfl | exact Or.inr rfl\n    )\n}\n\ndef eggs : Point B := {\n  toFun := fun _ â†¦ \"eggs\"\n  maps_to_codomain := by simp [B]\n}\n\nexample : f âˆ˜ John = eggs := rfl\n\nend CM_Finset\n\n\nnamespace CM_Set\n\ndef One : Set Unit := Set.univ\n\nstructure Map {Î± Î² : Type*} (X : Set Î±) (Y : Set Î²) where\n  toFun : Î± â†’ Î²\n  maps_to_codomain : âˆ€ a : Î±, a âˆˆ X â†’ toFun a âˆˆ Y\n\ninstance {Î± Î² : Type*} (X : Set Î±) (Y : Set Î²)\n    : CoeFun (Map X Y) (fun _ â†¦ Î± â†’ Î²) where\n  coe F := F.toFun\n\nabbrev Point {Î² : Type*} (Y : Set Î²) := Map One Y\n\ndef A : Set String := { \"John\", \"Mary\", \"Sam\" }\ndef B : Set String := { \"eggs\", \"coffee\" }\n\ndef John : Point A := {\n  toFun := fun _ â†¦ \"John\"\n  maps_to_codomain := by simp [A]\n}\n\ndef f : Map A B := {\n  toFun\n    | \"John\" => \"eggs\"\n    | \"Mary\" => \"eggs\"\n    | _ => \"coffee\"\n  maps_to_codomain := by\n    intro _ ha\n    dsimp [A, B] at *\n    repeat rw [Set.mem_insert_iff] at *\n    rw [Set.mem_singleton_iff] at *\n    rcases ha with ha | ha | ha\n    all_goals (\n      subst ha\n      first | exact Or.inl rfl | exact Or.inr rfl\n    )\n}\n\ndef eggs : Point B := {\n  toFun := fun _ â†¦ \"eggs\"\n  maps_to_codomain := by simp [B]\n}\n\nexample : f âˆ˜ John = eggs := rfl\n\nend CM_Set\n\n\ndef One := Unit\n\nnamespace CM_Type\n\ndef Point (Y : Type) := One â†’ Y\n\ndef A := { a : String // a = \"John\" âˆ¨ a = \"Mary\" âˆ¨ a = \"Sam\" }\ndef B := { b : String // b = \"eggs\" âˆ¨ b = \"coffee\" }\n\ndef John : Point A := fun _ â†¦ âŸ¨\"John\", by simpâŸ©\n\ndef f : A â†’ B := fun a â†¦\n  match a.val with\n  | \"John\" => âŸ¨\"eggs\", by simpâŸ©\n  | \"Mary\" => âŸ¨\"eggs\", by simpâŸ©\n  | _ => âŸ¨\"coffee\", by simpâŸ©\n\ndef eggs : Point B := fun _ â†¦ âŸ¨\"eggs\", by simpâŸ©\n\nexample : f âˆ˜ John = eggs := rfl\n\nend CM_Type\n\n\nWe lift our definition for the function Point between types to the morphism Point in the category Type for later use. Note the application of âŸ¶ (\\hom) for the morphism type instead of â†’ (\\r) for the function arrow.\n\n\n\ndef Point (Y : Type) := One âŸ¶ Y\n\n\nFor Exercises 2â€“5 which follow, rather than providing exhaustive lists of maps, it seems more useful at this stage to introduce what the book calls Alysia's formula, even though that formula doesn't appear until slightly later (on pp. 33â€“34). The formula states that the number of different maps between two finite sets is equal to the number of elements in the codomain raised to the power of the number of elements in the domain â€” that is, the number of maps is {(\\#\\beta)^{(\\#\\alpha)}}, where {\\#\\alpha} is the size of the domain \\alpha and {\\#\\beta} is the size of the codomain \\beta.\n\n\n\ndef Alysia's_formula (Î± Î² : Type*) [Fintype Î±] [Fintype Î²] : â„• :=\n  Fintype.card Î² ^ Fintype.card Î±\n\n\nHow many different maps f are there with domain A and codomain B?\n\nBy Alysia's formula, we have {(\\#B)^{(\\#A)} = 2^3 = 8} different maps.open CM_Finset\n\n#eval Alysia's_formula A B\n8\n\n\nSame, but for maps {A \\xrightarrow{f} A}?\n\nBy Alysia's formula, we have {(\\#A)^{(\\#A)} = 3^3 = 27} different maps.open CM_Finset\n\n#eval Alysia's_formula A A\n27\n\n\nSame, but for maps {B \\xrightarrow{f} A}?\n\nBy Alysia's formula, we have {(\\#A)^{(\\#B)} = 3^2 = 9} different maps.open CM_Finset\n\n#eval Alysia's_formula B A\n9\n\n\nSame, but for maps {B \\xrightarrow{f} B}?\n\nBy Alysia's formula, we have {(\\#B)^{(\\#B)} = 2^2 = 4} different maps.open CM_Finset\n\n#eval Alysia's_formula B B\n4\n\n\nExercises 6 and 7 concern idempotence, which the book formally introduces later on p. 54. For the purpose of these two exercises (and again aiming to avoid exhaustive lists of maps), we introduce the formula\n\\sum_{k=0}^{n} {n \\choose k} k^{n-k}\nfor the total number of possible idempotents on a finite set. (See the Wikipedia article on idempotence for additional information.)\n\n\n\ndef idempotentCount (Î± : Type) [Fintype Î±] : â„• :=\n  let n := Fintype.card Î±\n  âˆ‘ k âˆˆ Finset.range (n + 1), (n.choose k) * k ^ (n - k)\n\n\nHow many maps {A \\xrightarrow{f} A} satisfy {f \\circ f = f}?\n\nBy the formula above, we have 10 different maps.open CM_Finset\n\n#eval idempotentCount A\n10\n\n\nHow many maps {B \\xrightarrow{g} B} satisfy {g \\circ g = g}?\n\nBy the formula above, we have 3 different maps.open CM_Finset\n\n#eval idempotentCount B\n3\n\n\nCan you find a pair of maps {A \\xrightarrow{f} B \\xrightarrow{g} A} for which {g \\circ f = 1_A}? If so, how many such pairs?\n\nNo such pair exists, since the image of 1_A has 3 elements, but the image of {g \\circ f} has only 2 elements.open CM_Finset\nWe will begin using the Lean notation ðŸ™ X, for the identity morphism on X, after we finish Article I and start working with morphisms and categories; for now, though, since we are still operating with functions and sets, we must define the identity map on A explicitly.def idA : Map A A := {\n  toFun := id\n  maps_to_codomain := by\n    intro _ ha\n    dsimp [A] at *\n    repeat rw [Finset.mem_insert] at *\n    rw [Finset.mem_singleton] at *\n    rcases ha with ha | ha | ha\n    all_goals (\n      subst ha\n      first\n      | exact Or.inl rfl\n      | exact Or.inr (Or.inl rfl)\n      | exact Or.inr (Or.inr rfl)\n    )\n}\n\nopen Finset in\nexample : Â¬(âˆƒ f : Map A B, âˆƒ g : Map B A, g âˆ˜ f = idA) := by\n  -- Convert to the equivalent statement âˆ€ f g, g âˆ˜ f â‰  idA\n  push_neg\n  -- Assume that g âˆ˜ f = idA for some f, g, and derive a contradiction\n  intro f g h_eq\n  -- Since the functions g âˆ˜ f and idA are equal, so are their images\n  have h_img_eq\n      : (image g (image f A)).card = (image idA A).card := by\n    rw [image_image, h_eq]\n  -- But the image of g(f(A)) has at most 2 elements,\n  have h_card_gfA : (image g (image f A)).card â‰¤ 2 := by\n    apply le_trans\n    Â· exact card_image_le\n    Â· change (image f A).card â‰¤ B.card\n      apply card_le_card\n      intro _ hfa\n      rw [mem_image] at hfa\n      obtain âŸ¨a, ha, rflâŸ© := hfa\n      exact f.maps_to_codomain a ha\n  -- while the image of idA(A) has 3 elements\n  have h_card_idA : (image idA A).card = 3 := rfl\n  -- So we have a contradiction\n  rw [h_img_eq, h_card_idA] at h_card_gfA\n  contradiction\n\n\nCan you find a pair of maps {B \\xrightarrow{h} A \\xrightarrow{k} B} for which {k \\circ h = 1_B}? If so, how many such pairs?\n\nWe define one pair h, k.open CM_Finset\n\ndef h : Map B A := {\n  toFun\n    | \"eggs\" => \"John\"\n    | _ => \"Mary\"\n  maps_to_codomain := by\n    intro _ hb\n    dsimp [A, B] at *\n    repeat rw [Finset.mem_insert] at *\n    rw [Finset.mem_singleton] at *\n    rcases hb with hb | hb\n    all_goals (\n      subst hb\n      first | exact Or.inl rfl | exact Or.inr (Or.inl rfl)\n    )\n}\n\ndef k : Map A B := {\n  toFun\n    | \"John\" => \"eggs\"\n    | _ => \"coffee\"\n  maps_to_codomain := by\n    intro _ ha\n    dsimp [A, B] at *\n    repeat rw [Finset.mem_insert] at *\n    rw [Finset.mem_singleton] at *\n    rcases ha with ha | ha | ha\n    all_goals (\n      subst ha\n      first | exact Or.inl rfl | exact Or.inr rfl\n    )\n}\nWe define the identity map on B explicitly (see the earlier comment under Exercise 8).def idB : Map B B := {\n  toFun\n    | \"eggs\" => \"eggs\"\n    | _ => \"coffee\"\n  maps_to_codomain := by\n    intro _ hb\n    dsimp [B] at *\n    rw [Finset.mem_insert, Finset.mem_singleton] at *\n    rcases hb with hb | hb\n    all_goals (\n      subst hb\n      first | exact Or.inl rfl | exact Or.inr rfl\n    )\n}\nA proof that {k âˆ˜ h = 1_B} holds for our pair h, k is given below. (We define a macro for a repeated sequence of tactics to keep the proof concise.)syntax \"eval_map\" Lean.Parser.Tactic.rwRule : tactic\n\nmacro_rules\n  | `(tactic| eval_map $fn_name) =>\n    `(tactic| (\n        rw [$fn_name]\n        dsimp only [DFunLike.coe]\n        split\n        Â· contradiction\n        Â· rfl\n      )\n    )\n\nexample : k âˆ˜ h = idB := by\n  funext x\n  rw [Function.comp_apply]\n  by_cases h_x_eggs : x = \"eggs\"\n  Â· rw [h_x_eggs]\n    have h_eval : h \"eggs\" = \"John\" := rfl\n    have k_eval : k \"John\" = \"eggs\" := rfl\n    have idB_eval : idB \"eggs\" = \"eggs\" := rfl\n    rw [h_eval, k_eval, idB_eval]\n  Â· have h_eval : h x = \"Mary\" := by eval_map h\n    have k_eval : k \"Mary\" = \"coffee\" := by eval_map k\n    have idB_eval : idB x = \"coffee\" := by eval_map idB\n    rw [h_eval, k_eval, idB_eval]\nThere are 12 such pairs: h(\\mathit{eggs}) can take any one of three distinct values in A, leaving h(\\mathit{coffee}) to take one of the two remaining values, which together gives {3 \\times 2 = 6} combinations; and for each combination, k can map the element in A that is not in the image of h to either \\mathit{eggs} or \\mathit{coffee}.\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics","header":"Article I: Sets, maps, composition","id":"/Article-I___-Sets___-maps___-composition/#A-Lean-Companion-to-Conceptual-Mathematics--Article-I___-Sets___-maps___-composition"}});