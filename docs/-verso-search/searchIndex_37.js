window.docContents[37].resolve({"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--7___-The-simpler-category-_________-Objects-are-just-maps-of-sets":{"contents":"The category ğ‘ºâ†“ of simple directed graphs is described on pp. 144â€“145. We implement the category ğ‘ºâ†“ below.\n\n\n\nstructure SimpleGraph where\n  tA : Type\n  carrierA : Set tA\n  tD : Type\n  carrierD : Set tD\n  toFun : tA âŸ¶ tD\n  toFun_mem {a} : a âˆˆ carrierA â†’ toFun a âˆˆ carrierD\n\ninstance : Category SimpleGraph where\n  Hom X Y := {\n    f : (X.tA âŸ¶ Y.tA) Ã— (X.tD âŸ¶ Y.tD) //\n        (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Y.carrierA) -- fA maps to codomain\n        âˆ§ (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Y.carrierD) -- fD maps to codomain\n        âˆ§ f.2 âŠš X.toFun = Y.toFun âŠš f.1 -- commutes\n  }\n  id X := âŸ¨\n    (ğŸ™ X.tA, ğŸ™ X.tD),\n    by\n      split_ands <;> first | exact fun _ hx â†¦ hx | rfl\n  âŸ©\n  comp := by\n    rintro _ _ _ âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©\n    exact âŸ¨\n      (g.1 âŠš f.1, g.2 âŠš f.2),\n      by\n        obtain âŸ¨hfA_mtc, hfD_mtc, hfSrc_commâŸ© := hf\n        obtain âŸ¨hgA_mtc, hgD_mtc, hgSrc_commâŸ© := hg\n        split_ands\n        Â· intro x hx\n          exact hgA_mtc (f.1 x) (hfA_mtc x hx)\n        Â· intro x hx\n          exact hgD_mtc (f.2 x) (hfD_mtc x hx)\n        Â· rw [â† Category.assoc, hfSrc_comm, Category.assoc, hgSrc_comm,\n              â† Category.assoc]\n    âŸ©\n\n\nThe insertion J is a functor from ğ‘ºâ†» to ğ‘ºâ†“.\n\ndef functorSetWithEndomapToSimpleGraph\n    : Functor SetWithEndomap SimpleGraph := {\n  obj (X : SetWithEndomap) := {\n    tA := X.t\n    carrierA := Set.univ\n    tD := X.t\n    carrierD := Set.univ\n    toFun := X.toEnd\n    toFun_mem := fun _ â†¦ Set.mem_univ _\n  }\n  map {X Y : SetWithEndomap} (f : X âŸ¶ Y) := {\n    val := (f, f)\n    property := by\n      obtain âŸ¨tX, carrierX, toEndXâŸ© := X\n      obtain âŸ¨tY, carrierY, toEndYâŸ© := Y\n      obtain âŸ¨f, hf_mtc, hf_commâŸ© := f\n      dsimp at f hf_mtc hf_comm\n      split_ands <;> (dsimp; intros; trivial)\n  }\n}\n\n-- Helper function to align to the notation in the book\ndef J {X Y : SetWithEndomap} (f : X âŸ¶ Y) :=\n  functorSetWithEndomapToSimpleGraph.map f\n\nexample {X Y Z : SetWithEndomap}\n    (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : J (g âŠš f) = J g âŠš J f := rfl\n\n\nGive an example of ğ‘º of two endomaps and two maps as in\nX \\xrightarrow{f_A} Y,\\; X \\xrightarrow{f_D} Y,\\; X \\xrightarrow{\\alpha} X,\\; Y \\xrightarrow{\\beta} Y\nwhich satisfy the equation {f_D \\circ \\alpha = \\beta \\circ f_A}, but for which {f_A \\ne f_D}.\n\nWe give X, Y, \\alpha, \\beta, f_A, f_D as follows:inductive X\n  | xâ‚ | xâ‚‚\n\ninductive Y\n  | yâ‚ | yâ‚‚\n\ndef Î± : X âŸ¶ X\n  | X.xâ‚ => X.xâ‚\n  | X.xâ‚‚ => X.xâ‚\n\ndef Î² : Y âŸ¶ Y\n  | Y.yâ‚ => Y.yâ‚\n  | Y.yâ‚‚ => Y.yâ‚\n\ndef fA : X âŸ¶ Y\n  | X.xâ‚ => Y.yâ‚\n  | X.xâ‚‚ => Y.yâ‚‚\n\ndef fD : X âŸ¶ Y\n  | X.xâ‚ => Y.yâ‚\n  | X.xâ‚‚ => Y.yâ‚\nWe show that our example satisfies the required properties.example : fD âŠš Î± = Î² âŠš fA âˆ§ fA â‰  fD := by\n  constructor\n  Â· funext x\n    cases x <;> rfl\n  Â· by_contra h\n    have h_contra : fA X.xâ‚‚ = fD X.xâ‚‚ := congrFun h X.xâ‚‚\n    dsimp [fA, fD] at h_contra\n    contradiction\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article III: Examples of categories","header":"7. The simpler category ğ‘ºâ†“: Objects are just maps of sets","id":"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--7___-The-simpler-category-_________-Objects-are-just-maps-of-sets"}});