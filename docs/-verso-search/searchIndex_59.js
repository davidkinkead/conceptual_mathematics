window.docContents[59].resolve({"/Session-12___-Categories-of-diagrams/#A-Lean-Companion-to-Conceptual-Mathematics--Session-12___-Categories-of-diagrams--1___-Dynamical-systems-or-automata":{"contents":"Suppose that {x' = \\alpha^3(x)} and that {X^{‚Üª\\alpha} \\xrightarrow{f} Y^{‚Üª\\beta}} is a map in ùë∫‚Üª. Let {y = f(x)} and {y' = \\beta^3(y)}. Prove that {f(x') = y'}.\n\nWe proceed by repeatedly applying the property {f \\circ \\alpha = \\beta \\circ f}.example {XŒ± YŒ≤ : SetWithEndomap} (f : XŒ± ‚ü∂ YŒ≤)\n    {x x' : XŒ±.t} {y y' : YŒ≤.t}\n    (hx' : x' = (XŒ±.toEnd ‚äö XŒ±.toEnd ‚äö XŒ±.toEnd) x)\n    (hy : y = f.val x)\n    (hy' : y' = (YŒ≤.toEnd ‚äö YŒ≤.toEnd ‚äö YŒ≤.toEnd) y)\n    : f.val x' = y' := by\n  have hf_comm := f.property.2\n  rw [hy', hy]\n  rw [‚Üê types_comp_apply f.val (YŒ≤.toEnd ‚äö YŒ≤.toEnd ‚äö YŒ≤.toEnd)]\n  rw [‚Üê Category.assoc, ‚Üê Category.assoc]\n  rw [‚Üê hf_comm]\n  rw [Category.assoc XŒ±.toEnd]\n  rw [‚Üê hf_comm]\n  rw [Category.assoc, Category.assoc]\n  rw [‚Üê hf_comm]\n  rw [‚Üê Category.assoc, ‚Üê Category.assoc]\n  rw [types_comp_apply]\n  rw [hx']\n\n\n'With age comes stability'. In a finite dynamical system, every state eventually settles into a cycle....For two units of time, x is living on the fringes, but after that he settles into an organized periodic behaviour, repeating the same routine every four units of time. What about y and z? Don‚Äôt take the title seriously; humans can change the system! This sort of thing applies to light bulbs, though. If a particular light bulb can only be lit four times before burning out, after which pressing the on‚Äîoff button has no effect, draw the automaton modeling its behavior.\n\nThe automaton modelling the behaviour of a light bulb that can only be lit four times before burning out may be represented as follows:inductive BulbState\n  | off‚ÇÄ | on‚ÇÅ | off‚ÇÅ | on‚ÇÇ | off‚ÇÇ | on‚ÇÉ | off‚ÇÉ | on‚ÇÑ | burntOut\n  deriving Fintype, DecidableEq\n\nopen BulbState\n\ndef pressButton : BulbState ‚ü∂ BulbState\n  | off‚ÇÄ => on‚ÇÅ -- lit 1st time\n  | on‚ÇÅ  => off‚ÇÅ\n  | off‚ÇÅ => on‚ÇÇ -- lit 2nd time\n  | on‚ÇÇ  => off‚ÇÇ\n  | off‚ÇÇ => on‚ÇÉ -- lit 3rd time\n  | on‚ÇÉ  => off‚ÇÉ\n  | off‚ÇÉ => on‚ÇÑ -- lit 4th time\n  | on‚ÇÑ  => burntOut\n  | burntOut => burntOut\nTo verify correct operation, we begin by setting up a simulation of pressing the on-off button eight times, starting from off‚ÇÄ, and counting how many times the bulb lights up.abbrev LitCount := Nat\n\ndef LitStates : List BulbState := [on‚ÇÅ, on‚ÇÇ, on‚ÇÉ, on‚ÇÑ]\n\ndef pressAndCount (this : BulbState) : StateM LitCount BulbState := do\n  let next := pressButton this\n  if next ‚àà LitStates then\n    modify (¬∑ + 1)\n  return next\n\ndef EightPresses : List Unit := List.replicate 8 ()\n\ndef simulateEightPresses : StateM LitCount BulbState :=\n  EightPresses.foldlM (fun s _ ‚Ü¶ pressAndCount s) off‚ÇÄ\nRun the simulation starting with a lit count of 0, and return the final bulb state and lit count.def getResult : BulbState √ó LitCount := simulateEightPresses.run 0\nConfirm that at the end of the run, the bulb has been lit four times and is now burntOut.example : getResult = (burntOut, 4) := rfl\nLastly, confirm that once the bulb is burntOut, pressing the on‚Äîoff button has no effect (i.e., burntOut is a fixed point).example : Function.IsFixedPt pressButton burntOut := rfl\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 12: Categories of diagrams","header":"1. Dynamical systems or automata","id":"/Session-12___-Categories-of-diagrams/#A-Lean-Companion-to-Conceptual-Mathematics--Session-12___-Categories-of-diagrams--1___-Dynamical-systems-or-automata"}});