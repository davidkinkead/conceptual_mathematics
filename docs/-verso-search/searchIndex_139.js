window.docContents[139].resolve({"/Session-11___-Ascending-to-categories-of-richer-structures/#A-Lean-Companion-to-Conceptual-Mathematics--Session-11___-Ascending-to-categories-of-richer-structures--3___-The-category-of-graphs":{"contents":"inductive X\n  | a | b | c\n\ndef Î± : X âŸ¶ X\n  | X.a => X.c\n  | X.b => X.a\n  | X.c => X.b\n\ndef XÎ± : SetWithEndomap := {\n  t := X\n  carrier := Set.univ\n  toEnd := Î±\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\ninductive Y\n  | p | q | r\n\ndef Î² : Y âŸ¶ Y\n  | Y.p => Y.q\n  | Y.q => Y.r\n  | Y.r => Y.p\n\ndef YÎ² : SetWithEndomap := {\n  t := Y\n  carrier := Set.univ\n  toEnd := Î²\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\nFind an isomorphism from X^{â†»\\alpha} to Y^{â†»\\beta}. How many such isomorphisms are there?Hint: You need to find {X \\xrightarrow{f} Y} such that {f \\alpha = \\beta f}, and check that f has an inverse {Y \\xrightarrow{f^{-1}} X} (meaning {f^{-1}f = 1_X} and {ff^{-1} = 1_Y}). Then you'll still need to check that f^{-1} is a map in ğ‘ºâ†» (meaning {f^{-1} \\beta = \\alpha f^{-1}}), but see Exercise 4, below.\n\nThere are three such isomorphisms, which we call f_1, f_2, f_3 below.def fâ‚ : X âŸ¶ Y\n  | X.a => Y.r\n  | X.b => Y.q\n  | X.c => Y.p\n\n--fâ‚ is an isomorphism\nexample : âˆƒ f : XÎ± âŸ¶ YÎ², IsIso f := by\n  let f : XÎ± âŸ¶ YÎ² := âŸ¨\n    fâ‚,\n    by\n      constructor\n      Â· exact fun _ _ â†¦ Set.mem_univ _\n      Â· -- fÎ± = Î²f\n        funext x\n        cases x <;> rfl\n  âŸ©\n  let finv : YÎ² âŸ¶ XÎ± := âŸ¨\n    fun\n      | Y.p => X.c\n      | Y.q => X.b\n      | Y.r => X.a,\n    by\n      constructor\n      Â· exact fun _ _ â†¦ Set.mem_univ _\n      Â· -- fâ»Â¹Î² = Î±fâ»Â¹\n        funext y\n        cases y <;> rfl\n  âŸ©\n  use f\n  use finv\n  constructor\n  Â· -- fâ»Â¹f = ğŸ™ X\n    have h : finv.val âŠš f.val = ğŸ™ X := by\n      funext x\n      cases x <;> rfl\n    exact Subtype.eq h\n  Â· -- ffâ»Â¹ = ğŸ™ Y\n    have h : f.val âŠš finv.val = ğŸ™ Y := by\n      funext y\n      cases y <;> rfl\n    exact Subtype.eq h\n\ndef fâ‚‚ : X âŸ¶ Y\n  | X.a => Y.q\n  | X.b => Y.p\n  | X.c => Y.r\n\n--fâ‚‚ is an isomorphism\nexample : âˆƒ f : XÎ± âŸ¶ YÎ², IsIso f := by\n  let f : XÎ± âŸ¶ YÎ² := âŸ¨\n    fâ‚‚,\n    by\n      constructor\n      Â· exact fun _ _ â†¦ Set.mem_univ _\n      Â· -- fÎ± = Î²f\n        funext x\n        cases x <;> rfl\n  âŸ©\n  let finv : YÎ² âŸ¶ XÎ± := âŸ¨\n    fun\n      | Y.p => X.b\n      | Y.q => X.a\n      | Y.r => X.c,\n    by\n      constructor\n      Â· exact fun _ _ â†¦ Set.mem_univ _\n      Â· -- fâ»Â¹Î² = Î±fâ»Â¹\n        funext y\n        cases y <;> rfl\n  âŸ©\n  use f\n  use finv\n  constructor\n  Â· -- fâ»Â¹f = ğŸ™ X\n    have h : finv.val âŠš f.val = ğŸ™ X := by\n      funext x\n      cases x <;> rfl\n    exact Subtype.eq h\n  Â· -- ffâ»Â¹ = ğŸ™ Y\n    have h : f.val âŠš finv.val = ğŸ™ Y := by\n      funext y\n      cases y <;> rfl\n    exact Subtype.eq h\n\ndef fâ‚ƒ : X âŸ¶ Y\n  | X.a => Y.p\n  | X.b => Y.r\n  | X.c => Y.q\n\n--fâ‚ƒ is an isomorphism\nexample : âˆƒ f : XÎ± âŸ¶ YÎ², IsIso f := by\n  let f : XÎ± âŸ¶ YÎ² := âŸ¨\n    fâ‚ƒ,\n    by\n      constructor\n      Â· exact fun _ _ â†¦ Set.mem_univ _\n      Â· -- fÎ± = Î²f\n        funext x\n        cases x <;> rfl\n  âŸ©\n  let finv : YÎ² âŸ¶ XÎ± := âŸ¨\n    fun\n      | Y.p => X.a\n      | Y.q => X.c\n      | Y.r => X.b,\n    by\n      constructor\n      Â· exact fun _ _ â†¦ Set.mem_univ _\n      Â· -- fâ»Â¹Î² = Î±fâ»Â¹\n        funext y\n        cases y <;> rfl\n  âŸ©\n  use f\n  use finv\n  constructor\n  Â· -- fâ»Â¹f = ğŸ™ X\n    have h : finv.val âŠš f.val = ğŸ™ X := by\n      funext x\n      cases x <;> rfl\n    exact Subtype.eq h\n  Â· -- ffâ»Â¹ = ğŸ™ Y\n    have h : f.val âŠš finv.val = ğŸ™ Y := by\n      funext y\n      cases y <;> rfl\n    exact Subtype.eq h\n\n\nProve that there is no isomorphism (in ğ‘ºâ†»)frominductive X\n  | xâ‚ | xâ‚‚ | xâ‚ƒ | xâ‚„\n\ndef Î± : X âŸ¶ X\n  | X.xâ‚ => X.xâ‚‚\n  | X.xâ‚‚ => X.xâ‚ƒ\n  | X.xâ‚ƒ => X.xâ‚„\n  | X.xâ‚„ => X.xâ‚‚\n\ndef XÎ± : SetWithEndomap := {\n  t := X\n  carrier := Set.univ\n  toEnd := Î±\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\ntoinductive Y\n  | yâ‚ | yâ‚‚ | yâ‚ƒ | yâ‚„\n\ndef Î² : Y âŸ¶ Y\n  | Y.yâ‚ => Y.yâ‚‚\n  | Y.yâ‚‚ => Y.yâ‚ƒ\n  | Y.yâ‚ƒ => Y.yâ‚„\n  | Y.yâ‚„ => Y.yâ‚\n\ndef YÎ² : SetWithEndomap := {\n  t := Y\n  carrier := Set.univ\n  toEnd := Î²\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\nHint: In fact, more is true: there is no map (in ğ‘ºâ†») from X^{â†»\\alpha} to Y^{â†»\\beta}.\n\nWe give a proof by contradiction below.example : Â¬(âˆƒ f : XÎ± âŸ¶ YÎ², IsIso f) := by\n  rintro âŸ¨f, _âŸ©\n  -- X.xâ‚‚ is a fixed point of Î± âŠš Î± âŠš Î±,\n  have hâ‚ : (XÎ±.toEnd âŠš XÎ±.toEnd âŠš XÎ±.toEnd) X.xâ‚‚ = X.xâ‚‚ := by rfl\n  -- but Î² âŠš Î² âŠš Î² has no fixed points in Y\n  have hâ‚‚ : âˆ€ y : Y, (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) y â‰  y := by\n    intro y\n    cases y <;> exact fun h â†¦ by contradiction\n  -- Since f âŠš (Î± âŠš Î± âŠš Î±) = (Î² âŠš Î² âŠš Î²) âŠš f, we can derive a\n  -- contradiction\n  have h_contra : f.val ((XÎ±.toEnd âŠš XÎ±.toEnd âŠš XÎ±.toEnd) X.xâ‚‚) =\n      (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) (f.val X.xâ‚‚) := by\n    rw [â† types_comp_apply f.val (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd),\n        â† Category.assoc, â† Category.assoc, â† f.property.2]\n    rw [Category.assoc XÎ±.toEnd f.val, â† f.property.2]\n    rw [Category.assoc XÎ±.toEnd (f.val âŠš XÎ±.toEnd),\n        Category.assoc XÎ±.toEnd f.val, â† f.property.2]\n    rw [â† Category.assoc, â† Category.assoc,\n        types_comp_apply (XÎ±.toEnd âŠš XÎ±.toEnd âŠš XÎ±.toEnd)]\n  have : (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) (f.val X.xâ‚‚) =\n      f.val X.xâ‚‚ := by\n    rw [â† h_contra, hâ‚]\n  have : (YÎ².toEnd âŠš YÎ².toEnd âŠš YÎ².toEnd) (f.val X.xâ‚‚) â‰ \n      f.val X.xâ‚‚ := hâ‚‚ (f.val X.xâ‚‚)\n  contradiction\n\n\nSuppose {A^{â†»\\alpha} \\xrightarrow{f} B^{â†»\\beta}} is a map in ğ‘ºâ†», and that as a map of sets, {A \\xrightarrow{f} B} has an inverse {B \\xrightarrow{f^{-1}} A}. Show that f^{-1} is automatically a map in ğ‘ºâ†».\n\nLet {g = f^{-1}}.example {AÎ± BÎ² : SetWithEndomap} (f : AÎ± âŸ¶ BÎ²)\n    (g : BÎ².t âŸ¶ AÎ±.t) (hg_mtc : âˆ€ b âˆˆ BÎ².carrier, g b âˆˆ AÎ±.carrier)\n    (h : g âŠš f.val = ğŸ™ AÎ±.t âˆ§ f.val âŠš g = ğŸ™ BÎ².t)\n    : âˆƒ finv : BÎ² âŸ¶ AÎ±, finv.val = g := by\n  obtain âŸ¨f, _, hf_commâŸ© := f\n  use âŸ¨\n    g,\n    by\n      constructor\n      Â· exact hg_mtc\n      Â· funext b\n        apply_fun f\n        Â· rw [â† types_comp_apply (g âŠš BÎ².toEnd) f, Category.assoc,\n              h.2, Category.comp_id]\n          rw [â† types_comp_apply (AÎ±.toEnd âŠš g) f, Category.assoc,\n              hf_comm, â† Category.assoc, h.2, Category.id_comp]\n        Â· intro aâ‚ aâ‚‚ hf\n          have hgf := congrArg g hf\n          repeat rw [â† types_comp_apply f g, h.1] at hgf\n          exact hgf\n  âŸ©\n\n\n{\\mathbb{Z} = \\{\\ldots, -2, -1, 0, 1, 2, 3, \\ldots\\}} is the set of integers, and \\mathbb{Z}^{â†»\\alpha} and \\mathbb{Z}^{â†»\\beta} are the maps which add 2 and 3: {\\alpha(n) = n + 2}, {\\beta(n) = n + 3}. Is \\mathbb{Z}^{â†»\\alpha} isomorphic to \\mathbb{Z}^{â†»\\beta}? (If so, find an isomorphism {\\mathbb{Z}^{â†»\\alpha} \\xrightarrow{f} \\mathbb{Z}^{â†»\\beta}}; if not, explain how you know they are not isomorphic.)\n\nDefine the maps \\mathbb{Z}^{â†»\\alpha} and \\mathbb{Z}^{â†»\\beta} as SetWithEndomap structures.def Î± := (Â· + (2 : â„¤))\ndef Î² := (Â· + (3 : â„¤))\n\nabbrev â„¤Î± : SetWithEndomap := {\n  t := â„¤\n  carrier := Set.univ\n  toEnd := Î±\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\nabbrev â„¤Î² : SetWithEndomap := {\n  t := â„¤\n  carrier := Set.univ\n  toEnd := Î²\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\nWe show that \\mathbb{Z}^{â†»\\alpha} is not isomorphic to \\mathbb{Z}^{â†»\\beta}.example (f : â„¤Î± âŸ¶ â„¤Î²) : Â¬(IsIso f) := by\n  -- Assume f is an isomorphism, and derive a contradiction\n  by_contra hf_iso\n  -- We begin by extracting the structure-preserving property of f\n  have hf_comm\n      : âˆ€ x : â„¤, (f.val âˆ˜ â„¤Î±.toEnd) x = (â„¤Î².toEnd âˆ˜ f.val) x := by\n    intro x\n    exact congrFun f.property.2 x\n  -- and unfolding the definitions of Î± and Î²\n  have hf_comm' : âˆ€ x : â„¤, f.val (x + 2) = f.val x + 3 := hf_comm\n  -- The key observation: f.val(x + 2) and f.val(x) have the same\n  -- remainder when divided by 3\n  have hf_mod_3_eq : âˆ€ x : â„¤, f.val (x + 2) â‰¡ f.val x [ZMOD 3] := by\n    intro x\n    dsimp [Int.ModEq]\n    rw [hf_comm' x]\n    omega\n  -- Hence all even numbers map to values with the same remainder mod 3\n  -- as f.val(0),\n  have hf_even_congr : âˆ€ x : â„¤, f.val (2 * x) â‰¡ f.val 0 [ZMOD 3] := by\n    intro x\n    dsimp [Int.ModEq]\n    induction x with\n    | zero => simp\n    | succ x' ih => rw [mul_add, mul_one, hf_mod_3_eq (2 * x'), ih]\n    | pred x' ih => rw [mul_sub, â† hf_mod_3_eq (2 * (-x') - 2 * 1),\n        mul_one, sub_add_cancel, ih]\n  -- and all odd numbers map to values with the same remainder mod 3 as\n  -- f.val(1)\n  have hf_odd_congr\n      : âˆ€ x : â„¤, f.val (2 * x + 1) â‰¡ f.val 1 [ZMOD 3] := by\n    intro x\n    dsimp [Int.ModEq]\n    induction x with\n    | zero => simp\n    | succ x' ih =>\n        rw [mul_add, mul_one]\n        rw [add_assoc, add_comm 2 1, â† add_assoc]\n        rw [hf_mod_3_eq (2 * x' + 1), ih]\n    | pred x' ih =>\n        rw [mul_sub, â† hf_mod_3_eq (2 * (-x') - 2 * 1 + 1)]\n        have : 2 * (-x' : â„¤) - 2 * 1 + 1 + 2 = 2 * (-x') +1 := by ring\n        rw [this]\n        exact ih\n  -- So the image of f.val can have at most two distinct remainders\n  -- mod 3\n  have hf_img_setâ‚ : Set.range (fun x â†¦ f.val x % 3) =\n      {f.val 0 % 3, f.val 1 % 3} := by\n    ext b\n    constructor\n    Â· rintro âŸ¨a, hfaâŸ©\n      dsimp at hfa\n      rw [Set.mem_insert_iff, Set.mem_singleton_iff]\n      rcases Int.even_or_odd a with ha_even | ha_odd\n      Â· left\n        obtain âŸ¨a', ha_evenâŸ© := ha_even\n        rw [â† hfa, ha_even, â† two_mul, hf_even_congr a']\n      Â· right\n        obtain âŸ¨a', ha_oddâŸ© := ha_odd\n        rw [â† hfa, ha_odd, hf_odd_congr a']\n    Â· intro hb\n      rcases hb with hb_mem | hb_mem <;> (rw [hb_mem]; simp)\n  -- Now, since f is an isomorphism, f.val is bijective\n  have hf_bij : Function.Bijective f.val :=\n    ConcreteCategory.bijective_of_isIso f\n  -- and hence surjective,\n  have hf_surj : Function.Surjective f.val := hf_bij.right\n  -- but a surjective function on â„¤ must hit all three remainders mod 3\n  have hf_img_setâ‚‚ : Set.range (fun x â†¦ f.val x % 3) = {0, 1, 2} := by\n    ext b\n    constructor\n    Â· rintro âŸ¨a, hfaâŸ©\n      dsimp at hfa\n      have hf_lbound : 0 â‰¤ f.val a % 3 := Int.emod_nonneg\n          (f.val a) (by decide : (3 : â„¤) â‰  0)\n      have hf_ubound : f.val a % 3 < 3 := Int.emod_lt_of_pos\n          (f.val a) (by decide : (0 < (3 : â„¤)))\n      interval_cases k : f.val a % 3 using hf_lbound, hf_ubound <;>\n        (rw [â† hfa]; bound)\n    Â· rintro (hb | hb | hb)\n      all_goals (\n        obtain âŸ¨a, hfaâŸ© := hf_surj b\n        use a\n        dsimp\n        rw [hfa, hb]\n        norm_num\n      )\n  -- Since we have found that the image of f.val can have at most two\n  -- distinct elements and must also have exactly three distinct\n  -- elements, we have a contradiction\n  have h_cardâ‚\n      : Set.ncard ({f.val 0 % 3, f.val 1 % 3} : Set â„¤) â‰¤ 2 := by\n    have h := Set.ncard_insert_le (f.val 0 % 3) {f.val 1 % 3}\n    rwa [Set.ncard_singleton] at h\n  have h_cardâ‚‚ : Set.ncard ({0, 1, 2} : Set â„¤) = 3 := by norm_num\n  rw [â† hf_img_setâ‚, hf_img_setâ‚‚, h_cardâ‚‚] at h_cardâ‚\n  linarith\n\n\nEach of the following graphs is isomorphic to exactly one of the others. Which?\n\nWe label the arrows in each graph from top to bottom.inductive A\n  | aâ‚ | aâ‚‚ | aâ‚ƒ\nWe label the dots in each graph from left to right.inductive D\n  | dâ‚ | dâ‚‚ | dâ‚ƒ\nThen the six graphs (a) to (f) are as follows:def graph_a : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚‚\n    | A.aâ‚‚ => D.dâ‚\n    | A.aâ‚ƒ => D.dâ‚ƒ\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚ƒ\n    | A.aâ‚‚ => D.dâ‚‚\n    | A.aâ‚ƒ => D.dâ‚‚\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef graph_b : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚\n    | A.aâ‚‚ => D.dâ‚‚\n    | A.aâ‚ƒ => D.dâ‚‚,\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚‚\n    | A.aâ‚‚ => D.dâ‚ƒ\n    | A.aâ‚ƒ => D.dâ‚\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef graph_c : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚\n    | A.aâ‚‚ => D.dâ‚\n    | A.aâ‚ƒ => D.dâ‚\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚ƒ\n    | A.aâ‚‚ => D.dâ‚‚\n    | A.aâ‚ƒ => D.dâ‚ƒ\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef graph_d : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚ƒ\n    | A.aâ‚‚ => D.dâ‚\n    | A.aâ‚ƒ => D.dâ‚‚\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚‚\n    | A.aâ‚‚ => D.dâ‚‚\n    | A.aâ‚ƒ => D.dâ‚ƒ\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef graph_e : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚\n    | A.aâ‚‚ => D.dâ‚\n    | A.aâ‚ƒ => D.dâ‚ƒ\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚ƒ\n    | A.aâ‚‚ => D.dâ‚‚\n    | A.aâ‚ƒ => D.dâ‚\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef graph_f : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚\n    | A.aâ‚‚ => D.dâ‚\n    | A.aâ‚ƒ => D.dâ‚\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚‚\n    | A.aâ‚‚ => D.dâ‚ƒ\n    | A.aâ‚ƒ => D.dâ‚ƒ\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\nGraph (a) is isomorphic to graph (d).def fâ‚ : graph_a âŸ¶ graph_d := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚ƒ\n      | A.aâ‚‚ => A.aâ‚‚\n      | A.aâ‚ƒ => A.aâ‚,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚\n      | D.dâ‚‚ => D.dâ‚‚\n      | D.dâ‚ƒ => D.dâ‚ƒ\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\ndef finvâ‚ : graph_d âŸ¶ graph_a := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚ƒ\n      | A.aâ‚‚ => A.aâ‚‚\n      | A.aâ‚ƒ => A.aâ‚,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚\n      | D.dâ‚‚ => D.dâ‚‚\n      | D.dâ‚ƒ => D.dâ‚ƒ\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\nexample : graph_a â‰… graph_d := {\n  hom := fâ‚,\n  inv := finvâ‚,\n  hom_inv_id := by\n    have hâ‚ : (finvâ‚.val.1 âŠš fâ‚.val.1 = ğŸ™ graph_a.tA) âˆ§\n        (finvâ‚.val.2 âŠš fâ‚.val.2 = ğŸ™ graph_a.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (finvâ‚.val.1 âŠš fâ‚.val.1, finvâ‚.val.2 âŠš fâ‚.val.2) =\n        (ğŸ™ graph_a.tA, ğŸ™ graph_a.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚,\n  inv_hom_id := by\n    have hâ‚ : (fâ‚.val.1 âŠš finvâ‚.val.1 = ğŸ™ graph_d.tA) âˆ§\n        (fâ‚.val.2 âŠš finvâ‚.val.2 = ğŸ™ graph_d.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (fâ‚.val.1 âŠš finvâ‚.val.1, fâ‚.val.2 âŠš finvâ‚.val.2) =\n        (ğŸ™ graph_d.tA, ğŸ™ graph_d.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚\n}\nGraph (b) is isomorphic to graph (e).def fâ‚‚ : graph_b âŸ¶ graph_e := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚ƒ\n      | A.aâ‚‚ => A.aâ‚‚\n      | A.aâ‚ƒ => A.aâ‚,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚ƒ\n      | D.dâ‚‚ => D.dâ‚\n      | D.dâ‚ƒ => D.dâ‚‚\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\ndef finvâ‚‚ : graph_e âŸ¶ graph_b := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚ƒ\n      | A.aâ‚‚ => A.aâ‚‚\n      | A.aâ‚ƒ => A.aâ‚,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚‚\n      | D.dâ‚‚ => D.dâ‚ƒ\n      | D.dâ‚ƒ => D.dâ‚\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\nexample : graph_b â‰… graph_e := {\n  hom := fâ‚‚,\n  inv := finvâ‚‚,\n  hom_inv_id := by\n    have hâ‚ : (finvâ‚‚.val.1 âŠš fâ‚‚.val.1 = ğŸ™ graph_b.tA) âˆ§\n        (finvâ‚‚.val.2 âŠš fâ‚‚.val.2 = ğŸ™ graph_b.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (finvâ‚‚.val.1 âŠš fâ‚‚.val.1, finvâ‚‚.val.2 âŠš fâ‚‚.val.2) =\n        (ğŸ™ graph_b.tA, ğŸ™ graph_b.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚,\n  inv_hom_id := by\n    have hâ‚ : (fâ‚‚.val.1 âŠš finvâ‚‚.val.1 = ğŸ™ graph_e.tA) âˆ§\n        (fâ‚‚.val.2 âŠš finvâ‚‚.val.2 = ğŸ™ graph_e.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (fâ‚‚.val.1 âŠš finvâ‚‚.val.1, fâ‚‚.val.2 âŠš finvâ‚‚.val.2) =\n        (ğŸ™ graph_e.tA, ğŸ™ graph_e.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚\n}\nGraph (c) is isomorphic to graph (f).def fâ‚ƒ : graph_c âŸ¶ graph_f := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚‚\n      | A.aâ‚‚ => A.aâ‚\n      | A.aâ‚ƒ => A.aâ‚ƒ,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚\n      | D.dâ‚‚ => D.dâ‚‚\n      | D.dâ‚ƒ => D.dâ‚ƒ\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\ndef finvâ‚ƒ : graph_f âŸ¶ graph_c := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚‚\n      | A.aâ‚‚ => A.aâ‚\n      | A.aâ‚ƒ => A.aâ‚ƒ,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚\n      | D.dâ‚‚ => D.dâ‚‚\n      | D.dâ‚ƒ => D.dâ‚ƒ\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\nexample : graph_c â‰… graph_f := {\n  hom := fâ‚ƒ,\n  inv := finvâ‚ƒ,\n  hom_inv_id := by\n    have hâ‚ : (finvâ‚ƒ.val.1 âŠš fâ‚ƒ.val.1 = ğŸ™ graph_c.tA) âˆ§\n        (finvâ‚ƒ.val.2 âŠš fâ‚ƒ.val.2 = ğŸ™ graph_c.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (finvâ‚ƒ.val.1 âŠš fâ‚ƒ.val.1, finvâ‚ƒ.val.2 âŠš fâ‚ƒ.val.2) =\n        (ğŸ™ graph_c.tA, ğŸ™ graph_c.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚,\n  inv_hom_id := by\n    have hâ‚ : (fâ‚ƒ.val.1 âŠš finvâ‚ƒ.val.1 = ğŸ™ graph_f.tA) âˆ§\n        (fâ‚ƒ.val.2 âŠš finvâ‚ƒ.val.2 = ğŸ™ graph_f.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (fâ‚ƒ.val.1 âŠš finvâ‚ƒ.val.1, fâ‚ƒ.val.2 âŠš finvâ‚ƒ.val.2) =\n        (ğŸ™ graph_f.tA, ğŸ™ graph_f.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚\n}\n\n\nIf these two graphs are isomorphic, find an isomorphism between them; if they are not isomorphic, explain how you know they are not.\n\nWe label the arrows in each graph starting with the arrow at the bottom left and moving clockwise through the four outer arrows (a_1 to a_4) and then vertically upwards through the two inner arrows (a_5 and a_6).inductive A\n  | aâ‚ | aâ‚‚ | aâ‚ƒ | aâ‚„ | aâ‚… | aâ‚†\nWe label the dots in each graph starting with the bottom dot and moving clockwise through the four outer dots (d_1 to d_4) and then finishing with the centre dot (d_5).inductive D\n  | dâ‚ | dâ‚‚ | dâ‚ƒ | dâ‚„ | dâ‚…\nThen the two graphs are as follows:def graph_L : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚\n    | A.aâ‚‚ => D.dâ‚‚\n    | A.aâ‚ƒ => D.dâ‚ƒ\n    | A.aâ‚„ => D.dâ‚„\n    | A.aâ‚… => D.dâ‚\n    | A.aâ‚† => D.dâ‚…\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚‚\n    | A.aâ‚‚ => D.dâ‚ƒ\n    | A.aâ‚ƒ => D.dâ‚„\n    | A.aâ‚„ => D.dâ‚\n    | A.aâ‚… => D.dâ‚…\n    | A.aâ‚† => D.dâ‚ƒ\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef graph_R : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => D.dâ‚‚\n    | A.aâ‚‚ => D.dâ‚ƒ\n    | A.aâ‚ƒ => D.dâ‚ƒ\n    | A.aâ‚„ => D.dâ‚„\n    | A.aâ‚… => D.dâ‚\n    | A.aâ‚† => D.dâ‚…\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => D.dâ‚\n    | A.aâ‚‚ => D.dâ‚‚\n    | A.aâ‚ƒ => D.dâ‚„\n    | A.aâ‚„ => D.dâ‚\n    | A.aâ‚… => D.dâ‚…\n    | A.aâ‚† => D.dâ‚ƒ\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\nThe two graphs are isomorphic, with an isomorphism between them given by f below.def f : graph_L âŸ¶ graph_R := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚ƒ\n      | A.aâ‚‚ => A.aâ‚„\n      | A.aâ‚ƒ => A.aâ‚…\n      | A.aâ‚„ => A.aâ‚†\n      | A.aâ‚… => A.aâ‚‚\n      | A.aâ‚† => A.aâ‚\n      ,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚ƒ\n      | D.dâ‚‚ => D.dâ‚„\n      | D.dâ‚ƒ => D.dâ‚\n      | D.dâ‚„ => D.dâ‚…\n      | D.dâ‚… => D.dâ‚‚\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\ndef finv : graph_R âŸ¶ graph_L := {\n  val := (\n    fun -- maps arrows\n      | A.aâ‚ => A.aâ‚†\n      | A.aâ‚‚ => A.aâ‚…\n      | A.aâ‚ƒ => A.aâ‚\n      | A.aâ‚„ => A.aâ‚‚\n      | A.aâ‚… => A.aâ‚ƒ\n      | A.aâ‚† => A.aâ‚„,\n    fun -- maps dots\n      | D.dâ‚ => D.dâ‚ƒ\n      | D.dâ‚‚ => D.dâ‚…\n      | D.dâ‚ƒ => D.dâ‚\n      | D.dâ‚„ => D.dâ‚‚\n      | D.dâ‚… => D.dâ‚„\n  )\n  property := by\n    split_ands\n    all_goals (\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n    )\n}\n\nexample : graph_L â‰… graph_R := {\n  hom := f,\n  inv := finv,\n  hom_inv_id := by\n    have hâ‚ : (finv.val.1 âŠš f.val.1 = ğŸ™ graph_L.tA) âˆ§\n        (finv.val.2 âŠš f.val.2 = ğŸ™ graph_L.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (finv.val.1 âŠš f.val.1, finv.val.2 âŠš f.val.2) =\n        (ğŸ™ graph_L.tA, ğŸ™ graph_L.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚,\n  inv_hom_id := by\n    have hâ‚ : (f.val.1 âŠš finv.val.1 = ğŸ™ graph_R.tA) âˆ§\n        (f.val.2 âŠš finv.val.2 = ğŸ™ graph_R.tD) := by\n      constructor <;> (funext x; cases x <;> rfl)\n    have hâ‚‚ : (f.val.1 âŠš finv.val.1, f.val.2 âŠš finv.val.2) =\n        (ğŸ™ graph_R.tA, ğŸ™ graph_R.tD) := by\n      rw [hâ‚.1, hâ‚.2]\n    exact Subtype.eq hâ‚‚\n}\n\n\n(Impossible journeys) J is the graphinductive A\n  | aâ‚ | aâ‚‚ | aâ‚ƒ\n\nabbrev D := Fin 2\n\ndef J : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := fun\n    | A.aâ‚ => 0\n    | A.aâ‚‚ => 1\n    | A.aâ‚ƒ => 1\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | A.aâ‚ => 0\n    | A.aâ‚‚ => 0\n    | A.aâ‚ƒ => 1\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\nG is any graph, and b and e are dots of G.variable (G : IrreflexiveGraph)\n         (b e : G.tD) (hb : b âˆˆ G.carrierD) (he : e âˆˆ G.carrierD)\n(a) Suppose that {G \\xrightarrow{f} J} is a map of graphs with {fb = 0} and {fe = 1}. Show that there is no path in G that begins at b and ends at e.(b) Conversely, suppose that there is no path in G that begins at b and ends at e. Show that there is a map {G \\xrightarrow{f} J} with {fb = 0} and {fe = 1}.\n\nTODO Exercise 11.8\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 11: Ascending to categories of richer structures","header":"3. The category of graphs","id":"/Session-11___-Ascending-to-categories-of-richer-structures/#A-Lean-Companion-to-Conceptual-Mathematics--Session-11___-Ascending-to-categories-of-richer-structures--3___-The-category-of-graphs"}});