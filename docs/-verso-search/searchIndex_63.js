window.docContents[63].resolve({"/Session-5___-Division-of-maps___-Sections-and-retractions/#A-Lean-Companion-to-Conceptual-Mathematics--Session-5___-Division-of-maps___-Sections-and-retractions--1___-Determination-problems":{"contents":"(a) Show that if there is a map g for which {h = g \\circ f}, then for any pair a_1, a_2 of points {\\mathbf{1} \\rightarrow A} of the domain A of f (and of h) we have:\n\\text{if}\\; fa_1 = fa_2 \\;\\text{then}\\; ha_1 = ha_2.\n(So, if for some pair of points one has {f a_1 = f a_2} but {h a_1 \\ne h a_2}, then h is not determined by f.)(b) Does the converse hold? That is, if maps (of sets) f and h satisfy the conditions above ('for any pair ... then {h a_1 = h a_2}'), must there be a map {B \\xrightarrow{g} C} with {h = g \\circ f}?\n\nWe use types instead of sets here, and we begin by showing that part (a) holds.example {A B C : Type} {f : A ⟶ B} {h : A ⟶ C}\n    (hg : ∃ g : B ⟶ C, h = g ⊚ f)\n    : ∀ a₁ a₂ : Point A, f ⊚ a₁ = f ⊚ a₂ → h ⊚ a₁ = h ⊚ a₂ := by\n  obtain ⟨g, hg⟩ := hg\n  intro _ _ hfa\n  rw [hg]\n  repeat rw [← Category.assoc]\n  rw [hfa]\nFor part (b), we first prove the converse in the case when f is surjective.example {A B C : Type} {f : A ⟶ B} {h : A ⟶ C}\n    (H : ∀ a₁ a₂ : Point A, f ⊚ a₁ = f ⊚ a₂ → h ⊚ a₁ = h ⊚ a₂)\n    (hfsurj : Function.Surjective f)\n    : ∃ g : B ⟶ C, h = g ⊚ f := by\n  let g : B ⟶ C := fun β ↦ h (Classical.choose (hfsurj β))\n  use g\n  funext α\n  let a₁ : Point A := fun _ ↦ α\n  let a₂ : Point A := fun _ ↦ Classical.choose (hfsurj (f α))\n  have hfa : f ⊚ a₁ = f ⊚ a₂ := by\n    funext\n    exact (Classical.choose_spec (hfsurj (f α))).symm\n  have hha : h ⊚ a₁ = h ⊚ a₂ := H a₁ a₂ hfa\n  apply congrFun hha ()\nProof in the general case is slightly more complicated and is given below.open Classical in\nexample {A B C : Type} [Nonempty C] {f : A ⟶ B} {h : A ⟶ C}\n    (H : ∀ a₁ a₂ : Point A, f ⊚ a₁ = f ⊚ a₂ → h ⊚ a₁ = h ⊚ a₂)\n    : ∃ g : B ⟶ C, h = g ⊚ f := by\n  -- β : B may or may not be in the image of f,\n  -- so we need to handle both cases\n  let g : B ⟶ C := fun β ↦\n    if β_in_image : ∃ α : A, f α = β then\n      h (choose β_in_image)\n    else\n      choice inferInstance\n  use g\n  funext α\n  let β_in_image_exists : ∃ α' : A, f α' = f α := ⟨α, rfl⟩\n  let a₁ : Point A := fun _ ↦ α\n  let a₂ : Point A := fun _ ↦ choose β_in_image_exists\n  have hfa : f ⊚ a₁ = f ⊚ a₂ := by\n    funext\n    exact (choose_spec β_in_image_exists).symm\n  have hha : h ⊚ a₁ = h ⊚ a₂ := H a₁ a₂ hfa\n  have h_eq_h_chosen : h α = h (choose β_in_image_exists) :=\n    congrFun hha ()\n  have g_eq_h_chosen : g (f α) = h (choose β_in_image_exists) := by\n    dsimp [g]\n    rw [dif_pos β_in_image_exists]\n  rw [types_comp_apply]\n  rw [g_eq_h_chosen]\n  exact h_eq_h_chosen\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 5: Division of maps: Sections and retractions","header":"1. Determination problems","id":"/Session-5___-Division-of-maps___-Sections-and-retractions/#A-Lean-Companion-to-Conceptual-Mathematics--Session-5___-Division-of-maps___-Sections-and-retractions--1___-Determination-problems"}});