window.docContents[163].resolve({"/Article-II___-Isomorphisms/#A-Lean-Companion-to-Conceptual-Mathematics--Article-II___-Isomorphisms--3___-Retractions___-sections___-and-idempotents":{"contents":"If {A \\xrightarrow{f} B}:a retraction for f is a map {B \\xrightarrow{r} A} for which {r \\circ f = 1_A};a section for f is a map {B \\xrightarrow{s} A} for which {f \\circ s = 1_B}.\n\nThe mathlib definition corresponding to retraction is SplitMono (and IsSplitMono), which we print below for reference.\n\n#print SplitMono\n\n\nstructure CategoryTheory.SplitMono.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Type vâ‚\nnumber of parameters: 5\nfields:\n  CategoryTheory.SplitMono.retraction : Y âŸ¶ X\n  CategoryTheory.SplitMono.id : self.retraction âŠš f = ğŸ™ X := by\n    cat_disch\nconstructor:\n  CategoryTheory.SplitMono.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (retraction : Y âŸ¶ X)\n    (id : retraction âŠš f = ğŸ™ X := by cat_disch) : SplitMono f\n\n\n#print IsSplitMono\n\n\nclass CategoryTheory.IsSplitMono.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Prop\nnumber of parameters: 5\nfields:\n  CategoryTheory.IsSplitMono.exists_splitMono : Nonempty (SplitMono f)\nconstructor:\n  CategoryTheory.IsSplitMono.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y}\n    (exists_splitMono : Nonempty (SplitMono f)) : IsSplitMono f\n\n\nWe alias SplitMono and IsSplitMono as Retraction and IsRetraction, respectively, to remain aligned with the terminology in the book.\n\n\n\nabbrev Retraction {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’}\n    (f : A âŸ¶ B) :=\n  SplitMono f\nabbrev IsRetraction {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’}\n    (f : A âŸ¶ B) :=\n  IsSplitMono f\n\n\nThe mathlib definition corresponding to section is SplitEpi (and IsSplitEpi), which we print below for reference.\n\n#print SplitEpi\n\n\nstructure CategoryTheory.SplitEpi.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Type vâ‚\nnumber of parameters: 5\nfields:\n  CategoryTheory.SplitEpi.section_ : Y âŸ¶ X\n  CategoryTheory.SplitEpi.id : f âŠš self.section_ = ğŸ™ Y := by\n    cat_disch\nconstructor:\n  CategoryTheory.SplitEpi.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} (section_ : Y âŸ¶ X)\n    (id : f âŠš section_ = ğŸ™ Y := by cat_disch) : SplitEpi f\n\n\n#print IsSplitEpi\n\n\nclass CategoryTheory.IsSplitEpi.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} (f : X âŸ¶ Y) : Prop\nnumber of parameters: 5\nfields:\n  CategoryTheory.IsSplitEpi.exists_splitEpi : Nonempty (SplitEpi f)\nconstructor:\n  CategoryTheory.IsSplitEpi.mk.{vâ‚, uâ‚} {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y}\n    (exists_splitEpi : Nonempty (SplitEpi f)) : IsSplitEpi f\n\n\nWe alias SplitEpi and IsSplitEpi as Section and IsSection, respectively, to remain aligned with the terminology in the book.\n\n\n\nabbrev Section {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’}\n    (f : A âŸ¶ B) :=\n  SplitEpi f\nabbrev IsSection {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’}\n    (f : A âŸ¶ B) :=\n  IsSplitEpi f\n\n\nIf a map {A \\xrightarrow{f} B} has a section, then for any T and for any map {T \\xrightarrow{y} B} there exists a map {T \\xrightarrow{x} A} for which {f \\circ x = y}.\n\nThe assumption means that we have a map s for which {f \\circ s = 1_B}. Thus for any given map {T \\xrightarrow{y} B} we see that we could define a map x with at least the correct domain and codomain by taking the composite s following y\nx = s \\circ y.\nDoes this map x actually satisfy the required equation? Calculating\nf \\circ x = f \\circ (s \\circ y) = (f \\circ s) \\circ y = 1_B \\circ y = y\nwe see that it does.\n\nOur implementation in Lean faithfully follows the argument of the book proof given above.\n\n\n\ntheorem prop1 {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’}\n    (f : A âŸ¶ B) [hf : IsSection f]\n    : âˆ€ y : T âŸ¶ B, âˆƒ x : T âŸ¶ A, f âŠš x = y := by\n  obtain âŸ¨s, hfâŸ© := hf\n  intro y\n  use s âŠš y\n  rw [Category.assoc]\n  rw [hf]\n  exact Category.comp_id y\n\n\nIf the map {A \\xrightarrow{f} B} has a retraction, then for any map {A \\xrightarrow{g} T}, there is a map {B \\xrightarrow{t} T} for which {t \\circ f = g}. (This is Proposition 1*.)\n\nPut {t = g \\circ r}.theorem Â«prop1*Â» {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’}\n    (f : A âŸ¶ B) [hf : IsRetraction f]\n    : âˆ€ g : A âŸ¶ T, âˆƒ t : B âŸ¶ T, t âŠš f = g := by\n  obtain âŸ¨r, hfâŸ© := hf\n  intro g\n  use g âŠš r\n  rw [â† Category.assoc, hf, Category.id_comp]\n\n\nSuppose a map {A \\xrightarrow{f} B} has a retraction. Then for any set T and for any pair of maps {T \\xrightarrow{x_1} A}, {T \\xrightarrow{x_2} A} from any set T to A\n\\text{if}\\; f \\circ x_1 = f \\circ x_2 \\;\\text{then}\\; x_1 = x_2.\n\nLooking back at the definition, we see that the assumption means that we have a map r for which {r \\circ f = 1_A}. Using the assumption that x_1 and x_2 are such that f composes with them to get the same {T \\rightarrow B}, we can compose further with r as follows:\nx_1 = 1_A \\circ x_1 = (r \\circ f) \\circ x_1 = r \\circ (f \\circ x_1) = r \\circ (f \\circ x_2) = (r \\circ f) \\circ x_2 = 1_A \\circ x_2 = x_2.\n\nOur implementation in Lean generalises the proposition from sets to any categorical object but otherwise faithfully follows the argument of the book proof given above.\n\n\n\ntheorem prop2 {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’}\n    (f : A âŸ¶ B) [hf : IsRetraction f]\n    : âˆ€ xâ‚ xâ‚‚ : T âŸ¶ A, f âŠš xâ‚ = f âŠš xâ‚‚ â†’ xâ‚ = xâ‚‚ := by\n  obtain âŸ¨r, hfâŸ© := hf\n  intro xâ‚ xâ‚‚ h\n  rw [â† Category.comp_id xâ‚]\n  rw [â† hf]\n  rw [â† Category.assoc]\n  rw [h]\n  rw [Category.assoc]\n  rw [hf]\n  exact Category.comp_id xâ‚‚\n\n\nA map f satisfying the conclusion of Proposition 2 (for any pair of maps {T \\xrightarrow{x_1} A} and {T \\xrightarrow{x_2} A}, if {f \\circ x_1 = f \\circ x_2} then {x_1 = x_2}) is said to be injective for maps from T.If f is injective for maps from T for every T, one says that f is injective, or is a monomorphism.\n\nThe corresponding mathlib definition is Mono, which we print below for reference.\n\n#print Mono\n\n\nclass CategoryTheory.Mono.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y) : Prop\nnumber of parameters: 5\nfields:\n  CategoryTheory.Mono.right_cancellation : âˆ€ {Z : C} (g h : Z âŸ¶ X), f âŠš g = f âŠš h â†’ g = h\nconstructor:\n  CategoryTheory.Mono.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} {f : X âŸ¶ Y}\n    (right_cancellation : âˆ€ {Z : C} (g h : Z âŸ¶ X), f âŠš g = f âŠš h â†’ g = h) : Mono f\n\n\nSuppose the map {A \\xrightarrow{f} B} has a section. Then for any set T and any pair {B \\xrightarrow{t_1} T}, {B \\xrightarrow{t_2} T} of maps from B to T, if {t_1 \\circ f = t_2 \\circ f} then {t_1 = t_2}. (This is Proposition 2*.)\n\nA proof of Proposition 2* is given below.theorem Â«prop2*Â» {ğ’ : Type u} [Category.{v, u} ğ’] {A B T : ğ’}\n    (f : A âŸ¶ B) [hf : IsSection f]\n    : âˆ€ tâ‚ tâ‚‚ : B âŸ¶ T, tâ‚ âŠš f = tâ‚‚ âŠš f â†’ tâ‚ = tâ‚‚ := by\n  obtain âŸ¨s, hfâŸ© := hf\n  intro tâ‚ tâ‚‚ h\n  rw [â† Category.id_comp tâ‚, â† hf]\n  rw [Category.assoc, h, â† Category.assoc]\n  rw [hf, Category.id_comp]\n\n\nA map f with this cancellation property (if {t_1 \\circ f = t_2 \\circ f} then {t_1 = t_2}) for every T is called an epimorphism.\n\nThe corresponding mathlib definition is Epi, which we print below for reference.\n\n#print Epi\n\n\nclass CategoryTheory.Epi.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y) : Prop\nnumber of parameters: 5\nfields:\n  CategoryTheory.Epi.left_cancellation : âˆ€ {Z : C} (g h : Y âŸ¶ Z), g âŠš f = h âŠš f â†’ g = h\nconstructor:\n  CategoryTheory.Epi.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} {f : X âŸ¶ Y}\n    (left_cancellation : âˆ€ {Z : C} (g h : Y âŸ¶ Z), g âŠš f = h âŠš f â†’ g = h) : Epi f\n\n\nThus both 'monomorphism' and 'epimorphism' are 'cancellation' properties.\n\nThe mathlib theorems cancel_mono and cancel_epi are relevant here.\n\n\n\nexample {ğ’ : Type u} [Category.{v, u} ğ’] {X Y Z : ğ’}\n    (f : X âŸ¶ Y) [Mono f] {g h : Z âŸ¶ X}\n    : f âŠš g = f âŠš h â†” g = h := cancel_mono f\n\nexample {ğ’ : Type u} [Category.{v, u} ğ’] {X Y Z : ğ’}\n    (f : X âŸ¶ Y) [Epi f] {g h : Y âŸ¶ Z}\n    : g âŠš f = h âŠš f â†” g = h := cancel_epi f\n\n\nIf {A \\xrightarrow{f} B} has a retraction and if {B \\xrightarrow{g} C} has a retraction, then {A \\xrightarrow{g \\circ f} C} has a retraction.\n\nLet {r_1 \\circ f = 1_A} and {r_2 \\circ g = 1_B}. Then a good guess for a retraction of the composite would be the composite of the retractions in the opposite order (which is anyway the only order in which they can be composed). Does it in fact work?\nr \\circ (g \\circ f) = (r_1 \\circ r_2) \\circ (g \\circ f) = r_1 \\circ (r_2 \\circ g) \\circ f = r_1 \\circ 1_B \\circ f = r_1 \\circ f = 1_A\nproves that r is a retraction for {g \\circ f}.\n\nOur implementation in Lean faithfully follows the argument of the book proof given above.\n\n\n\ntheorem prop3 {ğ’ : Type u} [Category.{v, u} ğ’] {A B C : ğ’}\n    (f : A âŸ¶ B) [hf : IsRetraction f] (g : B âŸ¶ C) [hg : IsRetraction g]\n    : IsRetraction (g âŠš f) := by\n  obtain âŸ¨râ‚, hfâŸ© := hf\n  obtain âŸ¨râ‚‚, hgâŸ© := hg\n  use râ‚ âŠš râ‚‚\n  change (râ‚ âŠš râ‚‚) âŠš (g âŠš f) = ğŸ™ A\n  rw [Category.assoc, â† Category.assoc g]\n  rw [hg]\n  rw [Category.id_comp]\n  exact hf\n\n\nWe note that the corresponding mathlib instance is instIsSplitMonoComp.\n\n\n\nexample {ğ’ : Type u} [Category.{v, u} ğ’] {A B C : ğ’}\n    (f : A âŸ¶ B) [hf : IsRetraction f] (g : B âŸ¶ C) [hg : IsRetraction g]\n    : IsRetraction (g âŠš f) := instIsSplitMonoComp\n\n\nProve that the composite of two maps, each having sections, has itself a section.\n\nThe section of the composite is the composite of the sections in the opposite order (cf. Proposition 3).example {ğ’ : Type u} [Category.{v, u} ğ’] {A B C : ğ’}\n    (f : A âŸ¶ B) [hf : IsSection f] (g : B âŸ¶ C) [hg : IsSection g]\n    : IsSection (g âŠš f) := by\n  obtain âŸ¨sâ‚, hfâŸ© := hf\n  obtain âŸ¨sâ‚‚, hgâŸ© := hg\n  use sâ‚ âŠš sâ‚‚\n  change (g âŠš f) âŠš (sâ‚ âŠš sâ‚‚) = ğŸ™ C\n  rw [Category.assoc, â† Category.assoc sâ‚]\n  rw [hf]\n  rw [Category.id_comp]\n  exact hg\n\n\nWe note that the corresponding mathlib instance is instIsSplitEpiComp.\n\n\n\nexample {ğ’ : Type u} [Category.{v, u} ğ’] {A B C : ğ’}\n    (f : A âŸ¶ B) [hf : IsSection f] (g : B âŸ¶ C) [hg : IsSection g]\n    : IsSection (g âŠš f) := instIsSplitEpiComp\n\n\nAn endomap e is called idempotent if {e \\circ e = e}.\n\nWe implement Idempotent and IsIdempotent in Lean as follows:\n\n\n\nstructure Idempotent {ğ’ : Type u} [Category.{v, u} ğ’] (A : ğ’) where\n  e : A âŸ¶ A\n  idem : e âŠš e = e\n\nclass IsIdempotent {ğ’ : Type u} [Category.{v, u} ğ’] {A : ğ’}\n    (e : A âŸ¶ A) where\n  idem : e âŠš e = e\n\n\nSuppose r is a retraction of f (equivalently f is a section of r) and let {e = f \\circ r}. Show that e is an idempotent.... Show that if f is an isomorphism, then e is the identity.\n\nvariable {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’}\n         (f : A âŸ¶ B) (e : B âŸ¶ B)\nWe show that e is an idempotent.example (r : Retraction f) (he : e = f âŠš r.retraction)\n    : IsIdempotent e := {\n  idem := by\n    rw [he, Category.assoc, â† Category.assoc f, r.id,\n        Category.id_comp]\n}\nWe show that e is the identity if f is an isomorphism.example [hf : IsIso f]\n    (r : Retraction f) (he : e = f âŠš r.retraction)\n    : e = ğŸ™ B := by\n  have âŸ¨finv, hfinvâŸ© := hf\n  rw [â† hfinv.2, â† Category.id_comp f, â† r.id]\n  repeat rw [â† Category.assoc]\n  rwa [hfinv.2, Category.id_comp]\n\n\nIf f has both a retraction r and a section s then {r = s}.\n\nFrom the definition we have, if {A \\xrightarrow{f} B}, both of the equations\nr \\circ f = 1_A \\quad\\text{and}\\quad f \\circ s = 1_B.\nThen by the identity laws and the associative law\nr = r \\circ 1_B = r \\circ (f \\circ s) = (r \\circ f) \\circ s = 1_A \\circ s = s.\n\nOur implementation in Lean faithfully follows the argument of the book proof given above.\n\n\n\ntheorem uniqueness_of_inverses {ğ’ : Type u} [Category.{v, u} ğ’]\n    {A B : ğ’} (f : A âŸ¶ B) (r : Retraction f) (s : Section f)\n    : r.retraction = s.section_ := by\n  obtain âŸ¨r, hrâŸ© := r\n  obtain âŸ¨s, hsâŸ© := s\n  change r = s\n  calc\n    r = r âŠš ğŸ™ B := by rw [Category.id_comp]\n    _ = r âŠš (f âŠš s) := by rw [hs]\n    _ = (r âŠš f) âŠš s := by rw [â† Category.assoc]\n    _ = ğŸ™ A âŠš s := by rw [â† hr]\n    _ = s := Category.comp_id s\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article II: Isomorphisms","header":"3. Retractions, sections, and idempotents","id":"/Article-II___-Isomorphisms/#A-Lean-Companion-to-Conceptual-Mathematics--Article-II___-Isomorphisms--3___-Retractions___-sections___-and-idempotents"}});