window.docContents[113].resolve({"/Session-17___-Some-uses-of-graphs/#A-Lean-Companion-to-Conceptual-Mathematics--Session-17___-Some-uses-of-graphs--3___-Commuting-diagrams":{"contents":"We say that a diagram of shape G in ùíû commutes if for each pair p, q of dots in G, all paths in G from p to q are interpreted as the same map in ùíû.\n\nThe \"interpretation\" of dots in G as objects of ùíû and paths in G as maps of ùíû is performed by a functor from the free category ùë≠(G) to ùíû, written in Lean as CategoryTheory.Paths Dot ‚•§ ùíû, where p q : Dot.\n\nShow that a diagram of shapeinductive Dot\n  | x‚ÇÅ | x‚ÇÇ\n\ninductive Arrow : Dot ‚Üí Dot ‚Üí Type\n  | f : Arrow .x‚ÇÅ .x‚ÇÇ\n  | g : Arrow .x‚ÇÇ .x‚ÇÅ\n\ninstance : Quiver Dot where\n  Hom := Arrow\ncommutes if and only if the maps assigned to the two arrows are inverse.\n\nWe need to show that under a functor from the free category ùë≠(G) to ùíû, all paths between each pair of dots in ùë≠(G) correspond to the same map in ùíû if and only if the two arrows in the graph correspond to inverse maps in ùíû. Since there are four possible pairings of dots, the proof of the backward (\"if\") direction contains four parts.example {ùíû : Type u} [Category.{v, u} ùíû] (F : Paths Dot ‚•§ ùíû) :\n\n    -- Let x‚ÇÅ' be the object in ùíû associated with Dot.x‚ÇÅ in ùêπ(G)\n    let x‚ÇÅ' : ùíû := F.obj Dot.x‚ÇÅ\n    -- Let x‚ÇÇ' be the object in ùíû associated with Dot.x‚ÇÇ in ùêπ(G)\n    let x‚ÇÇ' : ùíû := F.obj Dot.x‚ÇÇ\n    -- Let f' be the morphism in ùíû associated with Arrow.f in ùêπ(G)\n    let f' : x‚ÇÅ' ‚ü∂ x‚ÇÇ' := F.map (Quiver.Hom.toPath Arrow.f)\n    -- Let g' be the morphism in ùíû associated with Arrow.g in ùêπ(G)\n    let g' : x‚ÇÇ' ‚ü∂ x‚ÇÅ' := F.map (Quiver.Hom.toPath Arrow.g)\n\n    -- Dot.x‚ÇÅ ‚ü∂ Dot.x‚ÇÅ is interpreted as the identity on x‚ÇÅ' in ùíû\n    (‚àÄ p‚ÇÅ : Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ, F.map p‚ÇÅ = ùüô x‚ÇÅ') ‚àß\n    -- Dot.x‚ÇÇ ‚ü∂ Dot.x‚ÇÇ is interpreted as the identity on x‚ÇÇ' in ùíû\n    (‚àÄ p‚ÇÇ : Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÇ, F.map p‚ÇÇ = ùüô x‚ÇÇ') ‚àß\n    -- Dot.x‚ÇÅ ‚ü∂ Dot.x‚ÇÇ is interpreted as f' in ùíû\n    (‚àÄ p‚ÇÅ‚ÇÇ : Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÇ, F.map p‚ÇÅ‚ÇÇ = f') ‚àß\n    -- Dot.x‚ÇÇ ‚ü∂ Dot.x‚ÇÅ is interpreted as g' in ùíû\n    (‚àÄ p‚ÇÇ‚ÇÅ : Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÅ, F.map p‚ÇÇ‚ÇÅ = g') ‚Üî\n    -- The maps assigned to the two arrows in G are inverse\n    g' ‚äö f' = ùüô x‚ÇÅ' ‚àß f' ‚äö g' = ùüô x‚ÇÇ' := by\n\n  constructor\n  -- Proof of the forward (\"only if\") direction\n  ¬∑ repeat rw [‚Üê F.map_comp]\n    intro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÅ‚ü©\n    constructor\n    ¬∑ rw [h‚ÇÅ]\n    ¬∑ rw [h‚ÇÇ]\n  -- Proof of the backward (\"if\") direction\n  ¬∑ repeat rw [‚Üê F.map_comp]\n    intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©\n    and_intros\n    -- ‚àÄ p‚ÇÅ : Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ, F.map p‚ÇÅ = ùüô x‚ÇÅ'\n    ¬∑ let rec aux‚ÇÅ (p : Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ)\n          : F.map p = ùüô (F.obj Dot.x‚ÇÅ) := by\n        match p with\n        | .nil =>\n          exact F.map_id Dot.x‚ÇÅ\n        | .cons tail Arrow.g =>\n          match tail with\n          | .cons tail' Arrow.f =>\n            change F.map ((Quiver.Hom.toPath Arrow.g ‚äö\n                           Quiver.Hom.toPath Arrow.f) ‚äö tail') = _\n            rw [Functor.map_comp, h‚ÇÅ, Category.comp_id]\n            exact aux‚ÇÅ tail'\n      intro p\n      exact aux‚ÇÅ p\n    -- ‚àÄ p‚ÇÇ : Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÇ, F.map p‚ÇÇ = ùüô x‚ÇÇ'\n    ¬∑ let rec aux‚ÇÇ (p : Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÇ)\n          : F.map p = ùüô (F.obj Dot.x‚ÇÇ) := by\n        match p with\n        | .nil =>\n          exact F.map_id Dot.x‚ÇÇ\n        | .cons tail Arrow.f =>\n          match tail with\n          | .cons tail' Arrow.g =>\n            change F.map ((Quiver.Hom.toPath Arrow.f ‚äö\n                           Quiver.Hom.toPath Arrow.g) ‚äö tail') = _\n            rw [Functor.map_comp, h‚ÇÇ, Category.comp_id]\n            exact aux‚ÇÇ tail'\n      intro p\n      exact aux‚ÇÇ p\n    -- ‚àÄ p‚ÇÅ‚ÇÇ : Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÇ, F.map p‚ÇÅ‚ÇÇ = f'\n    ¬∑ let rec aux‚ÇÅ‚ÇÇ (p : Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÇ)\n          : F.map p = F.map (Quiver.Hom.toPath Arrow.f) := by\n        match p with\n        | .cons tail Arrow.f =>\n          match tail with\n          | .nil =>\n            rfl\n          | .cons tail' Arrow.g =>\n            change F.map ((Quiver.Hom.toPath Arrow.f ‚äö\n                           Quiver.Hom.toPath Arrow.g) ‚äö tail') = _\n            rw [Functor.map_comp, h‚ÇÇ, Category.comp_id]\n            exact aux‚ÇÅ‚ÇÇ tail'\n      intro p\n      exact aux‚ÇÅ‚ÇÇ p\n    -- ‚àÄ p‚ÇÇ‚ÇÅ : Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÅ, F.map p‚ÇÇ‚ÇÅ = g'\n    ¬∑ let rec aux‚ÇÇ‚ÇÅ (p : Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÅ)\n          : F.map p = F.map (Quiver.Hom.toPath Arrow.g) := by\n        match p with\n        | .cons tail Arrow.g =>\n          match tail with\n          | .nil =>\n            rfl\n          | .cons tail' Arrow.f =>\n            change F.map ((Quiver.Hom.toPath Arrow.g ‚äö\n                           Quiver.Hom.toPath Arrow.f) ‚äö tail') = _\n            rw [Functor.map_comp, h‚ÇÅ, Category.comp_id]\n            exact aux‚ÇÇ‚ÇÅ tail'\n      intro p\n      exact aux‚ÇÇ‚ÇÅ p\n\n\nIn the diagraminductive Vertex\n  | A | B | C | D | E | F | G | H\n\ninductive Edge : Vertex ‚Üí Vertex ‚Üí Type\n  | f : Edge .A .B\n  | g : Edge .B .C\n  | h : Edge .C .D\n  | i : Edge .A .E\n  | j : Edge .B .F\n  | k : Edge .C .G\n  | l : Edge .D .H\n  | m : Edge .E .F\n  | n : Edge .F .G\n  | p : Edge .G .H\n\ninstance : Quiver Vertex where\n  Hom := Edge\nthe three equations (1) {jf = mi}, (2) {kg = nj}, (3) {lh = pk} actually force the diagram to commute; but you are just asked to prove that\npnmi = lhgf\n\nWe can prove this directly in the free category on the graph using only the associative property of path composition.open Edge Quiver Quiver.Hom Quiver.Path Vertex in\nexample\n    (h‚ÇÅ : (toPath f |>.comp (toPath j)) =\n          (toPath i |>.comp (toPath m) : Path A F))\n    (h‚ÇÇ : (toPath g |>.comp (toPath k)) =\n          (toPath j |>.comp (toPath n) : Path B G))\n    (h‚ÇÉ : (toPath h |>.comp (toPath l)) =\n          (toPath k |>.comp (toPath p) : Path C H))\n    : (toPath i\n          |>.comp (toPath m)\n          |>.comp (toPath n)\n          |>.comp (toPath p)) =\n      (toPath f\n          |>.comp (toPath g)\n          |>.comp (toPath h)\n          |>.comp (Hom.toPath l) : Path A H) := by\n  rw [comp_assoc, ‚Üê h‚ÇÅ]\n  rw [‚Üê comp_assoc, comp_assoc (a := A) (toPath f), ‚Üê h‚ÇÇ]\n  rw [comp_assoc, comp_assoc, ‚Üê h‚ÇÉ]\n  repeat rw [‚Üê comp_assoc]\n\n\nFor each of these diagrams, find a shortest list of equations that will make it commute....After you have found the answers try to explain clearly how you know, from the equations you chose, that all possible paths give equal composites.\n\n(a) A shortest list of equations that will make diagram (a) commute is:\ngf = 1_A, \\quad fg = 1_B, \\quad g = h(cf. Exercise 2 above.)inductive Vertex\n  | A | B\n\ninductive Edge : Vertex ‚Üí Vertex ‚Üí Type\n  | f : Edge .A .B\n  | g : Edge .B .A\n  | h : Edge .B .A\n\ninstance : Quiver Vertex where\n  Hom := Edge\n\nexample {ùíû : Type u} [Category.{v, u} ùíû] (F : Paths Vertex ‚•§ ùíû) :\n\n    -- Let A' be the object in ùíû associated with Vertex.A in ùêπ(G)\n    let A' : ùíû := F.obj Vertex.A\n    -- Let B' be the object in ùíû associated with Vertex.B in ùêπ(G)\n    let B' : ùíû := F.obj Vertex.B\n    -- Let f' be the morphism in ùíû associated with Edge.f in ùêπ(G)\n    let f' : A' ‚ü∂ B' := F.map (Quiver.Hom.toPath Edge.f)\n    -- Let g' be the morphism in ùíû associated with Edge.g in ùêπ(G)\n    let g' : B' ‚ü∂ A' := F.map (Quiver.Hom.toPath Edge.g)\n    -- Let h' be the morphism in ùíû associated with Edge.h in ùêπ(G)\n    let h' : B' ‚ü∂ A' := F.map (Quiver.Hom.toPath Edge.h)\n\n    -- The 3 equations required to make the diagram commute\n    g' ‚äö f' = ùüô A' ‚àß\n    f' ‚äö g' = ùüô B' ‚àß\n    g' = h' ‚Üí\n    -- .A ‚ü∂ .A is interpreted as the identity on A' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.A, F.map p = ùüô A') ‚àß\n    -- .B ‚ü∂ .B is interpreted as the identity on B' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.B, F.map p = ùüô B') ‚àß\n    -- .A ‚ü∂ .B is interpreted as f' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.B, F.map p = f') ‚àß\n    -- .B ‚ü∂ .A is interpreted as g' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.A, F.map p = g') := by\n\n  intro A' B' f' g' h' ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©\n  dsimp [A', B', f', g', h'] at h‚ÇÅ h‚ÇÇ h‚ÇÉ\n  rw [‚Üê F.map_comp] at h‚ÇÅ h‚ÇÇ\n  and_intros\n  -- ‚àÄ p : Quiver.Path Vertex.A Vertex.A, F.map p = ùüô A'\n  ¬∑ let rec auxAA (p : Quiver.Path Vertex.A Vertex.A)\n        : F.map p = ùüô (F.obj Vertex.A) := by\n      match p with\n      | .nil =>\n        exact F.map_id _\n      | .cons (.cons tail Edge.f) (e : Vertex.B ‚ü∂ Vertex.A) =>\n        have : F.map ((tail.cons Edge.f).cons e) =\n               F.map ((Quiver.Hom.toPath Edge.g ‚äö\n                       Quiver.Hom.toPath Edge.f) ‚äö tail) := by\n          rcases e\n          ¬∑ rfl\n          ¬∑ change F.map (Quiver.Hom.toPath Edge.h ‚äö\n                          Quiver.Hom.toPath Edge.f ‚äö tail) = _\n            rw [Functor.map_comp, ‚Üê h‚ÇÉ, ‚Üê Functor.map_comp,\n                Category.assoc]\n        rw [this]\n        rw [Functor.map_comp, h‚ÇÅ, Category.comp_id]\n        exact auxAA tail\n    intro p\n    exact auxAA p\n  -- ‚àÄ p : Quiver.Path Vertex.B Vertex.B, F.map p = ùüô B'\n  ¬∑ let rec auxBB (p : Quiver.Path Vertex.B Vertex.B)\n        : F.map p = ùüô (F.obj Vertex.B) := by\n      match p with\n      | .nil =>\n        exact F.map_id _\n      | .cons (.cons tail (e : Vertex.B ‚ü∂ Vertex.A)) Edge.f =>\n        have : F.map ((tail.cons e).cons Edge.f) =\n               F.map ((Quiver.Hom.toPath Edge.f ‚äö\n                       Quiver.Hom.toPath Edge.g) ‚äö tail) := by\n          rcases e\n          ¬∑ rfl\n          ¬∑ change F.map (Quiver.Hom.toPath Edge.f ‚äö\n                          Quiver.Hom.toPath Edge.h ‚äö tail) = _\n            rw [Functor.map_comp, Functor.map_comp, ‚Üê h‚ÇÉ,\n                ‚Üê Functor.map_comp, ‚Üê Functor.map_comp,\n                Category.assoc]\n        rw [this]\n        rw [Functor.map_comp, h‚ÇÇ, Category.comp_id]\n        exact auxBB tail\n    intro p\n    exact auxBB p\n  -- ‚àÄ p : Quiver.Path Vertex.A Vertex.B, F.map p = f'\n  ¬∑ let rec auxAB (p : Quiver.Path Vertex.A Vertex.B)\n        : F.map p = F.map (Quiver.Hom.toPath Edge.f) := by\n      match p with\n      | .cons .nil Edge.f =>\n        rfl\n      | .cons (.cons tail (e : Vertex.B ‚ü∂ Vertex.A)) Edge.f =>\n        have : F.map ((tail.cons e).cons Edge.f) =\n               F.map ((Quiver.Hom.toPath Edge.f ‚äö\n                       Quiver.Hom.toPath Edge.g) ‚äö tail) := by\n          rcases e\n          ¬∑ rfl\n          ¬∑ change F.map ((Quiver.Hom.toPath Edge.f ‚äö\n                           Quiver.Hom.toPath Edge.h) ‚äö tail) = _\n            rw [Functor.map_comp, Functor.map_comp, ‚Üê h‚ÇÉ,\n                ‚Üê Functor.map_comp, ‚Üê Functor.map_comp]\n        rw [this]\n        rw [Functor.map_comp, h‚ÇÇ, Category.comp_id]\n        exact auxAB tail\n    intro p\n    exact auxAB p\n  -- ‚àÄ p : Quiver.Path Vertex.B Vertex.A, F.map p = g'\n  ¬∑ let rec auxBA (p : Quiver.Path Vertex.B Vertex.A)\n        : F.map p = F.map (Quiver.Hom.toPath Edge.g) := by\n      match p with\n      | .cons .nil (e : Vertex.B ‚ü∂ Vertex.A) =>\n        rcases e\n        ¬∑ rfl\n        ¬∑ rw [h‚ÇÉ]\n          rfl\n      | .cons (.cons tail Edge.f) (e : Vertex.B ‚ü∂ Vertex.A) =>\n        have : F.map ((tail.cons Edge.f).cons e) =\n               F.map ((Quiver.Hom.toPath Edge.g ‚äö\n                       Quiver.Hom.toPath Edge.f) ‚äö tail) := by\n          rcases e\n          ¬∑ rfl\n          ¬∑ change F.map ((Quiver.Hom.toPath Edge.h ‚äö\n                           Quiver.Hom.toPath Edge.f) ‚äö tail) = _\n            rw [Functor.map_comp, Functor.map_comp, ‚Üê h‚ÇÉ,\n                ‚Üê Functor.map_comp, ‚Üê Functor.map_comp]\n        rw [this]\n        rw [Functor.map_comp, h‚ÇÅ, Category.comp_id]\n        exact auxBA tail\n    intro p\n    exact auxBA p\n(b) A shortest list of equations that will make diagram (b) commute is:\nhgf = 1_A, \\quad fhg = 1_B, \\quad gfh = 1_CSince there are now nine possible pairings of dots, we change our approach from Exercises 2 and 4(a) above and instead employ a more efficient proof by induction.inductive Vertex\n  | A | B | C\n\ninductive Edge : Vertex ‚Üí Vertex ‚Üí Type\n  | f : Edge .A .B\n  | g : Edge .B .C\n  | h : Edge .C .A\n\ninstance : Quiver Vertex where\n  Hom := Edge\n\nexample {ùíû : Type u} [Category.{v, u} ùíû] (F : Paths Vertex ‚•§ ùíû) :\n\n    -- Let A' be the object in ùíû associated with Vertex.A in ùêπ(G)\n    let A' : ùíû := F.obj Vertex.A\n    -- Let B' be the object in ùíû associated with Vertex.B in ùêπ(G)\n    let B' : ùíû := F.obj Vertex.B\n    -- Let C' be the object in ùíû associated with Vertex.C in ùêπ(G)\n    let C' : ùíû := F.obj Vertex.C\n    -- Let f' be the morphism in ùíû associated with Edge.f in ùêπ(G)\n    let f' : A' ‚ü∂ B' := F.map (Quiver.Hom.toPath Edge.f)\n    -- Let g' be the morphism in ùíû associated with Edge.g in ùêπ(G)\n    let g' : B' ‚ü∂ C' := F.map (Quiver.Hom.toPath Edge.g)\n    -- Let h' be the morphism in ùíû associated with Edge.h in ùêπ(G)\n    let h' : C' ‚ü∂ A' := F.map (Quiver.Hom.toPath Edge.h)\n\n    -- The 3 equations required to make the diagram commute\n    h' ‚äö g' ‚äö f' = ùüô A' ‚àß\n    f' ‚äö h' ‚äö g' = ùüô B' ‚àß\n    g' ‚äö f' ‚äö h' = ùüô C' ‚Üí\n    -- .A ‚ü∂ .A is interpreted as the identity on A' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.A, F.map p = ùüô A') ‚àß\n    -- .B ‚ü∂ .B is interpreted as the identity on B' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.B, F.map p = ùüô B') ‚àß\n    -- .C ‚ü∂ .C is interpreted as the identity on C' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.C Vertex.C, F.map p = ùüô C') ‚àß\n    -- .A ‚ü∂ .B is interpreted as f' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.B, F.map p = f') ‚àß\n    -- .B ‚ü∂ .C is interpreted as g' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.C, F.map p = g') ‚àß\n    -- .C ‚ü∂ .A is interpreted as h' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.C Vertex.A, F.map p = h') ‚àß\n    -- .A ‚ü∂ .C is interpreted as g' ‚äö f' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.C, F.map p = g' ‚äö f') ‚àß\n    -- .B ‚ü∂ .A is interpreted as h' ‚äö g' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.A, F.map p = h' ‚äö g') ‚àß\n    -- .C ‚ü∂ .B is interpreted as f' ‚äö h' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.C Vertex.B, F.map p = f' ‚äö h') := by\n\n  intro A' B' C' f' g' h' ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©\n  suffices ‚àÄ {u v : Vertex} (p : Quiver.Path u v), F.map p =\n    match u, v with\n    | .A, .A => ùüô A'\n    | .B, .B => ùüô B'\n    | .C, .C => ùüô C'\n    | .A, .B => f'\n    | .B, .C => g'\n    | .C, .A => h'\n    | .A, .C => g' ‚äö f'\n    | .B, .A => h' ‚äö g'\n    | .C, .B => f' ‚äö h' by\n    simp [this]\n  dsimp [A', B', C', f', g', h'] at h‚ÇÅ h‚ÇÇ h‚ÇÉ\n  intro u v p\n  induction p with\n  | nil =>\n    cases u\n    all_goals\n      dsimp\n      exact F.map_id _\n  | cons p e ih =>\n    change F.map (Quiver.Hom.toPath e ‚äö p) = _\n    rw [F.map_comp, ih]\n    cases u <;> rcases e\n    all_goals\n      dsimp [A', B', C', f', g', h']\n      try rw [Category.id_comp]\n      try first | rw [h‚ÇÅ] | rw [h‚ÇÇ] | rw [h‚ÇÉ]\n(c) A shortest list of equations that will make diagram (c) commute is:\njhg = 1_A, \\quad gjh = 1_B, \\quad hgj = 1_C, \\quad f = g, \\quad i = 1_Cinductive Vertex\n  | A | B | C\n\ninductive Edge : Vertex ‚Üí Vertex ‚Üí Type\n  | f : Edge .A .B\n  | g : Edge .A .B\n  | h : Edge .B .C\n  | i : Edge .C .C\n  | j : Edge .C .A\n\ninstance : Quiver Vertex where\n  Hom := Edge\n\nexample {ùíû : Type u} [Category.{v, u} ùíû] (F : Paths Vertex ‚•§ ùíû) :\n\n    -- Let A' be the object in ùíû associated with Vertex.A in ùêπ(G)\n    let A' : ùíû := F.obj Vertex.A\n    -- Let B' be the object in ùíû associated with Vertex.B in ùêπ(G)\n    let B' : ùíû := F.obj Vertex.B\n    -- Let C' be the object in ùíû associated with Vertex.C in ùêπ(G)\n    let C' : ùíû := F.obj Vertex.C\n    -- Let f' be the morphism in ùíû associated with Edge.f in ùêπ(G)\n    let f' : A' ‚ü∂ B' := F.map (Quiver.Hom.toPath Edge.f)\n    -- Let g' be the morphism in ùíû associated with Edge.g in ùêπ(G)\n    let g' : A' ‚ü∂ B' := F.map (Quiver.Hom.toPath Edge.g)\n    -- Let h' be the morphism in ùíû associated with Edge.h in ùêπ(G)\n    let h' : B' ‚ü∂ C' := F.map (Quiver.Hom.toPath Edge.h)\n    -- Let i' be the morphism in ùíû associated with Edge.i in ùêπ(G)\n    let i' : C' ‚ü∂ C' := F.map (Quiver.Hom.toPath Edge.i)\n    -- Let j' be the morphism in ùíû associated with Edge.j in ùêπ(G)\n    let j' : C' ‚ü∂ A' := F.map (Quiver.Hom.toPath Edge.j)\n\n    -- The 5 equations required to make the diagram commute\n    j' ‚äö h' ‚äö g' = ùüô A' ‚àß\n    g' ‚äö j' ‚äö h' = ùüô B' ‚àß\n    h' ‚äö g' ‚äö j' = ùüô C' ‚àß\n    f' = g' ‚àß\n    i' = ùüô C' ‚Üí\n    -- .A ‚ü∂ .A is interpreted as the identity on A' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.A, F.map p = ùüô A') ‚àß\n    -- .B ‚ü∂ .B is interpreted as the identity on B' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.B, F.map p = ùüô B') ‚àß\n    -- .C ‚ü∂ .C is interpreted as the identity on C' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.C Vertex.C, F.map p = ùüô C') ‚àß\n    -- .A ‚ü∂ .B is interpreted as g' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.B, F.map p = g') ‚àß\n    -- .B ‚ü∂ .C is interpreted as h' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.C, F.map p = h') ‚àß\n    -- .C ‚ü∂ .A is interpreted as j' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.C Vertex.A, F.map p = j') ‚àß\n    -- .A ‚ü∂ .C is interpreted as h' ‚äö g' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.A Vertex.C, F.map p = h' ‚äö g') ‚àß\n    -- .B ‚ü∂ .A is interpreted as j' ‚äö h' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.B Vertex.A, F.map p = j' ‚äö h') ‚àß\n    -- .C ‚ü∂ .B is interpreted as g' ‚äö j' in ùíû\n    (‚àÄ p : Quiver.Path Vertex.C Vertex.B, F.map p = g' ‚äö j') := by\n\n  intro A' B' C' f' g' h' i' j' ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ‚ü©\n  suffices ‚àÄ {u v : Vertex} (p : Quiver.Path u v), F.map p =\n    match u, v with\n    | .A, .A => ùüô A'\n    | .B, .B => ùüô B'\n    | .C, .C => ùüô C'\n    | .A, .B => g'\n    | .B, .C => h'\n    | .C, .A => j'\n    | .A, .C => h' ‚äö g'\n    | .B, .A => j' ‚äö h'\n    | .C, .B => g' ‚äö j' by\n    simp [this]\n  dsimp [A', B', C', f', g', h', i', j'] at h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ h‚ÇÖ\n  intro u v p\n  induction p with\n  | nil =>\n    cases u\n    all_goals\n      dsimp\n      exact F.map_id _\n  | cons p e ih =>\n    change F.map (Quiver.Hom.toPath e ‚äö p) = _\n    rw [F.map_comp, ih]\n    cases u <;> rcases e\n    all_goals\n      dsimp [A', B', C', f', g', h', i', j']\n      try rw [h‚ÇÑ]\n      try rw [h‚ÇÖ]\n      try first | rw [Category.comp_id] | rw [Category.id_comp]\n      try first | rw [h‚ÇÅ] | rw [h‚ÇÇ] | rw [h‚ÇÉ]\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 17: Some uses of graphs","header":"3. Commuting diagrams","id":"/Session-17___-Some-uses-of-graphs/#A-Lean-Companion-to-Conceptual-Mathematics--Session-17___-Some-uses-of-graphs--3___-Commuting-diagrams"}});