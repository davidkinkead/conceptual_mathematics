window.docContents[71].resolve({"/Session-15___-Objectification-of-properties-in-dynamical-systems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-15___-Objectification-of-properties-in-dynamical-systems--1___-Structure-preserving-maps-from-a-cycle-to-another-endomap":{"contents":"We say that an element y in Y^{‚Üª\\beta} has period four if {\\beta^4(y) = y}. All elements that have period one or two are included in this, because if {\\beta(y) = y} or {\\beta^2(y) = y}, then also {\\beta^4(y) = y}.\n\n\n\ntheorem period_four_of_period_one {Y : Type} (Œ≤ : End Y) (y : Y)\n    : Œ≤ y = y ‚Üí (Œ≤ ^ 4) y = y := by\n  intro hŒ≤\n  nth_rw 2 [‚Üê hŒ≤, ‚Üê hŒ≤, ‚Üê hŒ≤, ‚Üê hŒ≤]\n  rfl\n\ntheorem period_four_of_period_two {Y : Type} (Œ≤ : End Y) (y : Y)\n    : (Œ≤ ^ 2) y = y ‚Üí (Œ≤ ^ 4) y = y := by\n  intro hŒ≤2\n  nth_rw 2 [‚Üê hŒ≤2, ‚Üê hŒ≤2]\n  rfl\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 15: Objectification of properties in dynamical systems","header":"1. Structure-preserving maps from a cycle to another endomap","id":"/Session-15___-Objectification-of-properties-in-dynamical-systems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-15___-Objectification-of-properties-in-dynamical-systems--1___-Structure-preserving-maps-from-a-cycle-to-another-endomap"},"/Session-17___-Some-uses-of-graphs/#A-Lean-Companion-to-Conceptual-Mathematics--Session-17___-Some-uses-of-graphs--1___-Paths":{"contents":"In the exercises that follow for this Session, we implement the free category ùë≠(G) on each graph G using mathlib's CategoryTheory.Paths V, where V is a quiver (i.e., a directed graph). In particular, we make extensive use of the inductive datatype Quiver.Path, the type of paths through the arrows of the quiver, which we print below for reference.\n\n#print Quiver.Path\n\n\ninductive Quiver.Path.{v, u} : {V : Type u} ‚Üí [Quiver V] ‚Üí V ‚Üí V ‚Üí Sort (max (u + 1) v)\nnumber of parameters: 3\nconstructors:\nQuiver.Path.nil : {V : Type u} ‚Üí [inst : Quiver V] ‚Üí {a : V} ‚Üí Quiver.Path a a\nQuiver.Path.cons : {V : Type u} ‚Üí [inst : Quiver V] ‚Üí {a b c : V} ‚Üí Quiver.Path a b ‚Üí (b ‚ü∂ c) ‚Üí Quiver.Path a c\n\n\nDanilo noticed that from a graph G we can build a category ùë≠(G), the free category on the graph G. An object is a dot of G, and a map is a path in G. For which of the following graphs does Danilo's category have a terminal object?\n\nAn object S is terminal in a category if for each object X in the category there is exactly one map from X to S. Only the free category ùë≠(G_b) on the graph (b) and the free category ùë≠(G_c) on the graph (c) have objects that meet this criterion.(a) ùë≠(G_a) has infinitely many maps from the object to itself (each map corresponding to the path formed by going around the arrow/loop a different number of times).inductive Dot\n  | x‚ÇÅ\n\ninductive Arrow : Dot ‚Üí Dot ‚Üí Type\n  | f‚ÇÅ : Arrow .x‚ÇÅ .x‚ÇÅ\n\ninstance : Quiver Dot where\n  Hom := Arrow\n\nopen Limits in\nexample : ¬¨(HasTerminal (Paths Dot)) := by\n  by_contra h\n  have h_uniq : Unique (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ) :=\n    uniqueToTerminal (C := Paths Dot) Dot.x‚ÇÅ\n  have h_sub : Subsingleton (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ) :=\n    inferInstance\n  have h_nontriv : Nontrivial (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ) := by\n    apply nontrivial_iff.mpr\n    use Quiver.Path.nil, (Quiver.Hom.toPath Arrow.f‚ÇÅ)\n    intro\n    contradiction\n  exact false_of_nontrivial_of_subsingleton\n      (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ)\n(b) The only object in ùë≠(G_b) is terminal, since there is exactly one map from that object to itself, namely the identity map.inductive Dot\n  | x‚ÇÅ\n\ninductive Arrow : Dot ‚Üí Dot ‚Üí Type\n\ninstance : Quiver Dot where\n  Hom := Arrow\n\nopen Limits in\nexample : HasTerminal (Paths Dot) := by\n  have h_all_sub\n      : ‚àÄ (x : Paths Dot), Subsingleton (x ‚ü∂ Dot.x‚ÇÅ) := by\n    intro x\n    apply Subsingleton.intro\n    intro f g\n    let P : {x : Paths Dot} ‚Üí (x ‚ü∂ Dot.x‚ÇÅ) ‚Üí Prop :=\n      fun p => p = Quiver.Path.nil\n    have h_all_eq_id : ‚àÄ {x : Paths Dot} (p : x ‚ü∂ Dot.x‚ÇÅ), P p := by\n      intros\n      apply Paths.induction_fixed_target\n      ¬∑ rfl\n      ¬∑ intro _ _ _ e _\n        nomatch e\n    rw [h_all_eq_id f, h_all_eq_id g]\n  have h_all_nonempty\n      : ‚àÄ (x : Paths Dot), Nonempty (x ‚ü∂ Dot.x‚ÇÅ) := by\n    intro x\n    exact Nonempty.intro Quiver.Path.nil\n  exact hasTerminal_of_unique (C := Paths Dot) Dot.x‚ÇÅ\n(c) In ùë≠(G_c), the second dot from the right corresponds to a terminal object, since there is exactly one map (path) to that object from every object in ùë≠(G_c). We label the dots from left to right, with x_1 being the upper left dot and x_2 the lower left dot (so x_4 is terminal).inductive Dot\n  | x‚ÇÅ | x‚ÇÇ | x‚ÇÉ | x‚ÇÑ | x‚ÇÖ\n\ninductive Arrow : Dot ‚Üí Dot ‚Üí Type\n  | f‚ÇÅ : Arrow .x‚ÇÅ .x‚ÇÉ\n  | f‚ÇÇ : Arrow .x‚ÇÇ .x‚ÇÉ\n  | f‚ÇÉ : Arrow .x‚ÇÉ .x‚ÇÑ\n  | f‚ÇÖ : Arrow .x‚ÇÖ .x‚ÇÑ\n\ninstance : Quiver Dot where\n  Hom := Arrow\n\nopen Limits in\nexample : HasTerminal (Paths Dot) := by\n  have h_all_sub\n      : ‚àÄ (x : Paths Dot), Subsingleton (x ‚ü∂ Dot.x‚ÇÑ) := by\n    intro x\n    apply Subsingleton.intro\n    intro f g\n    cases x\n    all_goals\n      repeat first\n      | (rcases f with _ | ‚ü®f, _, _‚ü©) -- deconstruct f\n      | (rcases g with _ | ‚ü®g, _, _‚ü©) -- deconstruct g\n      | contradiction\n      | rfl\n  have h_all_nonempty\n      : ‚àÄ (x : Paths Dot), Nonempty (x ‚ü∂ Dot.x‚ÇÑ) := by\n    intro x\n    cases x\n    ¬∑ exact Nonempty.intro\n          ((Quiver.Hom.toPath Arrow.f‚ÇÅ).cons Arrow.f‚ÇÉ)\n    ¬∑ exact Nonempty.intro\n          ((Quiver.Hom.toPath Arrow.f‚ÇÇ).cons Arrow.f‚ÇÉ)\n    ¬∑ exact Nonempty.intro\n          (Quiver.Hom.toPath Arrow.f‚ÇÉ)\n    ¬∑ exact Nonempty.intro\n          Quiver.Path.nil\n    ¬∑ exact Nonempty.intro\n          (Quiver.Hom.toPath Arrow.f‚ÇÖ)\n  exact hasTerminal_of_unique (C := Paths Dot) Dot.x‚ÇÑ\n(d) ùë≠(G_d) is similar to ùë≠(G_a) in that each object of ùë≠(G_d) has infinitely many maps from itself to itself and from the other object to itself (each map corresponding to the path formed by going a different number of times around the closed loop of arrows between the two objects).inductive Dot\n  | x‚ÇÅ | x‚ÇÇ\n\ninductive Arrow : Dot ‚Üí Dot ‚Üí Type\n  | f‚ÇÅ : Arrow .x‚ÇÅ .x‚ÇÇ\n  | f‚ÇÇ : Arrow .x‚ÇÇ .x‚ÇÅ\n\ninstance : Quiver Dot where\n  Hom := Arrow\n\nopen Limits in\nexample : ¬¨(HasTerminal (Paths Dot)) := by\n  by_contra h\n  have h_all_uniq\n      : ‚àÄ (x : Paths Dot), Unique (x ‚ü∂ ‚ä§_ Paths Dot) := by\n    intro x\n    exact uniqueToTerminal x\n  have h_all_sub\n      : ‚àÄ (x : Paths Dot), Subsingleton (x ‚ü∂ ‚ä§_ Paths Dot) := by\n    intro x\n    infer_instance\n  have h_nontriv‚ÇÅ : Nontrivial (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ) := by\n    apply nontrivial_iff.mpr\n    use Quiver.Path.nil, ((Quiver.Hom.toPath Arrow.f‚ÇÅ).cons Arrow.f‚ÇÇ)\n    intro\n    contradiction\n  have h_nontriv‚ÇÇ : Nontrivial (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÇ) := by\n    apply nontrivial_iff.mpr\n    use Quiver.Path.nil, ((Quiver.Hom.toPath Arrow.f‚ÇÇ).cons Arrow.f‚ÇÅ)\n    intro\n    contradiction\n  cases hx : ‚ä§_ (Paths Dot) <;> rw [hx] at h_all_sub\n  ¬∑ exact false_of_nontrivial_of_subsingleton\n        (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÅ)\n  ¬∑ exact false_of_nontrivial_of_subsingleton\n        (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÇ)\n(e) In ùë≠(G_e), the left-hand object has no map from the right-hand object, while the right-hand object has two maps from the left-hand object. We label the dots from left to right.inductive Dot\n  | x‚ÇÅ | x‚ÇÇ\n\ninductive Arrow : Dot ‚Üí Dot ‚Üí Type\n  | f‚ÇÅ : Arrow .x‚ÇÅ .x‚ÇÇ\n  | f‚ÇÇ : Arrow .x‚ÇÅ .x‚ÇÇ\n\ninstance : Quiver Dot where\n  Hom := Arrow\n\nopen Limits in\nexample : ¬¨(HasTerminal (Paths Dot)) := by\n  by_contra h\n  have h_all_uniq\n      : ‚àÄ (x : Paths Dot), Unique (x ‚ü∂ ‚ä§_ Paths Dot) := by\n    intro x\n    exact uniqueToTerminal x\n  have h_all_sub\n      : ‚àÄ (x : Paths Dot), Subsingleton (x ‚ü∂ ‚ä§_ Paths Dot) := by\n    intro x\n    infer_instance\n  have h_empty‚ÇÅ : ¬¨(Nonempty (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÅ)) := by\n    by_contra h_empty\n    rcases h_empty with ‚ü®p‚ü©\n    nomatch p\n  have h_nontriv‚ÇÇ : Nontrivial (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÇ) := by\n    apply nontrivial_iff.mpr\n    use (Quiver.Hom.toPath Arrow.f‚ÇÅ), (Quiver.Hom.toPath Arrow.f‚ÇÇ)\n    intro H\n    injection H with _ h_arrow\n    contradiction\n  cases hx : ‚ä§_ (Paths Dot)\n  ¬∑ rw [hx] at h_all_uniq h_all_sub\n    have h_uniq‚ÇÅ : Unique (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÅ) :=\n      h_all_uniq Dot.x‚ÇÇ\n    have h_nonempty‚ÇÅ : Nonempty (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÅ) := by\n      infer_instance\n    contradiction\n  ¬∑ rw [hx] at h_all_sub\n    exact false_of_nontrivial_of_subsingleton\n        (Quiver.Path Dot.x‚ÇÅ Dot.x‚ÇÇ)\n(f) In ùë≠(G_f), neither the leftmost object nor the centre object has a map from the rightmost object, while the rightmost object has no map from either the leftmost object nor the centre object. We label the dots from left to right again.inductive Dot\n  | x‚ÇÅ | x‚ÇÇ | x‚ÇÉ\n\ninductive Arrow : Dot ‚Üí Dot ‚Üí Type\n  | f‚ÇÅ : Arrow .x‚ÇÇ .x‚ÇÅ\n\ninstance : Quiver Dot where\n  Hom := Arrow\n\nopen Limits in\nexample : ¬¨(HasTerminal (Paths Dot)) := by\n  by_contra h\n  have h_all_uniq\n      : ‚àÄ (x : Paths Dot), Unique (x ‚ü∂ ‚ä§_ Paths Dot) := by\n    intro x\n    exact uniqueToTerminal x\n  have h_all_sub\n      : ‚àÄ (x : Paths Dot), Subsingleton (x ‚ü∂ ‚ä§_ Paths Dot) := by\n    intro x\n    infer_instance\n  have h_empty‚ÇÅ : ¬¨(Nonempty (Quiver.Path Dot.x‚ÇÉ Dot.x‚ÇÅ)) := by\n    by_contra h_empty\n    rcases h_empty with ‚ü®p‚ü©\n    match p with\n    | .cons p' q =>\n      match p' with\n      | .nil =>\n      nomatch q\n  have h_empty‚ÇÇ : ¬¨(Nonempty (Quiver.Path Dot.x‚ÇÉ Dot.x‚ÇÇ)) := by\n    by_contra h_empty\n    rcases h_empty with ‚ü®p‚ü©\n    nomatch p\n  have h_empty‚ÇÉ : ¬¨(Nonempty (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÉ)) := by\n    by_contra h_empty\n    rcases h_empty with ‚ü®p‚ü©\n    nomatch p\n  cases hx : ‚ä§_ (Paths Dot) <;> rw [hx] at h_all_uniq h_all_sub\n  ¬∑ have h_uniq‚ÇÅ : Unique (Quiver.Path Dot.x‚ÇÉ Dot.x‚ÇÅ) :=\n      h_all_uniq Dot.x‚ÇÉ\n    have h_nonempty‚ÇÇ : Nonempty (Quiver.Path Dot.x‚ÇÉ Dot.x‚ÇÅ) := by\n      infer_instance\n    contradiction\n  ¬∑ have h_uniq‚ÇÇ : Unique (Quiver.Path Dot.x‚ÇÉ Dot.x‚ÇÇ) :=\n      h_all_uniq Dot.x‚ÇÉ\n    have h_nonempty‚ÇÇ : Nonempty (Quiver.Path Dot.x‚ÇÉ Dot.x‚ÇÇ) := by\n      infer_instance\n    contradiction\n  ¬∑ have h_uniq‚ÇÉ : Unique (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÉ) :=\n      h_all_uniq Dot.x‚ÇÇ\n    have h_nonempty‚ÇÉ : Nonempty (Quiver.Path Dot.x‚ÇÇ Dot.x‚ÇÉ) := by\n      infer_instance\n    contradiction\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 17: Some uses of graphs","header":"1. Paths","id":"/Session-17___-Some-uses-of-graphs/#A-Lean-Companion-to-Conceptual-Mathematics--Session-17___-Some-uses-of-graphs--1___-Paths"}});