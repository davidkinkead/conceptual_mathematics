window.docContents[168].resolve({"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--10___-Retractions-and-injectivity":{"contents":"We say that a map {X \\xrightarrow{a} Y} is injective iff for any maps {T \\xrightarrow{x_1} X} and {T \\xrightarrow{x_2} X} (in the same category) if {ax_1 = ax_2} then {x_1 = x_2} (or, in contrapositive form, 'the map a does not destroy distinctions', i.e. if {x_1 \\ne x_2}..., then {ax_1 \\ne ax_2} as well).\n\ncf. the earlier definition of injective on p. 52.\n\nIf a has a retraction, then a is injective. (Assume {pa = 1_X} and {ax_1 = ax_2}; then try to show by calculation that {x_1 = x_2}.)\n\ncf. mono_iff_injective.example {ğ’ : Type u} [Category.{v, u} ğ’] {X Y T : ğ’}\n    {a : X âŸ¶ Y} {p : Y âŸ¶ X} {xâ‚ xâ‚‚ : T âŸ¶ X}\n    (hâ‚ : p âŠš a = ğŸ™ X) (hâ‚‚ : a âŠš xâ‚ = a âŠš xâ‚‚)\n    : xâ‚ = xâ‚‚ := by\n  calc xâ‚\n    _ = ğŸ™ X âŠš xâ‚ := by rw [Category.comp_id]\n    _ = (p âŠš a) âŠš xâ‚ := by rw [hâ‚]\n    _ = p âŠš a âŠš xâ‚ := by rw [Category.assoc]\n    _ = p âŠš a âŠš xâ‚‚ := by rw [hâ‚‚]\n    _ = (p âŠš a) âŠš xâ‚‚ := by rw [Category.assoc]\n    _ = ğŸ™ X âŠš xâ‚‚ := by rw [hâ‚]\n    _ = xâ‚‚ := by rw [Category.comp_id]\n\n\nExercises 19â€“24 that follow relate to the sets X and Y, the endomaps \\alpha and \\beta, and the map a as defined below. (Note that we in fact define X and Y as finite types rather than finite sets.)\n\n\n\ninductive X\n  | xâ‚€ | xâ‚\n  deriving Fintype\n\ninductive Y\n  | yâ‚€ | yâ‚ | yâ‚‚\n  deriving Fintype\n\ndef Î± : X âŸ¶ X\n  | X.xâ‚€ => X.xâ‚€\n  | X.xâ‚ => X.xâ‚€\n\ndef Î² : Y âŸ¶ Y\n  | Y.yâ‚€ => Y.yâ‚€\n  | Y.yâ‚ => Y.yâ‚€\n  | Y.yâ‚‚ => Y.yâ‚\n\ndef a : X âŸ¶ Y\n  | X.xâ‚€ => Y.yâ‚€\n  | X.xâ‚ => Y.yâ‚\n\n\nShow that a is a map {X^{â†»\\alpha} \\xrightarrow{a} Y^{â†»\\beta}} in ğ‘ºâ†».\n\na is a map in ğ‘ºâ†» if it satisfies the condition {a \\alpha = \\beta a}.example : a âŠš Î± = Î² âŠš a := by\n  funext x\n  cases x <;> rfl\nOr, alternatively, using the categorical framework we defined earlier, a is a map in ğ‘ºâ†» if it is a morphism in our category of endomaps of sets.def XÎ± : SetWithEndomap := {\n  t := X\n  carrier := Set.univ\n  toEnd := Î±\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef YÎ² : SetWithEndomap := {\n  t := Y\n  carrier := Set.univ\n  toEnd := Î²\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef a' : XÎ± âŸ¶ YÎ² := âŸ¨\n  a,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\n\n\nShow that a is injective.\n\ncf. Exercise 18 above.example : âˆ€ {T : Type} (xâ‚ xâ‚‚ : T âŸ¶ X),\n    a âŠš xâ‚ = a âŠš xâ‚‚ â†’ xâ‚ = xâ‚‚ := by\n  let p : Y âŸ¶ X\n    | Y.yâ‚€ => X.xâ‚€\n    | Y.yâ‚ => X.xâ‚\n    | Y.yâ‚‚ => X.xâ‚\n  have hâ‚ : p âŠš a = ğŸ™ X := by\n    funext x\n    cases x <;> rfl\n  intro _ xâ‚ xâ‚‚ hâ‚‚\n  calc xâ‚\n    _ = ğŸ™ X âŠš xâ‚ := by rw [Category.comp_id]\n    _ = (p âŠš a) âŠš xâ‚ := by rw [hâ‚]\n    _ = p âŠš a âŠš xâ‚ := by rw [Category.assoc]\n    _ = p âŠš a âŠš xâ‚‚ := by rw [hâ‚‚]\n    _ = (p âŠš a) âŠš xâ‚‚ := by rw [Category.assoc]\n    _ = ğŸ™ X âŠš xâ‚‚ := by rw [hâ‚]\n    _ = xâ‚‚ := by rw [Category.comp_id]\n\n\nShow that, as a map {X \\xrightarrow{a} Y} in ğ‘º, a has exactly two retractions p.\n\nWe found one retraction p_1 in Exercise 20.def pâ‚ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚€\n  | Y.yâ‚ => X.xâ‚\n  | Y.yâ‚‚ => X.xâ‚\n\nexample : pâ‚ âŠš a = ğŸ™ X := by\n  funext x\n  cases x <;> rfl\nUsing p_1 with Danilo's formula, we find that a has exactly two retractions.#eval Danilo's_formula (Finset.univ) (Finset.univ) a pâ‚\n  (by funext x; fin_cases x <;> rfl)\n  (by intro x y _; fin_cases x <;> fin_cases y <;>\n    (first | rfl | simp; trivial))\n2\nThe other retraction p_2 isdef pâ‚‚ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚€\n  | Y.yâ‚ => X.xâ‚\n  | Y.yâ‚‚ => X.xâ‚€\n\nexample : pâ‚‚ âŠš a = ğŸ™ X := by\n  funext x\n  cases x <;> rfl\n\n\nShow that neither of the maps p found in the preceding exercise is a map {Y^{â†»\\beta} \\rightarrow X^{â†»\\alpha}} in ğ‘ºâ†». Hence a has no retractions in ğ‘ºâ†».\n\np_1 is not a map {Y^{â†»\\beta} \\rightarrow X^{â†»\\alpha}} in ğ‘ºâ†».example : Â¬(pâ‚ âŠš Î² = Î± âŠš pâ‚) := by\n  intro h\n  have h_contra : (pâ‚ âŠš Î²) Y.yâ‚‚ = (Î± âŠš pâ‚) Y.yâ‚‚ := congrFun h Y.yâ‚‚\n  dsimp [pâ‚, Î±, Î²] at h_contra\n  contradiction\np_2 is not a map {Y^{â†»\\beta} \\rightarrow X^{â†»\\alpha}} in ğ‘ºâ†».example : Â¬(pâ‚‚ âŠš Î² = Î± âŠš pâ‚‚) := by\n  intro h\n  have h_contra : (pâ‚‚ âŠš Î²) Y.yâ‚‚ = (Î± âŠš pâ‚‚) Y.yâ‚‚ := congrFun h Y.yâ‚‚\n  dsimp [pâ‚‚, Î±, Î²] at h_contra\n  contradiction\nSince, by Exercise 21, p_1 and p_2 are the only retractions of a in ğ‘º, they are the only candidates for retractions of a in ğ‘ºâ†»; hence a has no retractions in ğ‘ºâ†».\n\nHow many of the eight ğ‘º-maps {Y \\rightarrow X} (if any) are actually ğ‘ºâ†»-maps?\nY^{â†»\\beta} \\rightarrow X^{â†»\\alpha}\n\nFor an ğ‘º-map b to be an ğ‘ºâ†»-map, we require that {b \\beta = \\alpha b}. Since {\\alpha b = x_0}, it follows that we require {b \\beta = x_0}. That is, we require {b(y_0) = x_0} and {b(y_1) = x_0}, which leaves b(y_2) as the only degree of freedom. Hence just two of the eight ğ‘º-maps {Y \\rightarrow X} are actually ğ‘ºâ†»-maps {Y^{â†»\\beta} \\rightarrow X^{â†»\\alpha}}, as given below.The ğ‘º-maps b_1 and b_2 are ğ‘ºâ†»-maps.def bâ‚ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚€\n  | Y.yâ‚ => X.xâ‚€\n  | Y.yâ‚‚ => X.xâ‚€\n\nexample : bâ‚ âŠš Î² = Î± âŠš bâ‚ := by\n  funext y\n  cases y <;> rfl\n\ndef bâ‚‚ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚€\n  | Y.yâ‚ => X.xâ‚€\n  | Y.yâ‚‚ => X.xâ‚\n\nexample : bâ‚‚ âŠš Î² = Î± âŠš bâ‚‚ := by\n  funext y\n  cases y <;> rfl\nThe remaining ğ‘º-maps b_3 to b_8 are not ğ‘ºâ†»-maps.def bâ‚ƒ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚\n  | Y.yâ‚ => X.xâ‚€\n  | Y.yâ‚‚ => X.xâ‚€\n\nexample : bâ‚ƒ âŠš Î² â‰  Î± âŠš bâ‚ƒ := by\n  by_contra h\n  have h_contra : (bâ‚ƒ âŠš Î²) Y.yâ‚€ = (Î± âŠš bâ‚ƒ) Y.yâ‚€ := congrFun h Y.yâ‚€\n  dsimp [bâ‚ƒ, Î±, Î²] at h_contra\n  contradiction\n\ndef bâ‚„ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚\n  | Y.yâ‚ => X.xâ‚€\n  | Y.yâ‚‚ => X.xâ‚\n\nexample : bâ‚„ âŠš Î² â‰  Î± âŠš bâ‚„ := by\n  by_contra h\n  have h_contra : (bâ‚„ âŠš Î²) Y.yâ‚€ = (Î± âŠš bâ‚„) Y.yâ‚€ := congrFun h Y.yâ‚€\n  dsimp [bâ‚„, Î±, Î²] at h_contra\n  contradiction\n\ndef bâ‚… : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚€\n  | Y.yâ‚ => X.xâ‚\n  | Y.yâ‚‚ => X.xâ‚€\n\nexample : bâ‚… âŠš Î² â‰  Î± âŠš bâ‚… := by\n  by_contra h\n  have h_contra : (bâ‚… âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚…) Y.yâ‚‚ := congrFun h Y.yâ‚‚\n  dsimp [bâ‚…, Î±, Î²] at h_contra\n  contradiction\n\ndef bâ‚† : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚€\n  | Y.yâ‚ => X.xâ‚\n  | Y.yâ‚‚ => X.xâ‚\n\nexample : bâ‚† âŠš Î² â‰  Î± âŠš bâ‚† := by\n  by_contra h\n  have h_contra : (bâ‚† âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚†) Y.yâ‚‚ := congrFun h Y.yâ‚‚\n  dsimp [bâ‚†, Î±, Î²] at h_contra\n  contradiction\n\ndef bâ‚‡ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚\n  | Y.yâ‚ => X.xâ‚\n  | Y.yâ‚‚ => X.xâ‚€\n\nexample : bâ‚‡ âŠš Î² â‰  Î± âŠš bâ‚‡ := by\n  by_contra h\n  have h_contra : (bâ‚‡ âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚‡) Y.yâ‚‚ := congrFun h Y.yâ‚‚\n  dsimp [bâ‚‡, Î±, Î²] at h_contra\n  contradiction\n\ndef bâ‚ˆ : Y âŸ¶ X\n  | Y.yâ‚€ => X.xâ‚\n  | Y.yâ‚ => X.xâ‚\n  | Y.yâ‚‚ => X.xâ‚\n\nexample : bâ‚ˆ âŠš Î² â‰  Î± âŠš bâ‚ˆ := by\n  by_contra h\n  have h_contra : (bâ‚ˆ âŠš Î²) Y.yâ‚‚ = (Î± âŠš bâ‚ˆ) Y.yâ‚‚ := congrFun h Y.yâ‚‚\n  dsimp [bâ‚ˆ, Î±, Î²] at h_contra\n  contradiction\n\n\nShow that our map a does not have any retractions, even when considered (via the insertion J in Section 7 of this article) as being a map in the 'looser' category ğ‘ºâ†“.\n\nEmulating the insertion J,def X' : SimpleGraph := {\n  tA := X\n  carrierA := Set.univ\n  tD := X\n  carrierD := Set.univ\n  toFun := Î±\n  toFun_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef Y' : SimpleGraph := {\n  tA := Y\n  carrierA := Set.univ\n  tD := Y\n  carrierD := Set.univ\n  toFun := Î²\n  toFun_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef a'' : X' âŸ¶ Y' := âŸ¨\n  (a, a),\n  by\n    split_ands\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nwe can show that a has no retractions.example : Â¬(âˆƒ p : Y' âŸ¶ X', p âŠš a'' = ğŸ™ X') := by\n  push_neg\n  intro p\n  obtain âŸ¨p, _, _, hp_commâŸ© := p\n  dsimp [X', Y'] at hp_comm\n  have hpÎ²â‚€ : âˆ€ y, (Î± âŠš p.1) y = X.xâ‚€ := by\n    intro y\n    dsimp [Î±]\n    cases p.1 y <;> rfl\n  rw [â† hp_comm] at hpÎ²â‚€\n  dsimp [Y'] at hpÎ²â‚€\n  have hpÎ² : p.2 (Î² Y.yâ‚‚) = X.xâ‚€ := hpÎ²â‚€ Y.yâ‚‚\n  have hÎ² : Î² Y.yâ‚‚ = Y.yâ‚ := rfl\n  rw [hÎ²] at hpÎ²\n  dsimp [CategoryStruct.comp, CategoryStruct.id, a'']\n  by_contra hâ‚\n  have hâ‚‚ : (p.1 âŠš a, p.2 âŠš a) = (ğŸ™ X, ğŸ™ X) :=\n    congrArg Subtype.val hâ‚\n  have hâ‚ƒ : p.2 âŠš a = ğŸ™ X := congrArg Prod.snd hâ‚‚\n  have hpaâ‚€ : âˆ€ x, p.2 (a x) = x := congrFun hâ‚ƒ\n  have hpa : p.2 (a X.xâ‚) = X.xâ‚ := hpaâ‚€ X.xâ‚\n  have ha : a X.xâ‚ = Y.yâ‚ := rfl\n  rw [ha] at hpa\n  rw [hpÎ²] at hpa\n  contradiction\nOr, alternatively, using our functor J defined earlier,example : Â¬(âˆƒ p : YÎ² âŸ¶ XÎ±, J p âŠš J a' = J (ğŸ™ XÎ±)) := by\n  push_neg\n  intro p\n  obtain âŸ¨p, _, hp_commâŸ© := p\n  dsimp [XÎ±, YÎ²] at hp_comm\n  have hpÎ²â‚€ : âˆ€ y, (Î± âŠš p) y = X.xâ‚€ := by\n    intro y\n    dsimp [Î±]\n    cases p y <;> rfl\n  rw [â† hp_comm] at hpÎ²â‚€\n  dsimp [YÎ²] at hpÎ²â‚€\n  have hpÎ² : p (Î² Y.yâ‚‚) = X.xâ‚€ := hpÎ²â‚€ Y.yâ‚‚\n  have hÎ² : Î² Y.yâ‚‚ = Y.yâ‚ := rfl\n  rw [hÎ²] at hpÎ²\n  dsimp [CategoryStruct.comp, CategoryStruct.id, a', J,\n      functorSetWithEndomapToSimpleGraph]\n  by_contra hâ‚\n  have hâ‚‚ : (p âŠš a, p âŠš a) = (ğŸ™ X, ğŸ™ X) :=\n    congrArg Subtype.val hâ‚\n  have hâ‚ƒ : p âŠš a = ğŸ™ X := congrArg Prod.snd hâ‚‚\n  have hpaâ‚€ : âˆ€ x, p (a x) = x := congrFun hâ‚ƒ\n  have hpa : p (a X.xâ‚) = X.xâ‚ := hpaâ‚€ X.xâ‚\n  have ha : a X.xâ‚ = Y.yâ‚ := rfl\n  rw [ha] at hpa\n  rw [hpÎ²] at hpa\n  contradiction\n\n\n\n\nShow that for any two graphs and any ğ‘ºâ‡Š-map between them\nX \\xrightarrow{f_A} Y,\\; P \\xrightarrow{f_D} Q,\\; X \\xrightarrow{s} P,\\; X \\xrightarrow{t} P,\\; Y \\xrightarrow{s'} Q,\\; Y \\xrightarrow{t'} Q\nthe equation {f_D \\circ s = f_D \\circ t} can only be true when f_A maps every arrow in X to a loop (relative to s', t') in Y.\n\nWe first give a proof without using Category IrreflexiveGraph that we defined previously.example {X P Y Q : Type}\n    (s t : X âŸ¶ P) (s' t' : Y âŸ¶ Q) (fA : X âŸ¶ Y) (fD : P âŸ¶ Q)\n    (hfSrc_comm : fD âŠš s = s' âŠš fA) (hfTgt_comm : fD âŠš t = t' âŠš fA)\n    : fD âŠš s = fD âŠš t â†” âˆ€ x, s' (fA x) = t' (fA x) := by\n  constructor\n  Â· intro h x\n    change (s' âŠš fA) x = (t' âŠš fA) x\n    rw [â† hfSrc_comm, â† hfTgt_comm]\n    exact congrFun h x\n  Â· intro h\n    rw [hfSrc_comm, hfTgt_comm]\n    funext x\n    exact h x\nUsing Category IrreflexiveGraph, we havevariable (XP YQ : IrreflexiveGraph) (f : XP âŸ¶ YQ)\n\n-- Align to the notation in the book\nset_option quotPrecheck false\nlocal notation \"fA\" => f.val.1\nlocal notation \"fD\" => f.val.2\nset_option quotPrecheck true\n\nlocal notation \"s\" => XP.toSrc\nlocal notation \"s'\" => YQ.toSrc\nlocal notation \"t\" => XP.toTgt\nlocal notation \"t'\" => YQ.toTgt\n\nexample : (fD âŠš s = fD âŠš t) â†” (âˆ€ x, s' (fA x) = t' (fA x)) := by\n  obtain âŸ¨f, _, _, hfSrc_comm, hfTgt_commâŸ© := f\n  dsimp\n  constructor\n  Â· intro h x\n    change (s' âŠš f.1) x = (t' âŠš f.1) x\n    rw [â† hfSrc_comm, â† hfTgt_comm]\n    exact congrFun h x\n  Â· intro h\n    rw [hfSrc_comm, hfTgt_comm]\n    funext x\n    exact h x\n\n\nThere is an 'inclusion' map {\\mathbb{Z} \\xrightarrow{f} \\mathbb{Q}} in ğ‘º for which1. {\\mathbb{Z}^{â†»5\\times()} \\xrightarrow{f} \\mathbb{Q}^{â†»5\\times()}} is a map in ğ‘ºâ†», and2. \\mathbb{Q}^{â†»5\\times()} is an automorphism, and3. f is injective.Find the f and prove the three statements.\n\nRule is {f(x) = x / 1}.def f : â„¤ âŸ¶ â„š := fun x â†¦ (x : â„š)\n1. We show that {\\mathbb{Z}^{â†»5\\times()} \\xrightarrow{f} \\mathbb{Q}^{â†»5\\times()}} is a map in ğ‘ºâ†».def Z : SetWithEndomap := {\n  t := â„¤\n  carrier := Set.univ\n  toEnd := fun x â†¦ 5 * x\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef Q : SetWithEndomap := {\n  t := â„š\n  carrier := Set.univ\n  toEnd := fun x â†¦ 5 * x\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\nexample : Z âŸ¶ Q := âŸ¨\n  f,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext (x : â„¤)\n      dsimp [Z, Q, f]\n      norm_cast\nâŸ©\n2. We show that \\mathbb{Q}^{â†»5\\times()} is an automorphism.example : SetWithInvEndomap := {\n  t := Q.t\n  carrier := Q.carrier\n  toEnd := Q.toEnd\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  inv := by\n    let finv : â„š âŸ¶ â„š := fun x â†¦ x / 5\n    use finv\n    constructor <;> (funext x; dsimp [finv, Q]; ring)\n}\n3. We show that f is injective.example : âˆ€ {T : Type} (xâ‚ xâ‚‚ : T âŸ¶ â„¤),\n    f âŠš xâ‚ = f âŠš xâ‚‚ â†’ xâ‚ = xâ‚‚ := by\n  let p : â„š âŸ¶ â„¤ := fun y â†¦ y.num\n  have hâ‚ : p âŠš f = ğŸ™ â„¤ := by\n    dsimp [f, p]\n    funext x\n    congr\n  intro _ xâ‚ xâ‚‚ hâ‚‚\n  calc xâ‚\n    _ = ğŸ™ â„¤ âŠš xâ‚ := by rw [Category.comp_id]\n    _ = (p âŠš f) âŠš xâ‚ := by rw [hâ‚]\n    _ = p âŠš f âŠš xâ‚ := by rw [Category.assoc]\n    _ = p âŠš f âŠš xâ‚‚ := by rw [hâ‚‚]\n    _ = (p âŠš f) âŠš xâ‚‚ := by rw [Category.assoc]\n    _ = ğŸ™ â„¤ âŠš xâ‚‚ := by rw [hâ‚]\n    _ = xâ‚‚ := by rw [Category.comp_id]\n\n\nConsider our standard idempotentinductive X\n  | xâ‚€ | xâ‚\n\ndef Î± : X âŸ¶ X\n    | X.xâ‚€ => X.xâ‚€\n    | X.xâ‚ => X.xâ‚€\n\ndef XÎ± : SetWithIdemEndomap := {\n  t := X\n  carrier := Set.univ\n  toEnd := Î±\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  idem := by\n    funext x\n    cases x <;> rfl\n}\nand let Y^{â†»\\beta} be any automorphism. Show that any ğ‘ºâ†»-map {X^{â†»\\alpha} \\xrightarrow{f} Y^{â†»\\beta}} must be non-injective, i.e. must map both elements of X to the same (fixed) point of \\beta in Y.\n\nWe show that any ğ‘ºâ†»-map {X^{â†»\\alpha} \\xrightarrow{f} Y^{â†»\\beta}} must be non-injective.example (YÎ² : SetWithInvEndomap)\n    (f : XÎ±.toSetWithEndomap âŸ¶ YÎ².toSetWithEndomap)\n    : f X.xâ‚€ = f X.xâ‚ := by\n  obtain âŸ¨Î²inv, hÎ²_inv, _âŸ© := YÎ².inv\n  obtain âŸ¨f, _, hf_commâŸ© := f\n  have hf_comm_xâ‚€ : (f âŠš XÎ±.toEnd) X.xâ‚€ = (YÎ².toEnd âŠš f) X.xâ‚€ :=\n    congrFun hf_comm X.xâ‚€\n  have hf_comm_xâ‚ : (f âŠš XÎ±.toEnd) X.xâ‚ = (YÎ².toEnd âŠš f) X.xâ‚ :=\n    congrFun hf_comm X.xâ‚\n  dsimp [XÎ±, Î±] at hf_comm_xâ‚€ hf_comm_xâ‚\n  have hÎ²fx_eq : YÎ².toEnd (f X.xâ‚€) = YÎ².toEnd (f X.xâ‚) := by\n    rw [â† hf_comm_xâ‚€, hf_comm_xâ‚]\n  have h_cancel\n      : (Î²inv âŠš YÎ².toEnd) (f X.xâ‚€) = (Î²inv âŠš YÎ².toEnd) (f X.xâ‚) :=\n    congrArg Î²inv hÎ²fx_eq\n  rwa [hÎ²_inv] at h_cancel\n\n\nIf X^{â†»\\alpha} is any object of ğ‘ºâ†» for which there exists an injective ğ‘ºâ†»-map f to some Y^{â†»\\beta} where \\beta is in the subcategory of automorphisms, then \\alpha itself must be injective.\n\ncf. Mono f.val, Mono XÎ±.toEnd.val.example (XÎ± : SetWithEndomap) (YÎ² : SetWithInvEndomap)\n    (f : XÎ± âŸ¶ YÎ².toSetWithEndomap)\n    (hf_inj : âˆ€ {U : Type} (yâ‚ yâ‚‚ : U âŸ¶ XÎ±.t),\n        f.val âŠš yâ‚ = f.val âŠš yâ‚‚ â†’ yâ‚ = yâ‚‚)\n    : âˆ€ {T : Type} (xâ‚ xâ‚‚ : T âŸ¶ XÎ±.t),\n        XÎ±.toEnd âŠš xâ‚ = XÎ±.toEnd âŠš xâ‚‚ â†’ xâ‚ = xâ‚‚ := by\n  intro _ xâ‚ xâ‚‚ hâ‚\n  have hâ‚‚ : f.val âŠš XÎ±.toEnd âŠš xâ‚ = f.val âŠš XÎ±.toEnd âŠš xâ‚‚ := by\n    congrm f.val âŠš ?_\n    exact hâ‚\n  repeat rw [Category.assoc, f.property.2] at hâ‚‚\n  obtain âŸ¨Î²inv, hÎ²_invâŸ© := YÎ².inv\n  have hâ‚ƒ : Î²inv âŠš YÎ².toEnd âŠš f.val âŠš xâ‚ =\n      Î²inv âŠš YÎ².toEnd âŠš f.val âŠš xâ‚‚ := by\n    congrm Î²inv âŠš ?_\n    exact hâ‚‚\n  rw [Category.assoc, hÎ²_inv.1, Category.assoc (f.val âŠš xâ‚‚),\n      hÎ²_inv.1] at hâ‚ƒ\n  repeat rw [Category.comp_id] at hâ‚ƒ\n  exact hf_inj xâ‚ xâ‚‚ hâ‚ƒ\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article III: Examples of categories","header":"10. Retractions and injectivity","id":"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--10___-Retractions-and-injectivity"},"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--6___-Endomaps-as-special-graphs":{"contents":"If we denote the result of the [insertion] process by I(f), then {I(g \\circ f) = I(g) \\circ I(f)} so that our insertion I preserves the fundamental operation of categories.\n\nThe insertion I maps endomaps of sets to irreflexive graphs and maps morphisms between endomaps of sets to morphisms between irreflexive graphs â€” in other words, I is a functor. We again use our implementation of the category ğ‘ºâ‡Š of graphs.def functorSetWithEndomapToIrreflexiveGraph\n    : Functor SetWithEndomap IrreflexiveGraph := {\n  obj (X : SetWithEndomap) := {\n    tA := X.t\n    carrierA := Set.univ\n    tD := X.t\n    carrierD := Set.univ\n    toSrc := ğŸ™ X.t\n    toSrc_mem := fun _ â†¦ Set.mem_univ _\n    toTgt := X.toEnd\n    toTgt_mem := fun _ â†¦ Set.mem_univ _\n  }\n  map {X Y : SetWithEndomap} (f : X âŸ¶ Y) := {\n    val := (f, f)\n    property := by\n      obtain âŸ¨tX, carrierX, toEndXâŸ© := X\n      obtain âŸ¨tY, carrierY, toEndYâŸ© := Y\n      obtain âŸ¨f, hf_mtc, hf_commâŸ© := f\n      dsimp at f hf_mtc hf_comm\n      split_ands <;> (dsimp; intros; trivial)\n  }\n}\n\n-- Helper function to align to the notation in the book\ndef I {X Y : SetWithEndomap} (f : X âŸ¶ Y) :=\n  functorSetWithEndomapToIrreflexiveGraph.map f\n\nexample {X Y Z : SetWithEndomap}\n    (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : I (g âŠš f) = I g âŠš I f := rfl\n\n\n(Fullness) Show that if we are given any ğ‘ºâ‡Š-morphism\nX \\xrightarrow{f_A} Y,\\; X \\xrightarrow{f_D} Y\nbetween the special graphs that come via I from endomaps of sets, then it follows that {f_A = f_D}, so that the map itself comes via I from a map in ğ‘ºâ†».\n\nvariable (X' Y' : SetWithEndomap)\nUsing Category IrreflexiveGraph, we havedef graphâ‚ (S : SetWithEndomap) : IrreflexiveGraph := {\n  tA := S.t\n  carrierA := Set.univ\n  tD := S.t\n  carrierD := Set.univ\n  toSrc := ğŸ™ S.t\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := S.toEnd\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\nvariable (fâ‚ : graphâ‚ X' âŸ¶ graphâ‚ Y')\n\n-- Align to the notation in the book: fA is fâ‚.val.1, fD is fâ‚.val.2\nset_option quotPrecheck false\nlocal notation \"fAâ‚\" => fâ‚.val.1\nlocal notation \"fDâ‚\" => fâ‚.val.2\nset_option quotPrecheck true\n\nexample : fAâ‚ = fDâ‚ := by\n  obtain âŸ¨_, _ , hfSrc_comm, _âŸ© := fâ‚.property\n  dsimp [graphâ‚] at hfSrc_comm\n  exact hfSrc_comm.symm\nAlternatively, using functorSetWithEndomapToIrreflexiveGraph, we havedef graphâ‚‚ (S : SetWithEndomap) : IrreflexiveGraph :=\n  functorSetWithEndomapToIrreflexiveGraph.obj S\n\nvariable (fâ‚‚ : graphâ‚‚ X' âŸ¶ graphâ‚‚ Y')\n\nset_option quotPrecheck false\nlocal notation \"fAâ‚‚\" => fâ‚‚.val.1\nlocal notation \"fDâ‚‚\" => fâ‚‚.val.2\nset_option quotPrecheck true\n\nexample : fAâ‚‚ = fDâ‚‚ := by\n  obtain âŸ¨_, _ , hfSrc_comm, _âŸ© := fâ‚‚.property\n  dsimp [graphâ‚‚, functorSetWithEndomapToIrreflexiveGraph]\n      at hfSrc_comm\n  exact hfSrc_comm.symm\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article III: Examples of categories","header":"6. Endomaps as special graphs","id":"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--6___-Endomaps-as-special-graphs"}});