window.docContents[230].resolve({"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--5___-Irreflexive-graphs":{"contents":"Complete the specification of the two maps\n{X \\xrightarrow{s} P} \\quad\\text{and}\\quad {X \\xrightarrow{t} P}\nwhich express the source and target relations of the [given graph]. Is there any element of X at which s and t take the same value in P? Is there any element to which t assigns the value k?\n\nThe full specification of the two maps s and t is as follows:inductive X\n  | a | b | c | d | e\n\ninductive P\n  | k | m | n | p | q | r\n\ndef s : X âŸ¶ P\n    | X.a => P.k\n    | X.b => P.m\n    | X.c => P.k\n    | X.d => P.p\n    | X.e => P.m\n\ndef t : X âŸ¶ P\n    | X.a => P.m\n    | X.b => P.m\n    | X.c => P.m\n    | X.d => P.q\n    | X.e => P.r\ns and t take the same value in P at the element b of X.example : s X.b = t X.b := rfl\nThere is no element to which t assigns the value k.example : Â¬(âˆƒ x : X, t x = P.k) := by\n  push_neg\n  intro x\n  cases x <;> simp [t]\n\n\nThe category ğ‘ºâ‡Š of (irreflexive directed multi-) graphs is described on pp. 141â€“142. We implement the category ğ‘ºâ‡Š below.\n\n\n\nstructure IrreflexiveGraph where\n  tA : Type\n  carrierA : Set tA\n  tD : Type\n  carrierD : Set tD\n  toSrc : tA âŸ¶ tD\n  toSrc_mem {a} : a âˆˆ carrierA â†’ toSrc a âˆˆ carrierD\n  toTgt : tA âŸ¶ tD\n  toTgt_mem {a} : a âˆˆ carrierA â†’ toTgt a âˆˆ carrierD\n\ninstance instCategoryIrreflexiveGraph : Category IrreflexiveGraph where\n  Hom X Y := {\n    f : (X.tA âŸ¶ Y.tA) Ã— (X.tD âŸ¶ Y.tD) //\n        (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Y.carrierA) -- fA maps to codomain\n        âˆ§ (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Y.carrierD) -- fD maps to codomain\n        âˆ§ f.2 âŠš X.toSrc = Y.toSrc âŠš f.1 -- source commutes\n        âˆ§ f.2 âŠš X.toTgt = Y.toTgt âŠš f.1 -- target commutes\n  }\n  id X := âŸ¨\n    (ğŸ™ X.tA, ğŸ™ X.tD),\n    by\n      split_ands <;> first | exact fun _ hx â†¦ hx | rfl\n  âŸ©\n  comp := by\n    rintro _ _ _ âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©\n    exact âŸ¨\n      (g.1 âŠš f.1, g.2 âŠš f.2),\n      by\n        obtain âŸ¨hfA_mtc, hfD_mtc, hfSrc_comm, hfTgt_commâŸ© := hf\n        obtain âŸ¨hgA_mtc, hgD_mtc, hgSrc_comm, hgTgt_commâŸ© := hg\n        split_ands\n        Â· intro x hx\n          exact hgA_mtc (f.1 x) (hfA_mtc x hx)\n        Â· intro x hx\n          exact hgD_mtc (f.2 x) (hfD_mtc x hx)\n        Â· rw [â† Category.assoc, hfSrc_comm, Category.assoc, hgSrc_comm,\n              â† Category.assoc]\n        Â· rw [â† Category.assoc, hfTgt_comm, Category.assoc, hgTgt_comm,\n              â† Category.assoc]\n    âŸ©\n\n\nIf f is [the map of graphs]\n{X \\xrightarrow{f_A} Y},\\; {P \\xrightarrow{f_D} Q}\nand if\n{Y \\xrightarrow{g_A} Z},\\; {Q \\xrightarrow{g_D} R}\nis another map of graphs, show that the pair {g_A \\circ f_A,\\; g_D \\circ f_D} of ğ‘º-composites is also an ğ‘ºâ‡Š-map.\n\nvariable (X P Y Q Z R : Type)\n         (s t : X âŸ¶ P) (s' t' : Y âŸ¶ Q) (s'' t'' : Z âŸ¶ R)\n\nexample (fA : X âŸ¶ Y) (fD : P âŸ¶ Q) (gA : Y âŸ¶ Z) (gD : Q âŸ¶ R)\n    (hfSrc_comm : fD âŠš s = s' âŠš fA)\n    (hfTgt_comm : fD âŠš t = t' âŠš fA)\n    (hgSrc_comm : gD âŠš s' = s'' âŠš gA)\n    (hgTgt_comm : gD âŠš t' = t'' âŠš gA)\n    : (gD âŠš fD) âŠš s = s'' âŠš (gA âŠš fA)\n        âˆ§ (gD âŠš fD) âŠš t = t'' âŠš (gA âŠš fA)\n    := by\n  constructor\n  -- cf. instCategoryIrreflexiveGraph.comp above\n  Â· rw [â† Category.assoc, hfSrc_comm, Category.assoc, hgSrc_comm,\n        â† Category.assoc]\n  Â· rw [â† Category.assoc, hfTgt_comm, Category.assoc, hgTgt_comm,\n        â† Category.assoc]\nEquivalently, we can use our implementation of the category ğ‘ºâ‡Š of graphs.def graph (A D : Type) (src tgt : A âŸ¶ D) : IrreflexiveGraph := {\n  tA := A\n  carrierA := Set.univ\n  tD := D\n  carrierD := Set.univ\n  toSrc := src\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := tgt\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n\nexample (f : graph X P s t âŸ¶ graph Y Q s' t')\n    (g : graph Y Q s' t' âŸ¶ graph Z R s'' t'')\n    : graph X P s t âŸ¶ graph Z R s'' t'' := g âŠš f\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article III: Examples of categories","header":"5. Irreflexive graphs","id":"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--5___-Irreflexive-graphs"},"/Session-5___-Division-of-maps___-Sections-and-retractions/#A-Lean-Companion-to-Conceptual-Mathematics--Session-5___-Division-of-maps___-Sections-and-retractions--2___-A-special-case___-Constant-maps":{"contents":"A map that can be factored through \\mathbf{1} is called a constant map.\n\nWe implement IsConstantMap in Lean as follows:\n\n\n\ndef IsConstantMap {A C : Type} (h : A âŸ¶ C) :=\n  âˆƒ (f : A âŸ¶ One) (g : One âŸ¶ C), h = g âŠš f\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 5: Division of maps: Sections and retractions","header":"2. A special case: Constant maps","id":"/Session-5___-Division-of-maps___-Sections-and-retractions/#A-Lean-Companion-to-Conceptual-Mathematics--Session-5___-Division-of-maps___-Sections-and-retractions--2___-A-special-case___-Constant-maps"}});