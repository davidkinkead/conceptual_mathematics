window.docContents[24].resolve({"/Article-II___-Isomorphisms/#A-Lean-Companion-to-Conceptual-Mathematics--Article-II___-Isomorphisms--1___-Isomorphisms":{"contents":"A map {A \\xrightarrow{f} B} is called an isomorphism, or invertible map, if there is a map {B \\xrightarrow{g} A} for which {g \\circ f = 1_A} and {f \\circ g = 1_B}.A map g related to f by satisfying these equations is called an inverse for f.Two objects A and B are said to be isomorphic if there is at least one isomorphism {A \\xrightarrow{f} B}.\n\nThe corresponding mathlib definition for isomorphism is Iso (and IsIso), which we print below for reference.\n\n#print Iso\n\n\nstructure CategoryTheory.Iso.{v, u} {C : Type u} [Category.{v, u} C] (X Y : C) : Type v\nnumber of parameters: 4\nfields:\n  CategoryTheory.Iso.hom : X âŸ¶ Y\n  CategoryTheory.Iso.inv : Y âŸ¶ X\n  CategoryTheory.Iso.hom_inv_id : self.inv âŠš self.hom = ğŸ™ X := by\n    cat_disch\n  CategoryTheory.Iso.inv_hom_id : self.hom âŠš self.inv = ğŸ™ Y := by\n    cat_disch\nconstructor:\n  CategoryTheory.Iso.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (hom : X âŸ¶ Y) (inv : Y âŸ¶ X)\n    (hom_inv_id : inv âŠš hom = ğŸ™ X := by cat_disch) (inv_hom_id : hom âŠš inv = ğŸ™ Y := by cat_disch) : X â‰… Y\n\n\n#print IsIso\n\n\nclass CategoryTheory.IsIso.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} (f : X âŸ¶ Y) : Prop\nnumber of parameters: 5\nfields:\n  CategoryTheory.IsIso.out : âˆƒ inv, inv âŠš f = ğŸ™ X âˆ§ f âŠš inv = ğŸ™ Y\nconstructor:\n  CategoryTheory.IsIso.mk.{v, u} {C : Type u} [Category.{v, u} C] {X Y : C} {f : X âŸ¶ Y}\n    (out : âˆƒ inv, inv âŠš f = ğŸ™ X âˆ§ f âŠš inv = ğŸ™ Y) : IsIso f\n\n\nReflexive: A is isomorphic to A.Symmetric: If A is isomorphic to B, then B is isomorphic to A.Transitive: If A is isomorphic to B, and B is isomorphic to C, then A is isomorphic to C.\n\nThe respective mathlib definitions are Iso.refl, Iso.symm, and Iso.trans, which we print below for reference.\n\n#print Iso.refl\n\n\ndef CategoryTheory.Iso.refl.{v, u} : {C : Type u} â†’ [inst : Category.{v, u} C] â†’ (X : C) â†’ X â‰… X :=\nfun {C} [Category.{v, u} C] X â†¦ { hom := ğŸ™ X, inv := ğŸ™ X, hom_inv_id := â‹¯, inv_hom_id := â‹¯ }\n\n\n#print Iso.symm\n\n\ndef CategoryTheory.Iso.symm.{v, u} : {C : Type u} â†’ [inst : Category.{v, u} C] â†’ {X Y : C} â†’ (X â‰… Y) â†’ (Y â‰… X) :=\nfun {C} [Category.{v, u} C] {X Y} I â†¦ { hom := I.inv, inv := I.hom, hom_inv_id := â‹¯, inv_hom_id := â‹¯ }\n\n\n#print Iso.trans\n\n\ndef CategoryTheory.Iso.trans.{v, u} : {C : Type u} â†’\n  [inst : Category.{v, u} C] â†’ {X Y Z : C} â†’ (X â‰… Y) â†’ (Y â‰… Z) â†’ (X â‰… Z) :=\nfun {C} [Category.{v, u} C] {X Y Z} Î± Î² â†¦\n  { hom := Î².hom âŠš Î±.hom, inv := Î±.inv âŠš Î².inv, hom_inv_id := â‹¯, inv_hom_id := â‹¯ }\n\n\n(R) Show that {A \\xrightarrow{1_A} A} is an isomorphism. (Hint: find an inverse for 1_A.)(S) Show that if {A \\xrightarrow{f} B} is an isomorphism, and {B \\xrightarrow{g} A} is an inverse for f; then g is also an isomorphism. (Hint: find an inverse for g.)(T) Show that if {A \\xrightarrow{f} B} and {B \\xrightarrow{k} C} are isomorphisms, {A \\xrightarrow{k \\circ f} C} is also an isomorphism.\n\nvariable {ğ’ : Type u} [Category.{v, u} ğ’] {A B C : ğ’}\n(R) 1_A is an inverse for itself, so 1_A is an isomorphism.example : IsIso (ğŸ™ A) := by\n  use ğŸ™ A\n  constructor <;> exact Category.id_comp (ğŸ™ A)\n(S) f is an inverse for g, so g is an isomorphism. (Note that the hypothesis \"f is an isomorphism\" is redundant here and could be omitted.)example (f : A âŸ¶ B) (_ : IsIso f)\n    (g : B âŸ¶ A) (hg : g âŠš f = ğŸ™ A âˆ§ f âŠš g = ğŸ™ B)\n    : IsIso g := by\n  use f\n  exact âŸ¨hg.2, hg.1âŸ©\n(T) Composition of isomorphisms is transitive, so {k \\circ f} is an isomorphism.example (f : A âŸ¶ B) (hf : IsIso f) (k : B âŸ¶ C) (hk : IsIso k)\n    : IsIso (k âŠš f) := by\n  obtain âŸ¨finv, hfinvâŸ© := hf\n  obtain âŸ¨kinv, hkinvâŸ© := hk\n  use finv âŠš kinv\n  constructor\n  Â· rw [Category.assoc, â† Category.assoc k]\n    rw [hkinv.1, Category.id_comp, hfinv.1]\n  Â· rw [Category.assoc, â† Category.assoc finv]\n    rw [hfinv.2, Category.id_comp, hkinv.2]\n\n\nSuppose {B \\xrightarrow{g} A} and {B \\xrightarrow{k} A} are both inverses for {A \\xrightarrow{f} B}. Show that {g = k}.\n\nThe inverse of a map is unique (when it exists).example {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’} (f : A âŸ¶ B)\n    (g : B âŸ¶ A) (hg : g âŠš f = ğŸ™ A âˆ§ f âŠš g = ğŸ™ B)\n    (k : B âŸ¶ A) (hk : k âŠš f = ğŸ™ A âˆ§ f âŠš k = ğŸ™ B)\n    : g = k := by\n  calc\n    g = ğŸ™ A âŠš g := by rw [Category.comp_id]\n    _ = (k âŠš f) âŠš g := by rw [hk.1]\n    _ = k âŠš (f âŠš g) := by rw [Category.assoc]\n    _ = k âŠš ğŸ™ B := by rw [hg.2]\n    _ = k := by rw [Category.id_comp]\n\n\nIf f has an inverse, then f satisfies the two cancellation laws:(a) If {f \\circ h = f \\circ k}, then {h = k}.(b) If {h \\circ f = k \\circ f}, then {h = k}.Warning: The following 'cancellation law' is not correct, even if f has an inverse.(c) (wrong): If {h \\circ f = f \\circ k}, then {h = k}.\n\nvariable {ğ’ : Type u} [Category.{v, u} ğ’] {A B : ğ’}\n(a) We show that f is left-cancellative.example (f : A âŸ¶ B)\n    (hf : âˆƒ finv : B âŸ¶ A, finv âŠš f = ğŸ™ A âˆ§ f âŠš finv = ğŸ™ B)\n    (h : B âŸ¶ A) (k : B âŸ¶ A)\n    : f âŠš h = f âŠš k â†’ h = k := by\n  obtain âŸ¨finv, hfinvâ‚, hfinvâ‚‚âŸ© := hf\n  intro hâ‚\n  have hâ‚‚ : finv âŠš f âŠš h = finv âŠš f âŠš k := by rw [hâ‚]\n  repeat rw [Category.assoc] at hâ‚‚\n  rw [hfinvâ‚] at hâ‚‚\n  repeat rw [Category.comp_id] at hâ‚‚\n  exact hâ‚‚\n(b) We show that f is right-cancellative.example (f : A âŸ¶ B)\n    (hf : âˆƒ finv : B âŸ¶ A, finv âŠš f = ğŸ™ A âˆ§ f âŠš finv = ğŸ™ B)\n    (h : B âŸ¶ A) (k : B âŸ¶ A)\n    : h âŠš f = k âŠš f â†’ h = k := by\n  obtain âŸ¨finv, hfinvâ‚, hfinvâ‚‚âŸ© := hf\n  intro hâ‚\n  have hâ‚‚ : (h âŠš f) âŠš finv = (k âŠš f) âŠš finv := by rw [hâ‚]\n  repeat rw [â† Category.assoc] at hâ‚‚\n  rw [hfinvâ‚‚] at hâ‚‚\n  repeat rw [Category.id_comp] at hâ‚‚\n  exact hâ‚‚\n(c) We take our counterexample from endomaps on Fin 2, the canonical type with two elements.def f : Fin 2 âŸ¶ Fin 2\n  | 0 => 1\n  | 1 => 0\nf has an inverse, as required. (f is self-inverse.)example : f âŠš f = ğŸ™ (Fin 2) := by\n  funext x\n  fin_cases x <;> dsimp [f]\n\ndef h : Fin 2 âŸ¶ Fin 2\n  | 0 => 1\n  | 1 => 1\n\ndef k : Fin 2 âŸ¶ Fin 2\n  | 0 => 0\n  | 1 => 0\n\nexample : Â¬(h âŠš f = f âŠš k â†’ h = k) := by\n  push_neg\n  constructor\n  Â· funext x\n    fin_cases x <;> dsimp [f, h, k]\n  Â· by_contra hâ‚€\n    have hâ‚ : h 0 = 1 := rfl\n    have hâ‚‚ : k 0 = 0 := rfl\n    rw [â† hâ‚€, hâ‚] at hâ‚‚\n    norm_num at hâ‚‚\n\n\nFor each of the five maps below: decide whether it is invertible; and if it is invertible, find a 'formula' for the inverse map.1. \\mathbb{R} \\xrightarrow{f} \\mathbb{R},\\; f(x) = 3x + 72. \\mathbb{R}_{\\ge 0} \\xrightarrow{g} \\mathbb{R}_{\\ge 0},\\; g(x) = x^23. \\mathbb{R} \\xrightarrow{h} \\mathbb{R},\\; h(x) = x^24. \\mathbb{R} \\xrightarrow{k} \\mathbb{R}_{\\ge 0},\\; k(x) = x^25. \\mathbb{R}_{\\ge 0} \\xrightarrow{l} \\mathbb{R}_{\\ge 0},\\; l(x) = \\dfrac{1}{x + 1}\n\nSince all five maps have their domain and codomain as the real numbers (or a subset of the real numbers), we implement them as functions in Lean.f is invertible, with inverse {f^{-1}(x) = \\dfrac{x - 7}{3}}.example (f : â„ â†’ â„) (hf : âˆ€ x : â„, f x = 3 * x + 7)\n    : âˆƒ finv : â„ â†’ â„, finv âˆ˜ f = id âˆ§ f âˆ˜ finv = id := by\n  use fun x â†¦ (x - 7) / 3 -- fâ»Â¹(x)\n  constructor\n  Â· funext x\n    rw [Function.comp_apply, id_eq, hf x]\n    ring\n  Â· funext x\n    rw [Function.comp_apply, id_eq, hf ((x - 7) / 3)]\n    ring\ng is invertible, with inverse {g^{-1}(x) = \\sqrt{x}}.open NNReal in\nexample (g : â„â‰¥0 â†’ â„â‰¥0) (hg : âˆ€ x : â„â‰¥0, g x = x * x)\n  : âˆƒ ginv : â„â‰¥0 â†’ â„â‰¥0, ginv âˆ˜ g = id âˆ§ g âˆ˜ ginv = id := by\n  use fun x â†¦ NNReal.sqrt x -- gâ»Â¹(x)\n  constructor\n  Â· funext x\n    rw [Function.comp_apply, id_eq, hg x]\n    exact NNReal.sqrt_mul_self x\n  Â· funext x\n    rw [Function.comp_apply, id_eq, hg (sqrt x)]\n    exact mul_self_sqrt x\nh is not invertible, since {h(1) = h(-1) = 1}.example (h : â„ â†’ â„) (hh : âˆ€ x : â„, h x = x * x)\n    : Â¬(âˆƒ hinv : â„ â†’ â„, hinv âˆ˜ h = id âˆ§ h âˆ˜ hinv = id) := by\n  push_neg\n  intro hinv h_inv_left _\n  have hâ‚ : h 1 = 1 := by\n    rw [hh 1]\n    norm_num\n  have hâ‚‚ : h (-1) = 1 := by\n    rw [hh (-1)]\n    norm_num\n  have hâ‚ƒ : (hinv âˆ˜ h) 1 = 1:= by\n    rw [h_inv_left, id_eq]\n  have hâ‚„ : (hinv âˆ˜ h) (-1) = -1 := by\n    rw [h_inv_left, id_eq]\n  dsimp at hâ‚ƒ hâ‚„\n  rw [hâ‚] at hâ‚ƒ\n  rw [hâ‚‚] at hâ‚„\n  linarith\nk is not invertible, since {k(1) = k(-1) = 1}.open NNReal in\nexample (k : â„ â†’ â„â‰¥0) (hk : âˆ€ x : â„, k x = x * x)\n    : Â¬(âˆƒ kinv : â„â‰¥0 â†’ â„, kinv âˆ˜ k = id âˆ§ k âˆ˜ kinv = id) := by\n  push_neg\n  intro kinv h_inv_left _\n  have hâ‚ : k 1 = 1 := by\n    rw [â† coe_eq_one, hk 1]\n    norm_num\n  have hâ‚‚ : k (-1) = 1 := by\n    rw [â† coe_eq_one, hk (-1)]\n    norm_num\n  have hâ‚ƒ : (kinv âˆ˜ k) 1 = 1:= by\n    rw [h_inv_left, id_eq]\n  have hâ‚„ : (kinv âˆ˜ k) (-1) = -1 := by\n    rw [h_inv_left, id_eq]\n  dsimp at hâ‚ƒ hâ‚„\n  rw [hâ‚] at hâ‚ƒ\n  rw [hâ‚‚] at hâ‚„\n  linarith\nl is invertible, with inverse {l^{-1}(x) = \\dfrac{1}{x} - 1}, provided that we restrict the codomain of l to the interval {(0,1]}.TODO Exercise II.4.5\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article II: Isomorphisms","header":"1. Isomorphisms","id":"/Article-II___-Isomorphisms/#A-Lean-Companion-to-Conceptual-Mathematics--Article-II___-Isomorphisms--1___-Isomorphisms"}});