window.docContents[30].resolve({"/Session-15___-Objectification-of-properties-in-dynamical-systems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-15___-Objectification-of-properties-in-dynamical-systems--3___-Naming-arbitrary-elements":{"contents":"We implement the 'successor map' \\sigma : \\mathbb{N} \\rightarrow \\mathbb{N} defined by \\sigma(n) = n+1 (p. 178) as follows:\n\n\n\ndef œÉ : ‚Ñï ‚ü∂ ‚Ñï := (¬∑ + 1)\n\ndef ‚ÑïœÉ : SetWithEndomap := {\n  t := ‚Ñï\n  carrier := Set.univ\n  toEnd := œÉ\n  toEnd_mem := fun _ ‚Ü¶ Set.mem_univ _\n}\n\n\nFind all the maps from \\mathbb{N}^{‚Üª\\sigma} to C_4, the cycle of length 4.\n\nWe define C_4 as follows:def œÇ : Fin 4 ‚ü∂ Fin 4 := (¬∑ + 1)\n\ndef C‚ÇÑ : SetWithEndomap := {\n  t := Fin 4\n  carrier := Set.univ\n  toEnd := œÇ\n  toEnd_mem := fun _ ‚Ü¶ Set.mem_univ _\n}\nThen there are four distinct maps from \\mathbb{N}^{‚Üª\\sigma} to C_4. We give these maps below, in each case showing that we can form a valid morphism in the category ùë∫‚Üª.def f‚ÇÄ : ‚ÑïœÉ.t ‚ü∂ C‚ÇÑ.t\n  | Nat.zero => (0 : Fin 4) -- f(0) = 0\n  | n + 1 => œÇ (f‚ÇÄ n)\n\ndef f‚ÇÄ' : ‚ÑïœÉ ‚ü∂ C‚ÇÑ := ‚ü®\n  f‚ÇÄ,\n  by\n    constructor\n    ¬∑ exact fun _ _ ‚Ü¶ Set.mem_univ _\n    ¬∑ funext x\n      dsimp [f‚ÇÄ, ‚ÑïœÉ, C‚ÇÑ, œÉ, œÇ]\n‚ü©\n\ndef f‚ÇÅ : ‚ÑïœÉ.t ‚ü∂ C‚ÇÑ.t\n  | Nat.zero => (1 : Fin 4) -- f(0) = 1\n  | n + 1 => œÇ (f‚ÇÅ n)\n\ndef f‚ÇÅ' : ‚ÑïœÉ ‚ü∂ C‚ÇÑ := ‚ü®\n  f‚ÇÅ,\n  by\n    constructor\n    ¬∑ exact fun _ _ ‚Ü¶ Set.mem_univ _\n    ¬∑ funext x\n      dsimp [f‚ÇÅ, ‚ÑïœÉ, C‚ÇÑ, œÉ, œÇ]\n‚ü©\n\ndef f‚ÇÇ : ‚ÑïœÉ.t ‚ü∂ C‚ÇÑ.t\n  | Nat.zero => (2 : Fin 4) -- f(0) = 2\n  | n + 1 => œÇ (f‚ÇÇ n)\n\ndef f‚ÇÇ' : ‚ÑïœÉ ‚ü∂ C‚ÇÑ := ‚ü®\n  f‚ÇÇ,\n  by\n    constructor\n    ¬∑ exact fun _ _ ‚Ü¶ Set.mem_univ _\n    ¬∑ funext x\n      dsimp [f‚ÇÇ, ‚ÑïœÉ, C‚ÇÑ, œÉ, œÇ]\n‚ü©\n\ndef f‚ÇÉ : ‚ÑïœÉ.t ‚ü∂ C‚ÇÑ.t\n  | Nat.zero => (3 : Fin 4) -- f(0) = 3\n  | n + 1 => œÇ (f‚ÇÉ n)\n\ndef f‚ÇÉ' : ‚ÑïœÉ ‚ü∂ C‚ÇÑ := ‚ü®\n  f‚ÇÉ,\n  by\n    constructor\n    ¬∑ exact fun _ _ ‚Ü¶ Set.mem_univ _\n    ¬∑ funext x\n      dsimp [f‚ÇÉ, ‚ÑïœÉ, C‚ÇÑ, œÉ, œÇ]\n‚ü©\n\n\nShow that evaluation at 0 and iteration are inverse (to each other).\n\nTODO Exercise 15.3\n\nFor any dynamical system X^{‚Üª\\alpha}, show that \\alpha is itself a map of dynamical systems {X^{‚Üª\\alpha} \\xrightarrow{\\alpha} X^{‚Üª\\alpha}}.\n\nEssentially, the exercise is asking for a proof that Œ± ‚äö Œ± = Œ± ‚äö Œ±, which is trivially true.variable (X : Type) (Œ± : X ‚ü∂ X)\n\ndef XŒ± : SetWithEndomap := {\n  t := X\n  carrier := Set.univ\n  toEnd := Œ±\n  toEnd_mem := fun _ ‚Ü¶ Set.mem_univ _\n}\n\nexample : Œ± ‚äö (XŒ± X Œ±).toEnd = (XŒ± X Œ±).toEnd ‚äö Œ± := rfl\n\n\nShow that if {\\mathbb{N}^{‚Üª\\sigma} \\xrightarrow{f} Y^{‚Üª\\beta}} corresponds to y, then {\\mathbb{N}^{‚Üª\\sigma} \\xrightarrow{f \\circ \\sigma} Y^{‚Üª\\beta}} corresponds to \\beta(y).\n\nexample (YŒ≤ : SetWithEndomap) (f : ‚ÑïœÉ ‚ü∂ YŒ≤) (y : YŒ≤.t)\n    (hy : f.val (0 : ‚Ñï) = y)\n    : (f.val ‚äö œÉ) (0 : ‚Ñï) = YŒ≤.toEnd y := by\n  obtain ‚ü®f, _, hf_comm‚ü© := f\n  have h0 : ‚ÑïœÉ.toEnd (0 : ‚Ñï) = (1 : ‚Ñï) := rfl\n  rw [‚Üê hy]\n  dsimp [œÉ]\n  rw [‚Üê types_comp_apply _ YŒ≤.toEnd, ‚Üê hf_comm, types_comp_apply, h0]\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 15: Objectification of properties in dynamical systems","header":"3. Naming arbitrary elements","id":"/Session-15___-Objectification-of-properties-in-dynamical-systems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-15___-Objectification-of-properties-in-dynamical-systems--3___-Naming-arbitrary-elements"}});