window.docContents[60].resolve({"/Session-2___-Sets___-maps___-and-composition/#A-Lean-Companion-to-Conceptual-Mathematics--Session-2___-Sets___-maps___-and-composition--1___-Review-of-Article-I":{"contents":"If we recall that a point of a set A is a map from a singleton set \\mathbf{1} to A, we see that there is a simple test for equality of maps of sets {A \\xrightarrow{f} B} and {A \\xrightarrow{g} B}:\n\\text{If for each \\textit{point}}\\; \\mathbf{1} \\xrightarrow{a} A, f \\circ a = g \\circ a, \\;\\text{then}\\; f = g.\n\n\n\nWe generalise to types here.\n\nexample {A B : Type} {f g : A âŸ¶ B}\n    : (âˆ€ a : Point A, f âŠš a = g âŠš a) â†’ f = g := by\n  intro h\n  ext a'\n  exact congrFun (h (fun _ â†¦ a')) ()\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 2: Sets, maps, and composition","header":"1. Review of Article I","id":"/Session-2___-Sets___-maps___-and-composition/#A-Lean-Companion-to-Conceptual-Mathematics--Session-2___-Sets___-maps___-and-composition--1___-Review-of-Article-I"},"/Summary___-On-the-equation-p-___-j-___-1A/#A-Lean-Companion-to-Conceptual-Mathematics--Summary___-On-the-equation-p-___-j-___-1A":{"contents":"\n\n\n\nIf maps {A \\xrightarrow{j} X \\xrightarrow{p} A} satisfy {p \\circ j = 1_A}, several consequences follow:\n\nIn any category\n\n\n\nvariable {ğ’ : Type u} [Category.{v, u} ğ’] {A X : ğ’}\n         {j : A âŸ¶ X} {p : X âŸ¶ A}\n\n\nThe endomap {X \\xrightarrow{j \\circ p} X} (call it '\\alpha' for short) satisfies {\\alpha \\circ \\alpha = \\alpha}; we say \\alpha is idempotent. Written out in full, this is {(j \\circ p) \\circ (j \\circ p) = (j \\circ p)}.\n\n\n\nexample (hpj : p âŠš j = ğŸ™ A) : (j âŠš p) âŠš (j âŠš p) = (j âŠš p) := by\n  set Î± := j âŠš p\n  show Î± âŠš Î± = Î±\n  rw [Category.assoc, â† Category.assoc j, hpj, Category.id_comp]\n\n\n\n\nIn the category of finite sets\n\n\n\nWe use Fintypes instead of finite sets.\n\nvariable {A X : Type u} [Fintype A] [Fintype X] {j : A âŸ¶ X} {p : X âŸ¶ A}\n\n\n(1) p satisfies: for each member a of A, there is at least one member x of X for which {p(x) = a}; (We say p is surjective.)\n\n\n\nexample (hpj : p âŠš j = ğŸ™ A) : âˆ€ a : A, âˆƒ x : X, p x = a := by\n  intro a\n  use j a\n  rw [â† types_comp_apply j p, hpj]\n  rfl\n\n\nA morphism with this property in the category Type (and also in the category of sets) is a surjective function, defined in mathlib as Function.Surjective, which we print below for reference.\n\n#print Function.Surjective\n\n\ndef Function.Surjective.{u_1, u_2} : {Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (Î± â†’ Î²) â†’ Prop :=\nfun {Î±} {Î²} f â†¦ âˆ€ (b : Î²), âˆƒ a, f a = b\n\n\nHence we can restate our proof of (1) above as\n\nexample (hpj : p âŠš j = ğŸ™ A) : Function.Surjective p := by\n  intro a\n  use j a\n  rw [â† types_comp_apply j p, hpj]\n  rfl\n\n\nThe mathlib theorem epi_iff_surjective is also relevant here.\n\n\n\nexample {X Y : Type u} (f : X âŸ¶ Y) : Epi f â†” Function.Surjective f :=\n  epi_iff_surjective f\n\n\n(2) j satisfies: if {j(a_1) = j(a_2)}, then {a_1 = a_2}; (We say j is injective.)\n\n\n\nexample (hpj : p âŠš j = ğŸ™ A) : âˆ€ aâ‚ aâ‚‚ : A, j aâ‚ = j aâ‚‚ â†’ aâ‚ = aâ‚‚ := by\n  intro aâ‚ aâ‚‚ h\n  calc aâ‚\n    _ = ğŸ™ A aâ‚ := rfl\n    _ = (p âŠš j) aâ‚ := by rw [â† hpj]\n    _ = p (j aâ‚) := rfl\n    _ = p (j aâ‚‚) := by rw [h]\n    _ = (p âŠš j) aâ‚‚ := rfl\n    _ = ğŸ™ A aâ‚‚ := by rw [hpj]\n    _ = aâ‚‚ := rfl\n\n\nA morphism with this property in the category Type (and also in the category of sets) is an injective function, defined in mathlib as Function.Injective, which we print below for reference.\n\n#print Function.Injective\n\n\ndef Function.Injective.{u_1, u_2} : {Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (Î± â†’ Î²) â†’ Prop :=\nfun {Î±} {Î²} f â†¦ âˆ€ â¦ƒaâ‚ aâ‚‚ : Î±â¦„, f aâ‚ = f aâ‚‚ â†’ aâ‚ = aâ‚‚\n\n\nHence we can restate our proof of (2) above as\n\nexample (hpj : p âŠš j = ğŸ™ A) : Function.Injective j := by\n  intro aâ‚ aâ‚‚ h\n  calc aâ‚\n    _ = ğŸ™ A aâ‚ := rfl\n    _ = (p âŠš j) aâ‚ := by rw [â† hpj]\n    _ = p (j aâ‚) := rfl\n    _ = p (j aâ‚‚) := by rw [h]\n    _ = (p âŠš j) aâ‚‚ := rfl\n    _ = ğŸ™ A aâ‚‚ := by rw [hpj]\n    _ = aâ‚‚ := rfl\n\n\nThe mathlib theorem mono_iff_injective is also relevant here.\n\n\n\nexample {X Y : Type u} (f : X âŸ¶ Y) : Mono f â†” Function.Injective f :=\n  mono_iff_injective f\n\n\n(3) {\\#A \\le \\#X}, and if {\\#A = 0}, then {\\#X = 0} too!\n\nThe key step in our proof below that {\\#A \\le \\#X} is provided by the mathlib theorem Cardinal.mk_le_of_surjective, which states that the number of elements of the codomain of a surjective function is less than or equal to the number of elements of its domain, as follows:\n\n\n\nexample {Î± Î² : Type u} {f : Î± â†’ Î²} (hf_surj : Function.Surjective f)\n    : Cardinal.mk Î² â‰¤ Cardinal.mk Î± :=\n  Cardinal.mk_le_of_surjective hf_surj\n\n\nHence our proof is\n\nopen Cardinal in\nexample (hpj : p âŠš j = ğŸ™ A) : #A â‰¤ #X := by\n  have hpâ‚ : Section p := { section_ := j }\n  have hpâ‚‚ : Epi p := hpâ‚.epi\n  have hpâ‚ƒ : Function.Surjective p := (epi_iff_surjective p).mp hpâ‚‚\n  exact mk_le_of_surjective hpâ‚ƒ\n\n\nor, alternatively, using the counterpart mathlib theorem Cardinal.mk_le_of_injective,\n\nopen Cardinal in\nexample (hpj : p âŠš j = ğŸ™ A) : #A â‰¤ #X := by\n  have hjâ‚ : Retraction j := { retraction := p }\n  have hjâ‚‚ : Mono j := hjâ‚.mono\n  have hjâ‚ƒ : Function.Injective j := (mono_iff_injective j).mp hjâ‚‚\n  exact mk_le_of_injective hjâ‚ƒ\n\n\nFor the second part of (3) â€” that is, if {\\#A = 0}, then {\\#X = 0} â€” we first define the following lemma:\n\n\n\nopen Cardinal in\ntheorem h_cardinal_zero_eq_zero_iff {Î± : Type u} [Fintype Î±]\n    : #Î± = 0 â†” IsEmpty Î± := by\n  rw [mk_fintype]\n  norm_cast\n  exact Fintype.card_eq_zero_iff\n\n\nWe can then proceed as below. (Note that the primary assumption {p \\circ j = 1_A} is not required here, since any p that maps to an empty codomain must have an empty domain.)\n\nopen Cardinal in\nexample (_ : p âŠš j = ğŸ™ A) : #A = 0 â†’ #X = 0 := by\n  repeat rw [h_cardinal_zero_eq_zero_iff]\n  intro hA\n  apply IsEmpty.mk\n  intro x\n  exact hA.false (p x)\n\n\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics","header":"Summary: On the equation p âˆ˜ j = 1A","id":"/Summary___-On-the-equation-p-___-j-___-1A/#A-Lean-Companion-to-Conceptual-Mathematics--Summary___-On-the-equation-p-___-j-___-1A"}});