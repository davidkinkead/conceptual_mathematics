window.docContents[128].resolve({"/Session-12___-Categories-of-diagrams/#A-Lean-Companion-to-Conceptual-Mathematics--Session-12___-Categories-of-diagrams--2___-Family-trees":{"contents":"We implement the category ğ‘ºâ†»â†» in which an object is a set with a specified pair of endomaps, as described on p. 162.\n\n\n\nstructure SetWithTwoEndomaps extends SetWithEndomap where\n  toEnd2 : t âŸ¶ t\n  toEnd2_mem {a} : a âˆˆ carrier â†’ toEnd a âˆˆ carrier\n\ninstance instCatSetWithTwoEndomaps : Category SetWithTwoEndomaps where\n  Hom X Y := {\n    f : X.t âŸ¶ Y.t //\n        (âˆ€ x âˆˆ X.carrier, f x âˆˆ Y.carrier) -- maps to codomain\n        âˆ§ f âŠš X.toEnd = Y.toEnd âŠš f -- first endomap commutes\n        âˆ§ f âŠš X.toEnd2 = Y.toEnd2 âŠš f -- second endomap commutes\n  }\n  id X := âŸ¨\n    ğŸ™ X.t,\n    by\n      constructor\n      Â· intro _ hx\n        exact hx\n      Â· constructor <;> rfl\n  âŸ©\n  comp := by\n    rintro _ _ _ âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©\n    exact âŸ¨\n      g âŠš f,\n      by\n        obtain âŸ¨hf_mtc, hf_comm, hf2_commâŸ© := hf\n        obtain âŸ¨hg_mtc, hg_comm, hg2_commâŸ© := hg\n        constructor\n        Â· intro x hx\n          exact hg_mtc (f x) (hf_mtc x hx)\n        Â· constructor\n          Â· rw [â† Category.assoc, hf_comm, Category.assoc, hg_comm,\n              â† Category.assoc]\n          Â· rw [â† Category.assoc, hf2_comm, Category.assoc, hg2_comm,\n              â† Category.assoc]\n    âŸ©\n\n\n(a) Suppose {\\mathbf{P} = {}^{mâ†»}P^{â†»f}} is the set P of all people together with the endomaps {m = \\mathit{mother}} and {f = \\mathit{father}}. Show that 'gender' is a map in the category ğ‘ºâ†»â†» from \\mathbf{P} to the objectinductive Gender\n  | female | male\n\ndef mâ‚ : Gender âŸ¶ Gender := fun _ â†¦ Gender.female\n\ndef fâ‚ : Gender âŸ¶ Gender := fun _ â†¦ Gender.male\n\ndef G : SetWithTwoEndomaps := {\n  t := Gender\n  carrier := Set.univ\n  toEnd := mâ‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fâ‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n(b) In a certain society, all the people have always been divided into two 'clans', the Wolf-clan and the Bear-clan. Marriages within a clan are forbidden, so that a Wolf may not marry a Wolf. A child's clan is the same as that of its mother. Show that the sorting of people into clans is actually a map in ğ‘ºâ†»â†» from \\mathbf{P} to the objectinductive Clan\n  | wolf | bear\n\ndef mâ‚‚ : Clan âŸ¶ Clan := fun c â†¦ c\n\ndef fâ‚‚ : Clan âŸ¶ Clan\n  | Clan.wolf => Clan.bear\n  | Clan.bear => Clan.wolf\n\ndef C : SetWithTwoEndomaps := {\n  t := Clan\n  carrier := Set.univ\n  toEnd := mâ‚‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fâ‚‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n(c) Find appropriate 'father' and 'mother' maps to make {\\mathbf{G} \\times \\mathbf{C}} into an object in ğ‘ºâ†»â†» so that 'clan' and 'gender' can be combined into a single map {\\mathbf{P} \\rightarrow \\mathbf{G} \\times \\mathbf{C}}. (Later, when we have the precise definition of multiplication of objects in categories, you will see that {\\mathbf{G} \\times \\mathbf{C}} really is the product of \\mathbf{G} and \\mathbf{C}.)\n\n(a) For \\mathbf{P} in ğ‘ºâ†»â†», we first define a Person type to use in place of the set P of all people, and we identity each Person as being either a mother or a father.inductive ParentType\n  | isMother | isFather\n\nstructure Personâ‚ where\n  parentType : ParentType\nWe next define the mother and father endomaps on Person, which ignore their input (as irrelevant) and simply return a Person of the appropriate ParentType.def motherâ‚ : Personâ‚ âŸ¶ Personâ‚ := fun _ â†¦ âŸ¨ParentType.isMotherâŸ©\n\ndef fatherâ‚ : Personâ‚ âŸ¶ Personâ‚ := fun _ â†¦ âŸ¨ParentType.isFatherâŸ©\nNow we can define the object \\mathbf{P}.def Pâ‚ : SetWithTwoEndomaps := {\n  t := Personâ‚\n  carrier := Set.univ\n  toEnd := motherâ‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fatherâ‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\nLastly, we define the map gender, which sends each Person to their corresponding Gender.def gender : Pâ‚.t âŸ¶ G.t\n  | âŸ¨ParentType.isMotherâŸ© => Gender.female\n  | âŸ¨ParentType.isFatherâŸ© => Gender.male\nSince we can form a valid morphism using our categorical framework, it follows that gender is a map in the category ğ‘ºâ†»â†» from \\mathbf{P} to \\mathbf{G}.def gender' : Pâ‚ âŸ¶ G := âŸ¨\n  gender,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· constructor <;> rfl\nâŸ©\nFor good measure, we can also verify the two commutative properties explicitly.example : gender âŠš motherâ‚ = mâ‚ âŠš gender := rfl\n\nexample : gender âŠš fatherâ‚ = fâ‚ âŠš gender := rfl\n(b) The implementation of part (b) is similar to that of part (a), with an appropriate change to our Person structure to handle clan.inductive ParentClan\n  | isWolf | isBear\n\nstructure Personâ‚‚ where\n  parentClan : ParentClan\n\ndef motherâ‚‚ : Personâ‚‚ âŸ¶ Personâ‚‚ := fun p â†¦ âŸ¨p.parentClanâŸ©\n\ndef fatherâ‚‚ : Personâ‚‚ âŸ¶ Personâ‚‚\n  | âŸ¨ParentClan.isWolfâŸ© => âŸ¨ParentClan.isBearâŸ©\n  | âŸ¨ParentClan.isBearâŸ© => âŸ¨ParentClan.isWolfâŸ©\n\ndef Pâ‚‚ : SetWithTwoEndomaps := {\n  t := Personâ‚‚\n  carrier := Set.univ\n  toEnd := motherâ‚‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fatherâ‚‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef clan : Pâ‚‚.t âŸ¶ C.t\n  | âŸ¨ParentClan.isWolfâŸ© => Clan.wolf\n  | âŸ¨ParentClan.isBearâŸ© => Clan.bear\n\ndef clan' : Pâ‚‚ âŸ¶ C := âŸ¨\n  clan,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· constructor\n      all_goals\n        funext p\n        match p with\n        | âŸ¨ParentClan.isWolfâŸ© => rfl\n        | âŸ¨ParentClan.isBearâŸ© => rfl\nâŸ©\n(c) The implementation of part (c) is a combination of parts (a) and (b).structure Personâ‚ƒ where\n  parentType : ParentType\n  parentClan : ParentClan\n\ndef motherâ‚ƒ : Personâ‚ƒ âŸ¶ Personâ‚ƒ :=\n  fun p â†¦ âŸ¨ParentType.isMother, p.parentClanâŸ©\n\ndef fatherâ‚ƒ : Personâ‚ƒ âŸ¶ Personâ‚ƒ\n  | âŸ¨_, ParentClan.isWolfâŸ© => âŸ¨ParentType.isFather, ParentClan.isBearâŸ©\n  | âŸ¨_, ParentClan.isBearâŸ© => âŸ¨ParentType.isFather, ParentClan.isWolfâŸ©\n\ndef Pâ‚ƒ : SetWithTwoEndomaps := {\n  t := Personâ‚ƒ\n  carrier := Set.univ\n  toEnd := motherâ‚ƒ\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fatherâ‚ƒ\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\nAs required, we define appropriate 'mother' and 'father' maps (m and f, respectively, to align with the book).def mâ‚ƒ : (Gender Ã— Clan) âŸ¶ (Gender Ã— Clan) :=\n  fun (_, c) â†¦ (Gender.female, c)\n\ndef fâ‚ƒ : (Gender Ã— Clan) âŸ¶ (Gender Ã— Clan)\n  | (_, Clan.wolf) => (Gender.male, Clan.bear)\n  | (_, Clan.bear) => (Gender.male, Clan.wolf)\n\ndef GC : SetWithTwoEndomaps := {\n  t := Gender Ã— Clan\n  carrier := Set.univ\n  toEnd := mâ‚ƒ\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fâ‚ƒ\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef gender_and_clan : Pâ‚ƒ.t âŸ¶ GC.t\n  | âŸ¨ParentType.isMother, ParentClan.isWolfâŸ© =>\n        âŸ¨Gender.female, Clan.wolfâŸ©\n  | âŸ¨ParentType.isMother, ParentClan.isBearâŸ© =>\n        âŸ¨Gender.female, Clan.bearâŸ©\n  | âŸ¨ParentType.isFather, ParentClan.isWolfâŸ© =>\n        âŸ¨Gender.male, Clan.wolfâŸ©\n  | âŸ¨ParentType.isFather, ParentClan.isBearâŸ© =>\n        âŸ¨Gender.male, Clan.bearâŸ©\n\ndef gender_and_clan' : Pâ‚ƒ âŸ¶ GC := âŸ¨\n  gender_and_clan,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· constructor\n      all_goals\n        funext p\n        match p with\n        | âŸ¨ParentType.isMother, ParentClan.isWolfâŸ© => rfl\n        | âŸ¨ParentType.isMother, ParentClan.isBearâŸ© => rfl\n        | âŸ¨ParentType.isFather, ParentClan.isWolfâŸ© => rfl\n        | âŸ¨ParentType.isFather, ParentClan.isBearâŸ© => rfl\nâŸ©\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 12: Categories of diagrams","header":"2. Family trees","id":"/Session-12___-Categories-of-diagrams/#A-Lean-Companion-to-Conceptual-Mathematics--Session-12___-Categories-of-diagrams--2___-Family-trees"},"/Test-2/#A-Lean-Companion-to-Conceptual-Mathematics--Test-2":{"contents":"\n\n\n\nSuppose\nX^{â†»\\alpha} \\xrightarrow{f} Y^{â†»\\beta}\nis a map in ğ‘ºâ†». Show that if \\alpha has a fixed point, then \\beta must also have a fixed point.\n\nThe sequence of rewrites in the example below mirrors Danilo's solution on p. 205.example (X Y : SetWithEndomap) (f : X âŸ¶ Y) :\n    (âˆƒ x âˆˆ X.carrier, X.toEnd x = x) â†’\n    (âˆƒ y âˆˆ Y.carrier, Y.toEnd y = y) := by\n  obtain âŸ¨f, hf_mtc, hf_commâŸ© := f\n  intro âŸ¨x, hx, hÎ±âŸ©\n  use f x\n  constructor\n  Â· exact hf_mtc x hx\n  Â· rw [â† types_comp_apply _ Y.toEnd, â† hf_comm, types_comp_apply,\n        hÎ±]\n\n\nFind all maps of (irreflexive) graphs frominductive Aâ‚\n  | a | b\n\ninductive Dâ‚\n  | p | q | r\n\ndef Gâ‚ : IrreflexiveGraph := {\n  tA := Aâ‚\n  carrierA := Set.univ\n  tD := Dâ‚\n  carrierD := Set.univ\n  toSrc := fun\n    | Aâ‚.a => Dâ‚.p\n    | Aâ‚.b => Dâ‚.q\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | Aâ‚.a => Dâ‚.r\n    | Aâ‚.b => Dâ‚.r\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\ntoinductive Aâ‚‚\n  | c | d\n\ninductive Dâ‚‚\n  | v | w\n\ndef Gâ‚‚ : IrreflexiveGraph := {\n  tA := Aâ‚‚\n  carrierA := Set.univ\n  tD := Dâ‚‚\n  carrierD := Set.univ\n  toSrc := fun\n    | Aâ‚‚.c => Dâ‚‚.w\n    | Aâ‚‚.d => Dâ‚‚.v\n  toSrc_mem := fun _ â†¦ Set.mem_univ _\n  toTgt := fun\n    | Aâ‚‚.c => Dâ‚‚.w\n    | Aâ‚‚.d => Dâ‚‚.w\n  toTgt_mem := fun _ â†¦ Set.mem_univ _\n}\n(There are not more than a half-dozen of them.)\n\nThere are four maps, as given below (cf. the discussion of Omer's solution on pp. 207â€“210):def fâ‚ : Gâ‚ âŸ¶ Gâ‚‚ := {\n  val := (\n    fun -- maps arrows\n      | Aâ‚.a => Aâ‚‚.d\n      | Aâ‚.b => Aâ‚‚.d,\n    fun -- maps dots\n      | Dâ‚.p => Dâ‚‚.v\n      | Dâ‚.q => Dâ‚‚.v\n      | Dâ‚.r => Dâ‚‚.w\n  )\n  property := by\n    split_ands\n    all_goals\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n}\n\ndef fâ‚‚ : Gâ‚ âŸ¶ Gâ‚‚ := {\n  val := (\n    fun -- maps arrows\n      | Aâ‚.a => Aâ‚‚.c\n      | Aâ‚.b => Aâ‚‚.c,\n    fun -- maps dots\n      | Dâ‚.p => Dâ‚‚.w\n      | Dâ‚.q => Dâ‚‚.w\n      | Dâ‚.r => Dâ‚‚.w\n  )\n  property := by\n    split_ands\n    all_goals\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n}\n\ndef fâ‚ƒ : Gâ‚ âŸ¶ Gâ‚‚ := {\n  val := (\n    fun -- maps arrows\n      | Aâ‚.a => Aâ‚‚.c\n      | Aâ‚.b => Aâ‚‚.d,\n    fun -- maps dots\n      | Dâ‚.p => Dâ‚‚.w\n      | Dâ‚.q => Dâ‚‚.v\n      | Dâ‚.r => Dâ‚‚.w\n  )\n  property := by\n    split_ands\n    all_goals\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n}\n\ndef fâ‚„ : Gâ‚ âŸ¶ Gâ‚‚ := {\n  val := (\n    fun -- maps arrows\n      | Aâ‚.a => Aâ‚‚.d\n      | Aâ‚.b => Aâ‚‚.c,\n    fun -- maps dots\n      | Dâ‚.p => Dâ‚‚.v\n      | Dâ‚.q => Dâ‚‚.w\n      | Dâ‚.r => Dâ‚‚.w\n  )\n  property := by\n    split_ands\n    all_goals\n      first | exact fun _ _ â†¦ Set.mem_univ _\n            | funext x; cases x <;> rfl\n}\n\n\nFind an example of a set X and an endomap {X \\xrightarrow{\\alpha} X} with {\\alpha^2 = \\alpha^3} but {\\alpha \\neq \\alpha^2}.\n\ncf. the discussion of Katie's attempted solution on pp. 205â€“207.inductive X\n  | xâ‚ | xâ‚‚ | xâ‚ƒ\n\ndef Î± : End X\n  | X.xâ‚ => X.xâ‚‚\n  | X.xâ‚‚ => X.xâ‚ƒ\n  | X.xâ‚ƒ => X.xâ‚ƒ\n\nexample : Î± ^ 2 = Î± ^ 3 âˆ§ Î± â‰  Î± ^ 2 := by\n  constructor\n  Â· funext x\n    cases x <;> rfl\n  Â· by_contra h\n    have h_false : Î± X.xâ‚ = (Î± ^ 2) X.xâ‚ := congrFun h X.xâ‚\n    have hÎ± : Î± X.xâ‚ = X.xâ‚‚ := rfl\n    have hÎ±Î± : (Î± ^ 2) X.xâ‚ = X.xâ‚ƒ := rfl\n    rw [hÎ±, hÎ±Î±] at h_false\n    contradiction\nIn fact, since hÎ± and hÎ±Î± just establish definitional equalities, the contradiction tactic can take care of the last few steps automatically.example : Î± ^ 2 = Î± ^ 3 âˆ§ Î± â‰  Î± ^ 2 := by\n  constructor\n  Â· funext x\n    cases x <;> rfl\n  Â· by_contra h\n    have h_false : Î± X.xâ‚ = (Î± ^ 2) X.xâ‚ := congrFun h X.xâ‚\n    -- have hÎ± : Î± X.xâ‚ = X.xâ‚‚ := rfl\n    -- have hÎ±Î± : (Î± ^ 2) X.xâ‚ = X.xâ‚ƒ := rfl\n    -- rw [hÎ±, hÎ±Î±] at h_false\n    contradiction\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics","header":"Test 2","id":"/Test-2/#A-Lean-Companion-to-Conceptual-Mathematics--Test-2"}});