window.docContents[128].resolve({"/Session-12___-Categories-of-diagrams/#A-Lean-Companion-to-Conceptual-Mathematics--Session-12___-Categories-of-diagrams--2___-Family-trees":{"contents":"We implement the category ğ‘ºâ†»â†» in which an object is a set with a specified pair of endomaps, as described on p. 162.\n\n\n\nstructure SetWithTwoEndomaps extends SetWithEndomap where\n  toEnd2 : t âŸ¶ t\n  toEnd2_mem {a} : a âˆˆ carrier â†’ toEnd a âˆˆ carrier\n\ninstance instCatSetWithTwoEndomaps : Category SetWithTwoEndomaps where\n  Hom X Y := {\n    f : X.t âŸ¶ Y.t //\n        (âˆ€ x âˆˆ X.carrier, f x âˆˆ Y.carrier) -- maps to codomain\n        âˆ§ f âŠš X.toEnd = Y.toEnd âŠš f -- first endomap commutes\n        âˆ§ f âŠš X.toEnd2 = Y.toEnd2 âŠš f -- second endomap commutes\n  }\n  id X := âŸ¨\n    ğŸ™ X.t,\n    by\n      constructor\n      Â· intro _ hx\n        exact hx\n      Â· constructor <;> rfl\n  âŸ©\n  comp := by\n    rintro _ _ _ âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©\n    exact âŸ¨\n      g âŠš f,\n      by\n        obtain âŸ¨hf_mtc, hf_comm, hf2_commâŸ© := hf\n        obtain âŸ¨hg_mtc, hg_comm, hg2_commâŸ© := hg\n        constructor\n        Â· intro x hx\n          exact hg_mtc (f x) (hf_mtc x hx)\n        Â· constructor\n          Â· rw [â† Category.assoc, hf_comm, Category.assoc, hg_comm,\n              â† Category.assoc]\n          Â· rw [â† Category.assoc, hf2_comm, Category.assoc, hg2_comm,\n              â† Category.assoc]\n    âŸ©\n\n\n(a) Suppose {\\mathbf{P} = {}^{mâ†»}P^{â†»f}} is the set P of all people together with the endomaps {m = \\mathit{mother}} and {f = \\mathit{father}}. Show that 'gender' is a map in the category ğ‘ºâ†»â†» from \\mathbf{P} to the objectinductive Gender\n  | female | male\n\ndef mâ‚ : Gender âŸ¶ Gender := fun _ => Gender.female\n\ndef fâ‚ : Gender âŸ¶ Gender := fun _ => Gender.male\n\ndef G : SetWithTwoEndomaps := {\n  t := Gender\n  carrier := Set.univ\n  toEnd := mâ‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fâ‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n(b) In a certain society, all the people have always been divided into two 'clans', the Wolf-clan and the Bear-clan. Marriages within a clan are forbidden, so that a Wolf may not marry a Wolf. A child's clan is the same as that of its mother. Show that the sorting of people into clans is actually a map in ğ‘ºâ†»â†» from \\mathbf{P} to the objectinductive Clan\n  | wolf | bear\n\ndef mâ‚‚ : Clan âŸ¶ Clan := fun c => c\n\ndef fâ‚‚ : Clan âŸ¶ Clan\n  | Clan.wolf => Clan.bear\n  | Clan.bear => Clan.wolf\n\ndef C : SetWithTwoEndomaps := {\n  t := Clan\n  carrier := Set.univ\n  toEnd := mâ‚‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fâ‚‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n(c) Find appropriate 'father' and 'mother' maps to make {\\mathbf{G} \\times \\mathbf{C}} into an object in ğ‘ºâ†»â†» so that 'clan' and 'gender' can be combined into a single map {\\mathbf{P} \\rightarrow \\mathbf{G} \\times \\mathbf{C}}. (Later, when we have the precise definition of multiplication of objects in categories, you will see that {\\mathbf{G} \\times \\mathbf{C}} really is the product of \\mathbf{G} and \\mathbf{C}.)\n\n(a) For \\mathbf{P} in ğ‘ºâ†»â†», we first define a Person type to use in place of the set P of all people, and we identity each Person as being either a mother or a father.inductive ParentType\n  | isMother | isFather\n\nstructure Personâ‚ where\n  parentType : ParentType\nWe next define the mother and father endomaps on Person, which ignore their input (as irrelevant) and simply return a Person of the appropriate ParentType.def motherâ‚ : Personâ‚ âŸ¶ Personâ‚ := fun _ => âŸ¨ParentType.isMotherâŸ©\n\ndef fatherâ‚ : Personâ‚ âŸ¶ Personâ‚ := fun _ => âŸ¨ParentType.isFatherâŸ©\nNow we can define the object \\mathbf{P}.def Pâ‚ : SetWithTwoEndomaps := {\n  t := Personâ‚\n  carrier := Set.univ\n  toEnd := motherâ‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fatherâ‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\nLastly, we define the map gender, which sends each Person to their corresponding Gender.def gender : Pâ‚.t âŸ¶ G.t\n  | âŸ¨ParentType.isMotherâŸ© => Gender.female\n  | âŸ¨ParentType.isFatherâŸ© => Gender.male\nSince we can form a valid morphism using our categorical framework, it follows that gender is a map in the category ğ‘ºâ†»â†» from \\mathbf{P} to \\mathbf{G}.def gender' : Pâ‚ âŸ¶ G := âŸ¨\n  gender,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· constructor <;> rfl\nâŸ©\nFor good measure, we can also verify the two commutative properties explicitly.example : gender âŠš motherâ‚ = mâ‚ âŠš gender := rfl\n\nexample : gender âŠš fatherâ‚ = fâ‚ âŠš gender := rfl\n(b) The implementation of part (b) is similar to that of part (a), with an appropriate change to our Person structure to handle clan.inductive ParentClan\n  | isWolf | isBear\n\nstructure Personâ‚‚ where\n  parentClan : ParentClan\n\ndef motherâ‚‚ : Personâ‚‚ âŸ¶ Personâ‚‚ := fun p => âŸ¨p.parentClanâŸ©\n\ndef fatherâ‚‚ : Personâ‚‚ âŸ¶ Personâ‚‚\n  | âŸ¨ParentClan.isWolfâŸ© => âŸ¨ParentClan.isBearâŸ©\n  | âŸ¨ParentClan.isBearâŸ© => âŸ¨ParentClan.isWolfâŸ©\n\ndef Pâ‚‚ : SetWithTwoEndomaps := {\n  t := Personâ‚‚\n  carrier := Set.univ\n  toEnd := motherâ‚‚\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fatherâ‚‚\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef clan : Pâ‚‚.t âŸ¶ C.t\n  | âŸ¨ParentClan.isWolfâŸ© => Clan.wolf\n  | âŸ¨ParentClan.isBearâŸ© => Clan.bear\n\ndef clan' : Pâ‚‚ âŸ¶ C := âŸ¨\n  clan,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· constructor\n      all_goals (\n        funext p\n        match p with\n        | âŸ¨ParentClan.isWolfâŸ© => rfl\n        | âŸ¨ParentClan.isBearâŸ© => rfl\n      )\nâŸ©\n(c) The implementation of part (c) is a combination of parts (a) and (b).structure Personâ‚ƒ where\n  parentType : ParentType\n  parentClan : ParentClan\n\ndef motherâ‚ƒ : Personâ‚ƒ âŸ¶ Personâ‚ƒ :=\n  fun p => âŸ¨ParentType.isMother, p.parentClanâŸ©\n\ndef fatherâ‚ƒ : Personâ‚ƒ âŸ¶ Personâ‚ƒ\n  | âŸ¨_, ParentClan.isWolfâŸ© => âŸ¨ParentType.isFather, ParentClan.isBearâŸ©\n  | âŸ¨_, ParentClan.isBearâŸ© => âŸ¨ParentType.isFather, ParentClan.isWolfâŸ©\n\ndef Pâ‚ƒ : SetWithTwoEndomaps := {\n  t := Personâ‚ƒ\n  carrier := Set.univ\n  toEnd := motherâ‚ƒ\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fatherâ‚ƒ\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\nAs required, we define appropriate 'mother' and 'father' maps (m and f, respectively, to align with the book).def mâ‚ƒ : (Gender Ã— Clan) âŸ¶ (Gender Ã— Clan) :=\n  fun (_, c) => (Gender.female, c)\n\ndef fâ‚ƒ : (Gender Ã— Clan) âŸ¶ (Gender Ã— Clan)\n  | (_, Clan.wolf) => (Gender.male, Clan.bear)\n  | (_, Clan.bear) => (Gender.male, Clan.wolf)\n\ndef GC : SetWithTwoEndomaps := {\n  t := Gender Ã— Clan\n  carrier := Set.univ\n  toEnd := mâ‚ƒ\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n  toEnd2 := fâ‚ƒ\n  toEnd2_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef gender_and_clan : Pâ‚ƒ.t âŸ¶ GC.t\n  | âŸ¨ParentType.isMother, ParentClan.isWolfâŸ© =>\n        âŸ¨Gender.female, Clan.wolfâŸ©\n  | âŸ¨ParentType.isMother, ParentClan.isBearâŸ© =>\n        âŸ¨Gender.female, Clan.bearâŸ©\n  | âŸ¨ParentType.isFather, ParentClan.isWolfâŸ© =>\n        âŸ¨Gender.male, Clan.wolfâŸ©\n  | âŸ¨ParentType.isFather, ParentClan.isBearâŸ© =>\n        âŸ¨Gender.male, Clan.bearâŸ©\n\ndef gender_and_clan' : Pâ‚ƒ âŸ¶ GC := âŸ¨\n  gender_and_clan,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· constructor\n      all_goals (\n        funext p\n        match p with\n        | âŸ¨ParentType.isMother, ParentClan.isWolfâŸ© => rfl\n        | âŸ¨ParentType.isMother, ParentClan.isBearâŸ© => rfl\n        | âŸ¨ParentType.isFather, ParentClan.isWolfâŸ© => rfl\n        | âŸ¨ParentType.isFather, ParentClan.isBearâŸ© => rfl\n      )\nâŸ©\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 12: Categories of diagrams","header":"2. Family trees","id":"/Session-12___-Categories-of-diagrams/#A-Lean-Companion-to-Conceptual-Mathematics--Session-12___-Categories-of-diagrams--2___-Family-trees"}});