window.docContents[212].resolve({"/Quiz/#A-Lean-Companion-to-Conceptual-Mathematics--Quiz":{"contents":"\n\n\n\nGive an example of two explicit sets A and B and an explicit map {A \\xrightarrow{f} B} satisfying both:(a) there is a retraction for f, and(b) there is no section for f.Then explain how you know that f satisfies (a) and (b).\n\nWe use Fintypes here instead of sets.We give explicit types A and B and an explicit map f.inductive A\n  | a\n  deriving Fintype\n\ninductive B\n  | bâ‚ | bâ‚‚\n  deriving Fintype\n\ndef f : A âŸ¶ B\n  | A.a => B.bâ‚\nOur candidate retraction for f isdef r : B âŸ¶ A\n  | B.bâ‚ => A.a\n  | B.bâ‚‚ => A.a\nand we show that (a) is satisfied.example : IsRetraction f := by\n  use r\n  change r âŠš f = ğŸ™ A\n  funext x\n  fin_cases x\n  dsimp [f, r]\nWe show that f also satisfies (b).example : Â¬(IsSection f) := by\n  by_contra h\n  obtain âŸ¨s, hsâŸ© := h\n  have h_false := congrFun hs B.bâ‚‚\n  cases h_false\n\n\nIf {C \\xrightarrow{p} D \\xrightarrow{q} C} satisfy {p \\circ q \\circ p = p}, can you conclude that(a) {p \\circ q} is idempotent? If so, how?(b) {q \\circ p} is idempotent? If so, how?\n\nvariable {ğ’ : Type u} [Category.{v, u} ğ’] {C D : ğ’}\n         (p : C âŸ¶ D) (q : D âŸ¶ C) (hpq : p âŠš q âŠš p = p)\nWe show that {p \\circ q} is idempotent.example : IsIdempotent (p âŠš q) := {\n  idem := by\n    calc (p âŠš q) âŠš p âŠš q\n      _ = ((p âŠš q) âŠš p) âŠš q := by rw [Category.assoc]\n      _ = (p âŠš q âŠš p) âŠš q := by rw [â† Category.assoc p]\n      _ = p âŠš q := by rw [hpq]\n}\nWe show that {q \\circ p} is idempotent.example : IsIdempotent (q âŠš p) := {\n  idem := by\n    calc (q âŠš p) âŠš q âŠš p\n      _ = q âŠš p âŠš q âŠš p := by rw [Category.assoc (q âŠš p)]\n      _ = q âŠš p := by rw [hpq]\n}\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics","header":"Quiz","id":"/Quiz/#A-Lean-Companion-to-Conceptual-Mathematics--Quiz"},"/Session-15___-Objectification-of-properties-in-dynamical-systems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-15___-Objectification-of-properties-in-dynamical-systems--5___-Presentations-of-dynamical-systems":{"contents":"Find all the maps from the X^{â†»\\alpha} [below] to the Y^{â†»\\beta} [below]. (Unless I made a mistake, there are 14 of them.)inductive X\n  | a | aâ‚ | aâ‚‚ | aâ‚ƒ | aâ‚„ | b | c | d | dâ‚\n\n-- Subscripts correspond to powers of Î±\n-- (i.e., the number of applications of Î± to the element)\ndef Î± : X âŸ¶ X\n  | X.a => X.aâ‚\n  | X.aâ‚ => X.aâ‚‚\n  | X.aâ‚‚ => X.aâ‚ƒ\n  | X.aâ‚ƒ => X.aâ‚„\n  | X.aâ‚„ => X.aâ‚‚\n  | X.b => X.aâ‚‚\n  | X.c => X.aâ‚ƒ\n  | X.d => X.dâ‚\n  | X.dâ‚ => X.d\n\ninductive Y\n  | l | m | p | q | r | s | t | u | v | w | x | y | z\n\ndef Î² : Y âŸ¶ Y\n  | Y.l => Y.m\n  | Y.m => Y.l\n  | Y.p => Y.r\n  | Y.q => Y.r\n  | Y.r => Y.t\n  | Y.s => Y.t\n  | Y.t => Y.v\n  | Y.u => Y.s\n  | Y.v => Y.u\n  | Y.w => Y.x\n  | Y.x => Y.y\n  | Y.y => Y.w\n  | Y.z => Y.y\n\ndef XÎ± : SetWithEndomap := {\n  t := X\n  carrier := Set.univ\n  toEnd := Î±\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\ndef YÎ² : SetWithEndomap := {\n  t := Y\n  carrier := Set.univ\n  toEnd := Î²\n  toEnd_mem := fun _ â†¦ Set.mem_univ _\n}\n\n\nIt is possible the book does in fact contain a mistake here. Following the algorithm given on pp. 182â€“185, I find only 12 distinct maps, not 14. The 12 maps are given below, in each case with a proof that the map forms a valid morphism {X^{â†»\\alpha} \\rightarrow Y^{â†»\\beta}}.Map 1:(i) \\bar{a} = w satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = x satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = y satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = l satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.w\n  | X.aâ‚ => Y.x\n  | X.aâ‚‚ => Y.y\n  | X.aâ‚ƒ => Y.w\n  | X.aâ‚„ => Y.x\n  | X.b => Y.x\n  | X.c => Y.y\n  | X.d => Y.l\n  | X.dâ‚ => Y.m\n\ndef fâ‚' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 2:(i) \\bar{a} = w satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = x satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = y satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = m satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚‚ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.w\n  | X.aâ‚ => Y.x\n  | X.aâ‚‚ => Y.y\n  | X.aâ‚ƒ => Y.w\n  | X.aâ‚„ => Y.x\n  | X.b => Y.x\n  | X.c => Y.y\n  | X.d => Y.m\n  | X.dâ‚ => Y.l\n\ndef fâ‚‚' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚‚,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 3:(i) \\bar{a} = w satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = z satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = y satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = l satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚ƒ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.w\n  | X.aâ‚ => Y.x\n  | X.aâ‚‚ => Y.y\n  | X.aâ‚ƒ => Y.w\n  | X.aâ‚„ => Y.x\n  | X.b => Y.z\n  | X.c => Y.y\n  | X.d => Y.l\n  | X.dâ‚ => Y.m\n\ndef fâ‚ƒ' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚ƒ,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 4:(i) \\bar{a} = w satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = z satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = y satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = m satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚„ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.w\n  | X.aâ‚ => Y.x\n  | X.aâ‚‚ => Y.y\n  | X.aâ‚ƒ => Y.w\n  | X.aâ‚„ => Y.x\n  | X.b => Y.z\n  | X.c => Y.y\n  | X.d => Y.m\n  | X.dâ‚ => Y.l\n\ndef fâ‚„' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚„,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 5:(i) \\bar{a} = x satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = y satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = w satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = l satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚… : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.x\n  | X.aâ‚ => Y.y\n  | X.aâ‚‚ => Y.w\n  | X.aâ‚ƒ => Y.x\n  | X.aâ‚„ => Y.y\n  | X.b => Y.y\n  | X.c => Y.w\n  | X.d => Y.l\n  | X.dâ‚ => Y.m\n\ndef fâ‚…' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚…,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 6:(i) \\bar{a} = x satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = y satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = w satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = m satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚† : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.x\n  | X.aâ‚ => Y.y\n  | X.aâ‚‚ => Y.w\n  | X.aâ‚ƒ => Y.x\n  | X.aâ‚„ => Y.y\n  | X.b => Y.y\n  | X.c => Y.w\n  | X.d => Y.m\n  | X.dâ‚ => Y.l\n\ndef fâ‚†' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚†,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 7:(i) \\bar{a} = y satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = w satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = x satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = l satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚‡ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.y\n  | X.aâ‚ => Y.w\n  | X.aâ‚‚ => Y.x\n  | X.aâ‚ƒ => Y.y\n  | X.aâ‚„ => Y.w\n  | X.b => Y.w\n  | X.c => Y.x\n  | X.d => Y.l\n  | X.dâ‚ => Y.m\n\ndef fâ‚‡' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚‡,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 8:(i) \\bar{a} = y satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = w satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = x satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = m satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚ˆ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.y\n  | X.aâ‚ => Y.w\n  | X.aâ‚‚ => Y.x\n  | X.aâ‚ƒ => Y.y\n  | X.aâ‚„ => Y.w\n  | X.b => Y.w\n  | X.c => Y.x\n  | X.d => Y.m\n  | X.dâ‚ => Y.l\n\ndef fâ‚ˆ' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚ˆ,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 9:(i) \\bar{a} = y satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = w satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = z satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = l satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚‰ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.y\n  | X.aâ‚ => Y.w\n  | X.aâ‚‚ => Y.x\n  | X.aâ‚ƒ => Y.y\n  | X.aâ‚„ => Y.w\n  | X.b => Y.w\n  | X.c => Y.z\n  | X.d => Y.l\n  | X.dâ‚ => Y.m\n\ndef fâ‚‰' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚‰,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 10:(i) \\bar{a} = y satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = w satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = z satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = m satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚â‚€ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.y\n  | X.aâ‚ => Y.w\n  | X.aâ‚‚ => Y.x\n  | X.aâ‚ƒ => Y.y\n  | X.aâ‚„ => Y.w\n  | X.b => Y.w\n  | X.c => Y.z\n  | X.d => Y.m\n  | X.dâ‚ => Y.l\n\ndef fâ‚â‚€' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚â‚€,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 11:(i) \\bar{a} = z satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = y satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = w satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = l satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚â‚ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.z\n  | X.aâ‚ => Y.y\n  | X.aâ‚‚ => Y.w\n  | X.aâ‚ƒ => Y.x\n  | X.aâ‚„ => Y.y\n  | X.b => Y.y\n  | X.c => Y.w\n  | X.d => Y.l\n  | X.dâ‚ => Y.m\n\ndef fâ‚â‚' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚â‚,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\nMap 12:(i) \\bar{a} = z satisfies \\beta^5\\bar{a} = \\beta^2\\bar{a}(ii) \\bar{b} = y satisfies \\beta\\bar{b} = \\beta^2\\bar{a}(iii) \\bar{c} = w satisfies \\beta\\bar{c} = \\beta^3\\bar{a}(iv) \\bar{d} = m satisfies \\beta^2\\bar{d} = \\bar{d}def fâ‚â‚‚ : XÎ±.t âŸ¶ YÎ².t\n  | X.a => Y.z\n  | X.aâ‚ => Y.y\n  | X.aâ‚‚ => Y.w\n  | X.aâ‚ƒ => Y.x\n  | X.aâ‚„ => Y.y\n  | X.b => Y.y\n  | X.c => Y.w\n  | X.d => Y.m\n  | X.dâ‚ => Y.l\n\ndef fâ‚â‚‚' : XÎ± âŸ¶ YÎ² := âŸ¨\n  fâ‚â‚‚,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· funext x\n      cases x <;> rfl\nâŸ©\n\n\nOur procedure treated X^{â†»\\alpha} and  Y^{â†»\\beta} very differently. Suppose that in addition to a presentation of X^{â†»\\alpha} you had a presentation of Y^{â†»\\beta}. Try to find a method to calculate the solutions of the equations (\\bar{\\mathbf{R}}) without having to draw the picture of Y^{â†»\\beta}, but just working with a presentation. One can even program a computer to find all the maps f, starting from presentations of X^{â†»\\alpha} and Y^{â†»\\beta}.\n\nA presentation of Y^{â†»\\beta} is given below.(\\mathbf{L})l, \\beta l, p, \\beta p, \\beta^2 p, \\beta^3 p, \\beta^4 p, \\beta^5 p, q, z, \\beta z, \\beta^2 z, \\beta^3 z(\\mathbf{R})(i) \\beta^2 l = l(ii) \\beta^6 p = \\beta^2 p(iii) \\beta q = \\beta p(iv) \\beta^4 z = \\beta z\n\nFind a presentation for this system, which continues to the right forever.\n\nLet \\alpha be the endomap, and label the generators from top to bottom as a, b, and c. Then a presentation is given below.(\\mathbf{L})a, \\alpha a, \\alpha^2 a, \\ldots, b, c, \\alpha c(\\mathbf{R})(i) \\alpha b = \\alpha a(ii) \\alpha^2 c = \\alpha^2 a\n\nA non-autonomous dynamical system S is one in which the 'rule of evolution' {\\mathbb{N} \\times S \\xrightarrow{r} S} itself depends on time. These can be studied by reducing to the ordinary, or autonomous, system on the state space {X = \\mathbb{N} \\times S} with dynamics given by {\\rho(n, s) = \\langle n+1, r(n, s) \\rangle}. Show that for any r there is exactly one sequence u in S for which {u(n+1) = r(n, u(n))} and for which {u(0) = s_0} is a given starting point. (Hint: Reduce this to the universal property of {\\mathbb{N} = (\\mathbb{N}, \\sigma)} in ğ‘ºâ†».)\n\nTODO Exercise 15.12\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 15: Objectification of properties in dynamical systems","header":"5. Presentations of dynamical systems","id":"/Session-15___-Objectification-of-properties-in-dynamical-systems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-15___-Objectification-of-properties-in-dynamical-systems--5___-Presentations-of-dynamical-systems"},"/Session-5___-Division-of-maps___-Sections-and-retractions/#A-Lean-Companion-to-Conceptual-Mathematics--Session-5___-Division-of-maps___-Sections-and-retractions--5___-Stacking-or-sorting":{"contents":"Draw the internal diagrams of all the sections of f.\n\nWe label the elements in the first column of A as a_{11}, a_{12}, a_{13}, a_{14} and the elements in the second column of A as a_{21}, a_{22}; we label the element in the first column of B as b_1 and the element in the second column of B as b_2.inductive A\n  | aâ‚â‚ | aâ‚â‚‚ | aâ‚â‚ƒ | aâ‚â‚„ | aâ‚‚â‚ | aâ‚‚â‚‚\n  deriving Fintype\n\ninductive B\n  | bâ‚ | bâ‚‚\n  deriving Fintype\n\ndef f : A âŸ¶ B\n  | A.aâ‚â‚ => B.bâ‚\n  | A.aâ‚â‚‚ => B.bâ‚\n  | A.aâ‚â‚ƒ => B.bâ‚\n  | A.aâ‚â‚„ => B.bâ‚\n  | A.aâ‚‚â‚ => B.bâ‚‚\n  | A.aâ‚‚â‚‚ => B.bâ‚‚\nThen the sections aredef sâ‚ : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚\n  | B.bâ‚‚ => A.aâ‚‚â‚\n\nexample : f âŠš sâ‚ = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\ndef sâ‚‚ : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚‚\n  | B.bâ‚‚ => A.aâ‚‚â‚\n\nexample : f âŠš sâ‚‚ = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\ndef sâ‚ƒ : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚ƒ\n  | B.bâ‚‚ => A.aâ‚‚â‚\n\nexample : f âŠš sâ‚ƒ = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\ndef sâ‚„ : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚„\n  | B.bâ‚‚ => A.aâ‚‚â‚\n\nexample : f âŠš sâ‚„ = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\ndef sâ‚… : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚\n  | B.bâ‚‚ => A.aâ‚‚â‚‚\n\nexample : f âŠš sâ‚… = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\ndef sâ‚† : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚‚\n  | B.bâ‚‚ => A.aâ‚‚â‚‚\n\nexample : f âŠš sâ‚† = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\ndef sâ‚‡ : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚ƒ\n  | B.bâ‚‚ => A.aâ‚‚â‚‚\n\nexample : f âŠš sâ‚‡ = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\ndef sâ‚ˆ : B âŸ¶ A\n  | B.bâ‚ => A.aâ‚â‚„\n  | B.bâ‚‚ => A.aâ‚‚â‚‚\n\nexample : f âŠš sâ‚ˆ = ğŸ™ B := by funext x; fin_cases x <;> rfl\n\n\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 5: Division of maps: Sections and retractions","header":"5. Stacking or sorting","id":"/Session-5___-Division-of-maps___-Sections-and-retractions/#A-Lean-Companion-to-Conceptual-Mathematics--Session-5___-Division-of-maps___-Sections-and-retractions--5___-Stacking-or-sorting"}});