window.docContents[126].resolve({"/Session-4___-Division-of-maps___-Isomorphisms/#A-Lean-Companion-to-Conceptual-Mathematics--Session-4___-Division-of-maps___-Isomorphisms--4___-A-small-zoo-of-isomorphisms-in-other-categories":{"contents":"In some of the Exercises that follow, we start to make use of mathlib's implementation of the Category class (see the definition of category at the end of Article I) ahead of our more extensive reliance on it in later Articles and Sessions.\n\nFinish checking that d is an isomorphism in our category by showing that {h \\circ d} and {d \\circ h} are indeed identity maps.\n\nTo begin tackling this Exercise, we first define an abstract algebraic object as a type equipped with a carrier set and a 'combining-rule', which operates on elements of the carrier set (and which has the closure property).structure AlgebraicObj where\n  t : Type\n  carrier : Set t\n  oper : t â†’ t â†’ t\n  oper_mem {a b} : a âˆˆ carrier â†’ b âˆˆ carrier â†’ oper a b âˆˆ carrier\nNext we register a Category instance for our algebraic object, defining maps/morphisms between algebraic objects as morphisms between their underlying types that map elements of the domain carrier set to elements of the codomain carrier set and that respect the combining-rules.instance : Category AlgebraicObj where\n  Hom X Y := {\n    f : X.t âŸ¶ Y.t //\n        (âˆ€ x âˆˆ X.carrier, f x âˆˆ Y.carrier) -- maps to codomain\n        âˆ§ (âˆ€ xâ‚ âˆˆ X.carrier, -- respects combining-rules\n             âˆ€ xâ‚‚ âˆˆ X.carrier, f (X.oper xâ‚ xâ‚‚) = Y.oper (f xâ‚) (f xâ‚‚))\n  }\n  id X := âŸ¨\n    ğŸ™ X.t,\n    by\n      constructor\n      Â· intro _ hx\n        exact hx\n      Â· intros\n        rfl\n  âŸ©\n  comp := by\n    rintro _ _ _ âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©\n    exact âŸ¨\n      g âŠš f,\n      by\n        obtain âŸ¨hf_mtc, hf_combâŸ© := hf\n        obtain âŸ¨hg_mtc, hg_combâŸ© := hg\n        constructor\n        Â· intro x hx\n          exact hg_mtc (f x) (hf_mtc x hx)\n        Â· intro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚\n          dsimp\n          have hâ‚ := hf_comb xâ‚ hxâ‚ xâ‚‚ hxâ‚‚\n          rw [hâ‚]\n          have hâ‚‚ :=\n            hg_comb (f xâ‚) (hf_mtc xâ‚ hxâ‚) (f xâ‚‚) (hf_mtc xâ‚‚ hxâ‚‚)\n          rw [hâ‚‚]\n    âŸ©\nLastly we define the concrete algebraic object of real numbers with addition as the combining-rule.def RealAdd : AlgebraicObj := {\n  t := â„\n  carrier := Set.univ\n  oper := (Â· + Â·)\n  oper_mem := fun _ _ â†¦ Set.mem_univ _\n}\nWe are now ready to complete the Exercise by defining d and h as morphisms in our category and showing that they are inverses.def d : RealAdd âŸ¶ RealAdd := âŸ¨\n  fun (x : â„) â†¦ 2 * x,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· intros\n      dsimp [RealAdd]\n      ring\nâŸ©\n\nnoncomputable def h : RealAdd âŸ¶ RealAdd := âŸ¨\n  fun (x : â„) â†¦ x / 2,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· intros\n      dsimp [RealAdd]\n      ring\nâŸ©\n\nexample : IsIso d := {\n  out := by\n    use h\n    constructor\n    Â· show h âŠš d = ğŸ™ RealAdd\n      have hâ‚€ : h.val âˆ˜ d.val = id := by\n        funext x\n        dsimp [d, h, RealAdd]\n        ring\n      exact Subtype.eq hâ‚€\n    Â· show d âŠš h = ğŸ™ RealAdd\n      have hâ‚€ : d.val âˆ˜ h.val = id := by\n        funext x\n        dsimp [d, h, RealAdd]\n        ring\n      exact Subtype.eq hâ‚€\n}\n\n\nFind an isomorphism\n(\\{\\textit{odd}, \\textit{even}\\}, +) \\xrightarrow{f} (\\{\\textit{positive}, \\textit{negative}\\}, \\times).\nHint: There are only two invertible maps of sets from {\\{\\textit{odd}, \\textit{even}\\}} to {\\{\\textit{pos.}, \\textit{neg.}\\}}. One of them 'respects the combining rules', but the other doesn't.\n\nFor this Exercise, we continue to use the category of algebraic objects we defined in Exercise 1.Define addition for parity and multiplication for sign, and allow use of + and * notation.inductive Parity\n  | odd | even\n\ndef add : Parity â†’ Parity â†’ Parity\n  | Parity.odd, Parity.odd => Parity.even\n  | Parity.odd, Parity.even => Parity.odd\n  | Parity.even, Parity.odd => Parity.odd\n  | Parity.even, Parity.even => Parity.even\n\ninstance : Add Parity where\n  add := add\n\ninductive Sign\n  | pos | neg\n\ndef mul : Sign â†’ Sign â†’ Sign\n  | Sign.pos, Sign.pos => Sign.pos\n  | Sign.pos, Sign.neg => Sign.neg\n  | Sign.neg, Sign.pos => Sign.neg\n  | Sign.neg, Sign.neg => Sign.pos\n\ninstance : Mul Sign where\n  mul := mul\nCreate algebraic objects for parity with addition and sign with multiplication.def parityAdd : AlgebraicObj := {\n  t := Parity\n  carrier := Set.univ\n  oper := (Â· + Â·)\n  oper_mem := fun _ _ â†¦ Set.mem_univ _\n}\n\ndef signMul : AlgebraicObj := {\n  t := Sign\n  carrier := Set.univ\n  oper := (Â· * Â·)\n  oper_mem := fun _ _ â†¦ Set.mem_univ _\n}\nPropose a map f from parity to sign, and its inverse, and form the corresponding morphisms between algebraic objects.def f' : Parity âŸ¶ Sign\n  | Parity.odd => Sign.neg\n  | Parity.even => Sign.pos\n\ndef finv' : Sign âŸ¶ Parity\n  | Sign.pos => Parity.even\n  | Sign.neg => Parity.odd\n\ndef f : parityAdd âŸ¶ signMul := âŸ¨\n  f',\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· intro a _ b _\n      cases a <;> cases b <;> rfl\nâŸ©\n\ndef finv : signMul âŸ¶ parityAdd := âŸ¨\n  finv',\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· intro a _ b _\n      cases a <;> cases b <;> rfl\nâŸ©\nGive a proof that our proposed map f is indeed an isomorphism.example : IsIso f := {\n  out := by\n    use finv\n    constructor\n    Â· have hâ‚€ : finv.val âˆ˜ f.val = id := by\n        funext x\n        cases x <;> rfl\n      exact Subtype.eq hâ‚€\n    Â· have hâ‚€ : f.val âˆ˜ finv.val = id := by\n        funext x\n        cases x <;> rfl\n      exact Subtype.eq hâ‚€\n}\n\n\nAn unscrupulous importer has sold to the algebraic category section of our zoo some creatures which are not isomorphisms. Unmask the impostors.(a) {(\\mathbb{R}, +) \\xrightarrow{p} (\\mathbb{R}, +)} by 'plus 1': {p\\:x = x + 1}.(b) {(\\mathbb{R}, \\times) \\xrightarrow{\\mathit{sq}} (\\mathbb{R}, \\times)} by 'squaring': {\\mathit{sq}\\:x = x^2}.(c) {(\\mathbb{R}, \\times) \\xrightarrow{\\mathit{sq}} (\\mathbb{R}_{\\ge 0}, \\times)} by 'squaring': {\\mathit{sq}\\:x = x^2}.(d) {(\\mathbb{R}, +) \\xrightarrow{m} (\\mathbb{R}, +)} by 'minus': {m\\:x = -x}.(e) {(\\mathbb{R}, \\times) \\xrightarrow{m} (\\mathbb{R}, \\times)} by 'minus': {m\\:x = -x}.(f) {(\\mathbb{R}, \\times) \\xrightarrow{c} (\\mathbb{R}_{>0}, \\times)} by 'cubing': {c\\:x = x^3}.Hints: Exactly one is genuine. Some of the cruder impostors fail to be maps in our category, i.e. don't respect the combining-rules. The crudest is not even a map of sets with the indicated domain and codomain.\n\nFor clarity of presentation here, we restrict our use of the category of algebraic objects we defined in Exercise 1 to the one genuine case of (d).(a) p fails to respect the combining-rules.example {p : â„ âŸ¶ â„} (hp : âˆ€ x : â„, p x = x + 1)\n    : Â¬(âˆ€ a b : â„, p (a + b) = p a + p b) := by\n  push_neg\n  use 0, 0\n  rw [add_zero, ne_eq, left_eq_add, hp]\n  linarith\n(b) \\mathit{sq} has no retraction.example {sq : â„ âŸ¶ â„} (hsq : âˆ€ x : â„, sq x = x ^ 2)\n    : Â¬(âˆƒ r : â„ â†’ â„, (âˆ€ x : â„, r (sq x) = x)) := by\n  by_contra h\n  obtain âŸ¨r, hâŸ© := h\n  have hpos : r (sq 1) = 1 := h 1\n  have hneg : r (sq (-1)) = -1 := h (-1)\n  rw [hsq] at hpos hneg\n  rw [neg_sq, hpos] at hneg\n  linarith\n(c) \\mathit{sq} has no retraction.open NNReal in\nexample {sq : â„ âŸ¶ â„â‰¥0} (hsq : âˆ€ x : â„, sq x = x ^ 2)\n    : Â¬(âˆƒ r : â„ â†’ â„, (âˆ€ x : â„, r (sq x) = x)) := by\n  by_contra h\n  obtain âŸ¨r, hâŸ© := h\n  have hpos : r (sq 1) = 1 := h 1\n  have hneg : r (sq (-1)) = -1 := h (-1)\n  rw [hsq] at hpos hneg\n  rw [neg_sq, hpos] at hneg\n  linarith\n(d) m is genuine.def m : RealAdd âŸ¶ RealAdd := âŸ¨\n  fun (x : â„) â†¦ -x,\n  by\n    constructor\n    Â· exact fun _ _ â†¦ Set.mem_univ _\n    Â· intros\n      dsimp [RealAdd]\n      ring\nâŸ©\n\ndef minv := m\n\nexample : IsIso m := {\n  out := by\n    use minv\n    constructor\n    Â· have hâ‚€ : minv.val âˆ˜ m.val = id := by\n        funext x\n        dsimp [m, minv]\n        ring\n      exact Subtype.eq hâ‚€\n    Â· have hâ‚€ : m.val âˆ˜ minv.val = id := by\n        funext x\n        dsimp [m, minv]\n        ring\n      exact Subtype.eq hâ‚€\n}\n(e) m fails to respect the combining-rules.example {m : â„ âŸ¶ â„} (hm : âˆ€ x : â„, m x = -x)\n    : Â¬(âˆ€ a b : â„, m (a * b) = m a * m b) := by\n  push_neg\n  use 1, 1\n  rw [mul_one, ne_eq, hm]\n  linarith\n(f) c has an invalid codomain.abbrev â„pos := { x : â„ // x > 0 }\n\nexample {c : â„ â†’ â„pos} (hc : âˆ€ x : â„, c x = x ^ 3)\n    : âˆƒ x : â„, Â¬(âˆƒ y : â„pos, y.val = c x) := by\n  push_neg\n  use -1\n  rw [hc]\n  norm_num\n  intros\n  linarith\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Session 4: Division of maps: Isomorphisms","header":"4. A small zoo of isomorphisms in other categories","id":"/Session-4___-Division-of-maps___-Isomorphisms/#A-Lean-Companion-to-Conceptual-Mathematics--Session-4___-Division-of-maps___-Isomorphisms--4___-A-small-zoo-of-isomorphisms-in-other-categories"},"/Test-1/#A-Lean-Companion-to-Conceptual-Mathematics--Test-1":{"contents":"\n\n\n\nThroughout this probleminductive A\n  | Mara | Aurelio | Andrea\n  deriving Fintype\n(a) Find an invertible map {A \\xrightarrow{f} A}, different from the identity map 1_A.(b) Find an idempotent map {A \\xrightarrow{e} A}, different from the identity map 1_A.(c) Find another set B and two maps\nB \\xrightarrow{s} A \\xrightarrow{r} B\nfor which {r \\circ s = 1_B} and {s \\circ r = e}. (In this part, e is still the map you chose in part (b).)\n\nFor part (a), we give a map f, and we show that f is invertible.def f : A âŸ¶ A\n  | A.Mara => A.Aurelio\n  | A.Aurelio => A.Andrea\n  | A.Andrea => A.Mara\n\ndef finv : A âŸ¶ A\n  | A.Mara => A.Andrea\n  | A.Aurelio => A.Mara\n  | A.Andrea => A.Aurelio\n\nexample : IsIso f := {\n  out := by\n    use finv\n    constructor\n    all_goals\n      funext x\n      fin_cases x <;> dsimp [f, finv]\n}\nFor part (b), we give a map e, and we show that e is idempotent.def e : A âŸ¶ A\n  | A.Mara => A.Mara\n  | A.Aurelio => A.Mara\n  | A.Andrea => A.Mara\n\ninstance : IsIdempotent e := {\n  idem := by\n    funext x\n    fin_cases x <;> dsimp [e]\n}\nFor part (c), we give a set B and maps r and s, and we show that they satisfy the required properties.inductive B\n  | b\n  deriving Fintype\n\ndef r : A âŸ¶ B\n  | A.Mara => B.b\n  | A.Aurelio => B.b\n  | A.Andrea => B.b\n\ndef s : B âŸ¶ A\n  | B.b => A.Mara\n\nexample : r âŠš s = ğŸ™ B âˆ§ s âŠš r = e := by\n  constructor\n  Â· show r âŠš s = ğŸ™ B\n    rfl\n  Â· show s âŠš r = e\n    funext x\n    fin_cases x <;> rfl\n\n\n\\mathbb{R} is the set of all real numbers, and {\\mathbb{R} \\xrightarrow{f} \\mathbb{R}} is the map given by the explicit formula {f(x) = 4x â€” 7} for each input x. Show that f has an inverse map. To do this, give an explicit formula for the inverse map g, and then show that(a) {(g \\circ f)(x) = x} for each real number x, and that(b) {(f \\circ g)(x) = x} for each real number x.\n\nPut {g(x) = \\dfrac{x + 7}{4}}; then we haveexample (f : â„ âŸ¶ â„) (hf : âˆ€ x : â„, f x = 4 * x - 7)\n    : âˆƒ g, âˆ€ x : â„, (g âŠš f) x = x âˆ§ (f âŠš g) x = x := by\n  use fun x â†¦ (x + 7) / 4 -- g\n  intro x\n  dsimp [CategoryStruct.comp]\n  constructor\n  Â· -- Proof of part (a)\n    rw [hf x]\n    ring\n  Â· -- Proof of part (b)\n    rw [hf ((x + 7) / 4)]\n    ring\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics","header":"Test 1","id":"/Test-1/#A-Lean-Companion-to-Conceptual-Mathematics--Test-1"}});