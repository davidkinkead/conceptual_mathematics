window.docContents[50].resolve({"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--1___-The-category-______-of-endomaps-of-sets":{"contents":"The category ğ‘ºâ†» of endomaps of sets is described on pp. 136â€“137. We implement this category in Lean in a similar way to the category of algebraic objects that we developed in the solution to Session 4, Exercise 1. Our Lean implementation follows closely the definition of category given on p. 21, so we reproduce that definition here, interspersed with our comments (italicised) and the corresponding Lean code.\n\n\n\nA category consists of the DATA:(1) OBJECTSAn object in the category ğ‘ºâ†» is a set equipped with an endomap.structure SetWithEndomap where\n  t : Type\n  carrier : Set t\n  toEnd : t âŸ¶ t\n  toEnd_mem {a} : a âˆˆ carrier â†’ toEnd a âˆˆ carrier\n(2) MAPSA map in the category ğ‘ºâ†» is one which respects the given structure â€” i.e., a morphism which commutes. Note that we use a Lean subtype here instead of a Lean structure.def SetWithEndomapHom (X Y : SetWithEndomap) := {\n  f : X.t âŸ¶ Y.t //\n      (âˆ€ x âˆˆ X.carrier, f x âˆˆ Y.carrier) -- maps to codomain\n      âˆ§ f âŠš X.toEnd = Y.toEnd âŠš f -- commutes\n}\n(3) For each map f, one object as DOMAIN of f and one object as CODOMAIN of fAs given above, a SetWithEndomapHom is a subtype of morphisms between the underlying types of two SetWithEndomap objects, so the domain and codomain are already specified.(4) For each object A an IDENTITY MAP, which has domain A and codomain AWe define the identity map within the SetWithEndomapHom namespace to facilitate code re-use in some closely related category instances that follow shortly.def SetWithEndomapHom.id (X : SetWithEndomap)\n    : SetWithEndomapHom X X := âŸ¨\n  ğŸ™ X.t,\n  by\n    constructor\n    Â· intro _ hx\n      exact hx\n    Â· rfl\nâŸ©\n(5) For each pair of maps {A \\xrightarrow{f} B \\xrightarrow{g} C}, a COMPOSITE MAP map {A \\xrightarrow{g \\;\\mathrm{following}\\; f} C}We likewise define composition of maps within the SetWithEndomapHom namespace.def SetWithEndomapHom.comp {X Y Z : SetWithEndomap}\n    (f : SetWithEndomapHom X Y) (g : SetWithEndomapHom Y Z)\n    : SetWithEndomapHom X Z := âŸ¨\n  g.val âŠš f.val,\n  by\n    obtain âŸ¨hf_mtc, hf_commâŸ© := f.property\n    obtain âŸ¨hg_mtc, hg_commâŸ© := g.property\n    constructor\n    Â· intro x hx\n      exact hg_mtc (f.val x) (hf_mtc x hx)\n    Â· rw [â† Category.assoc, hf_comm, Category.assoc, hg_comm,\n          â† Category.assoc]\nâŸ©\nWe can now instantiate the category ğ‘ºâ†».instance instCatSetWithEndomap : Category SetWithEndomap where\n  Hom := SetWithEndomapHom\n  id := SetWithEndomapHom.id\n  comp := SetWithEndomapHom.comp\nsatisfying the following RULES:(i) IDENTITY LAWS: If {A \\xrightarrow{f} B}, then {1_B \\circ f = f} and {f \\circ 1_A = f}The identity laws are given by the methods Category.comp_id and Category.id_comp, respectively, which Lean is able to discharge automatically using tactics.(ii) ASSOCIATIVE LAW: If {A \\xrightarrow{f} B \\xrightarrow{g} C \\xrightarrow{h} D}, then {(h \\circ g) \\circ f = h \\circ (g \\circ f)}The associative law is given by the method Category.assoc, which Lean is likewise able to discharge automatically.\n\nFor good measure, we make the category ğ‘ºâ†» a concrete category.\n\ninstance {X Y : SetWithEndomap}\n    : FunLike (instCatSetWithEndomap.Hom X Y) X.t Y.t where\n  coe f := f.val\n  coe_injective' := fun _ _ h â†¦ Subtype.eq h\n\ninstance\n    : ConcreteCategory SetWithEndomap instCatSetWithEndomap.Hom where\n  hom f := f\n  ofHom f := f\n\n\nShow that if both\n{X^{â†»\\alpha} \\xrightarrow{f} Y^{â†»\\beta}}\n...and also\n{Y^{â†»\\beta} \\xrightarrow{g} Z^{â†»\\gamma}}\nare maps in ğ‘ºâ†», then the composite {g \\circ f} in ğ‘º actually defines another map in ğ‘ºâ†». Hint: What should the domain and the codomain (in the sense of ğ‘ºâ†») of this third map be? Transfer the definition (given for the case f) to the cases g and {g \\circ f}; then calculate that the equations satisfied by g and f imply the desired equation for {g \\circ f}.\n\nUsing only the category Type, we haveexample {X Y Z : Type}\n    (Î± : X âŸ¶ X) (Î² : Y âŸ¶ Y) (Î³ : Z âŸ¶ Z)\n    (f : X âŸ¶ Y) (hf_comm : f âŠš Î± = Î² âŠš f)\n    (g : Y âŸ¶ Z) (hg_comm : g âŠš Î² = Î³ âŠš g)\n    : (g âŠš f) âŠš Î± = Î³ âŠš (g âŠš f) := by\n  -- cf. SetWithEndomapHom.comp above\n  rw [â† Category.assoc, hf_comm, Category.assoc, hg_comm,\n      â† Category.assoc]\nUsing instead our implementation of the category ğ‘ºâ†» of endomaps of sets givesexample {X Y Z : SetWithEndomap} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : X âŸ¶ Z :=\n  g âŠš f\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article III: Examples of categories","header":"1. The category ğ‘ºâ†» of endomaps of sets","id":"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--1___-The-category-______-of-endomaps-of-sets"}});