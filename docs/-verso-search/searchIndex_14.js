window.docContents[14].resolve({"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--8___-Reflexive-graphs":{"contents":"The category of reflexive graphs is described on p. 145. We implement this category below.\n\n\n\nstructure ReflexiveGraph extends IrreflexiveGraph where\n  toCommonSection : tD âŸ¶ tA\n  toCommonSection_mem {d} : d âˆˆ carrierD â†’ toCommonSection d âˆˆ carrierA\n  section_src : toSrc âŠš toCommonSection = ğŸ™ tD\n  section_tgt : toTgt âŠš toCommonSection = ğŸ™ tD\n\ninstance : Category ReflexiveGraph where\n  Hom X Y := {\n    f : (X.tA âŸ¶ Y.tA) Ã— (X.tD âŸ¶ Y.tD) //\n        (âˆ€ x âˆˆ X.carrierA, f.1 x âˆˆ Y.carrierA) -- fA maps to codomain\n        âˆ§ (âˆ€ x âˆˆ X.carrierD, f.2 x âˆˆ Y.carrierD) -- fD maps to codomain\n        âˆ§ f.2 âŠš X.toSrc = Y.toSrc âŠš f.1 -- source commutes\n        âˆ§ f.2 âŠš X.toTgt = Y.toTgt âŠš f.1 -- target commutes\n        âˆ§ f.1 âŠš X.toCommonSection = Y.toCommonSection âŠš f.2\n  }\n  id X := âŸ¨\n    (ğŸ™ X.tA, ğŸ™ X.tD),\n    by\n      split_ands <;> first | exact fun _ hx â†¦ hx | rfl\n  âŸ©\n  comp := by\n    rintro _ _ _ âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©\n    exact âŸ¨\n      (g.1 âŠš f.1, g.2 âŠš f.2),\n      by\n        obtain âŸ¨hfA_mtc, hfD_mtc, hfSrc_comm, hfTgt_comm,\n            hfCommonSection_commâŸ© := hf\n        obtain âŸ¨hgA_mtc, hgD_mtc, hgSrc_comm, hgTgt_comm,\n            hgCommonSection_commâŸ© := hg\n        split_ands\n        Â· intro x hx\n          exact hgA_mtc (f.1 x) (hfA_mtc x hx)\n        Â· intro x hx\n          exact hgD_mtc (f.2 x) (hfD_mtc x hx)\n        Â· rw [â† Category.assoc, hfSrc_comm, Category.assoc, hgSrc_comm,\n              â† Category.assoc]\n        Â· rw [â† Category.assoc, hfTgt_comm, Category.assoc, hgTgt_comm,\n              â† Category.assoc]\n        Â· rw [â† Category.assoc, hfCommonSection_comm, Category.assoc,\n              hgCommonSection_comm, â† Category.assoc]\n    âŸ©\n\n\nIn a reflexive graph, the two endomaps {e_1 = is}, {e_0 = it} of the set of arrows are not only idempotent, but even satisfy four equations:\ne_k e_j = e_j \\quad\\text{for}\\quad k, j = 0, 1.\n\nWe use our implementation of the category of reflexive graphs.variable (X : ReflexiveGraph)\nDefine the two endomaps {e_1 = is}, {e_0 = it}.variable (eâ‚ eâ‚€ : X.tA âŸ¶ X.tA)\n         (hâ‚ : eâ‚ = X.toCommonSection âŠš X.toSrc)\n         (hâ‚€ : eâ‚€ = X.toCommonSection âŠš X.toTgt)\ne_0 e_0 = e_0example : eâ‚€ âŠš eâ‚€ = eâ‚€ := by\n  rw [hâ‚€, Category.assoc, â† Category.assoc X.toCommonSection,\n      X.section_tgt, Category.id_comp]\ne_0 e_1 = e_1example : eâ‚€ âŠš eâ‚ = eâ‚ := by\n  rw [hâ‚€, hâ‚, Category.assoc, â† Category.assoc X.toCommonSection,\n      X.section_tgt, Category.id_comp]\ne_1 e_0 = e_0example : eâ‚ âŠš eâ‚€ = eâ‚€ := by\n  rw [hâ‚, hâ‚€, Category.assoc, â† Category.assoc X.toCommonSection,\n      X.section_src, Category.id_comp]\ne_1 e_1 = e_1example : eâ‚ âŠš eâ‚ = eâ‚ := by\n  rw [hâ‚, Category.assoc, â† Category.assoc X.toCommonSection,\n      X.section_src, Category.id_comp]\n\n\nShow that if f_A, f_D in ğ‘º constitute a map of reflexive graphs, then f_D is determined by f_A and the internal structure of the two graphs.\n\nf is a morphism in our category of reflexive graphs.variable (X Y : ReflexiveGraph) (f : X âŸ¶ Y)\n\n-- Align to the notation in the book\nset_option quotPrecheck false\nlocal notation \"fA\" => f.val.1\nlocal notation \"fD\" => f.val.2\nset_option quotPrecheck true\n\nlocal notation \"s\" => X.toSrc\nlocal notation \"s'\" => Y.toSrc\nlocal notation \"t\" => X.toTgt\nlocal notation \"t'\" => Y.toTgt\nlocal notation \"i\" => X.toCommonSection\nlocal notation \"i'\" => Y.toCommonSection\nThen f_D is determined by f_A and the internal structure of the two graphs.example : fD = s' âŠš fA âŠš i := by\n  rw [â† Category.id_comp fD, â† X.section_src]\n  repeat rw [Category.assoc]\n  congrm ?_ âŠš X.toCommonSection\n  exact f.property.2.2.1\nOr, alternatively,example : fD = t' âŠš fA âŠš i := by\n  rw [â† Category.id_comp fD, â† X.section_tgt]\n  repeat rw [Category.assoc]\n  congrm ?_ âŠš X.toCommonSection\n  exact f.property.2.2.2.1\n\n\nConsider a structure involving two sets and four maps as in\nM \\xrightarrow{\\varphi} M,\\; F \\xrightarrow{\\varphi'} M,\\; F \\xrightarrow{\\mu} F,\\; M \\xrightarrow{\\mu'} F \\quad\\text{(no equations required)}\n(for example {M = \\mathit{males}}, {F = \\mathit{females}}, \\varphi and \\varphi' are \\mathit{father}, and \\mu and \\mu' are \\mathit{mother}). Devise a rational definition of map between such structures in order to make them into a category.\n\nDefine the structure.structure ParentLike where\n  tM : Type\n  carrierM : Set tM\n  tF : Type\n  carrierF : Set tF\n  Ï† : tM âŸ¶ tM\n  Ï†_mem {m} : m âˆˆ carrierM â†’ Ï† m âˆˆ carrierM\n  Ï†' : tF âŸ¶ tM\n  Ï†'_mem {f} : f âˆˆ carrierF â†’ Ï†' f âˆˆ carrierM\n  Î¼ : tF âŸ¶ tF\n  Î¼_mem {f} : f âˆˆ carrierF â†’ Î¼ f âˆˆ carrierF\n  Î¼' : tM âŸ¶ tF\n  Î¼'_mem {m} : m âˆˆ carrierM â†’ Î¼' m âˆˆ carrierF\nDefine a map between such structures.def ParentLikeHom (X Y : ParentLike) := {\n  f : (X.tM âŸ¶ Y.tM) Ã— (X.tF âŸ¶ Y.tF) //\n      (âˆ€ x âˆˆ X.carrierM, f.1 x âˆˆ Y.carrierM) -- f.1 maps to codomain\n      âˆ§ (âˆ€ x âˆˆ X.carrierF, f.2 x âˆˆ Y.carrierF) -- f.2 maps to codomain\n      âˆ§ f.1 âŠš X.Ï† = Y.Ï† âŠš f.1 -- Ï† commutes\n      âˆ§ f.1 âŠš X.Ï†' = Y.Ï†' âŠš f.2 -- Ï†' commutes\n      âˆ§ f.2 âŠš X.Î¼ = Y.Î¼ âŠš f.2 -- Î¼ commutes\n      âˆ§ f.2 âŠš X.Î¼' = Y.Î¼' âŠš f.1 -- Î¼' commutes\n}\nThis map between structures makes them into a category.instance : Category ParentLike where\n  Hom := ParentLikeHom -- our map between ParentLike structures\n  id X := âŸ¨\n    (ğŸ™ X.tM, ğŸ™ X.tF),\n    by\n      split_ands <;> first | exact fun _ hx â†¦ hx | rfl\n  âŸ©\n  comp := by\n    rintro _ _ _ âŸ¨f, hfâŸ© âŸ¨g, hgâŸ©\n    exact âŸ¨\n      (g.1 âŠš f.1, g.2 âŠš f.2),\n      by\n        obtain âŸ¨hfM_mtc, hfF_mtc, hfÏ†_comm, hfÏ†'_comm, hfÎ¼_comm,\n            hfÎ¼'_commâŸ© := hf\n        obtain âŸ¨hgM_mtc, hgF_mtc, hgÏ†_comm, hgÏ†'_comm, hgÎ¼_comm,\n            hgÎ¼'_commâŸ© := hg\n        split_ands\n        Â· intro x hx\n          exact hgM_mtc (f.1 x) (hfM_mtc x hx)\n        Â· intro x hx\n          exact hgF_mtc (f.2 x) (hfF_mtc x hx)\n        Â· rw [â† Category.assoc, hfÏ†_comm, Category.assoc, hgÏ†_comm,\n              â† Category.assoc]\n        Â· rw [â† Category.assoc, hfÏ†'_comm, Category.assoc, hgÏ†'_comm,\n              â† Category.assoc]\n        Â· rw [â† Category.assoc, hfÎ¼_comm, Category.assoc, hgÎ¼_comm,\n              â† Category.assoc]\n        Â· rw [â† Category.assoc, hfÎ¼'_comm, Category.assoc, hgÎ¼'_comm,\n              â† Category.assoc]\n    âŸ©\n\n\n","context":"A Lean Companion to Conceptual Mathematics\u0009Article III: Examples of categories","header":"8. Reflexive graphs","id":"/Article-III___-Examples-of-categories/#A-Lean-Companion-to-Conceptual-Mathematics--Article-III___-Examples-of-categories--8___-Reflexive-graphs"},"/Session-10___-Brouwer___s-theorems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-10___-Brouwer___s-theorems":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n","context":"A Lean Companion to Conceptual Mathematics","header":"Session 10: Brouwer's theorems","id":"/Session-10___-Brouwer___s-theorems/#A-Lean-Companion-to-Conceptual-Mathematics--Session-10___-Brouwer___s-theorems"}});